---
title: 代理模式(结构型)
date: 
categories: Design Pattern
tags:
- C++
- Design Pattern
- Structural Pattern
---

## 前言
---

<!--more-->

## 代理模式
---
在一个陌生的城市找房子住的时候，一般都需要通过房产中介或者熟人介绍的方式来找房子。这个第三方的角色相当于代理的角色，负责代理真实的房东或业主来给我们提供相关的租房信息，而不需要我们直接与房东接触。同时，而为了安全性，一般代理还会让我们进行身份验证，同时为了方便租户管理，他们还会记录相关的租户信息。这里的第三方角色就是本文将要介绍的代理模式中的代理对象。
> 这里涉及到了保护代理和引用计数代理两种类型

### 意图
为其他对象提供一种代理以控制对这个对象的访问

### 参与者
- Proxy
保存一个引用使得代理可以访问实体，若RealSubject和Subject的接口相同，Proxy会引用Subject
提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体
控制对实体的存取，并可能负责创建和删除它

- Subject
定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。

- RealSubject
定义Proxy所代表的实体

>代理根据其种类，在适当的时候向RealSubject转发请求

### 模式结构
![flyweight_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FFlyweight_Abstract.PNG)

### 代码实现
1. 首先定义抽象的`Flyweight`,并提供`Operate()`接口，接受外部状态：
```
// Flyweight抽象类
class Flyweight
{
private:
    // 内部状态，也可以放在ConcreteFlyweight中
    string _intraState;
protected:
    Flyweight(string intraState) : _intraState(intraState) {};
public:
    //操作外部状态extraState
    virtual void Operate(const string& extraState) = 0;
    virtual ~Flyweight() {};
public:
    // 内部状态回读接口，也可以放在ConcreteFlyweight中
    string getIntraState(void)
    {
        return _intraState;
    }
};
```

2. 再分别定义`Flyweight`类的两个子类，共享的`ConcreteFlyweight`类和非共享的 `UnsharedConcreteFlyweight`类，并分别实现其`Operate()`接口：
```
// 共享Flyweight的具体子类
class ConcreteFlyweight : public Flyweight
{
public:
    ConcreteFlyweight(string intraState) : Flyweight(intraState) {};
public:
    virtual void Operate(const string& extraState)
    {
        cout << "concrete flyweight intraState: " <<  getIntraState() << endl; // intra state & extra state
        cout << "concrete flyweight extraState: " <<  extraState << endl;
    }
    virtual ~ConcreteFlyweight() {};
};


// 非共享Flyweight的具体子类
class UnsharedConcreteFlyweight : public Flyweight
{
public:
    UnsharedConcreteFlyweight(string intraState) : Flyweight(intraState) {};
public:
    virtual void Operate(const string& extraState)
    {
        cout << "UnsharedConcrete flyweight extraState: " << extraState << endl; // only extra state
    }
    virtual ~UnsharedConcreteFlyweight() {};
};
```

3. 定义`Flyweight`的工厂类，对于共享和非共享分别提供一个获取对象实例的接口：
```
// flyweight工厂类，若该对象已存在，直接返回该对象，否则新建一个对象，存入容器中，再返回
class FlyweightFactory
{
    //保存内部状态的flyweight对象容器
private:
    vector<Flyweight*> _vecFlyweight;
public:
    FlyweightFactory() {};
    // 获取可共享的flyweight，从共享pool中获取
    Flyweight* getConcreteFlyweight(const string& key)
    {
        vector<Flyweight*>::iterator it = _vecFlyweight.begin();
        for (; it != _vecFlyweight.end(); ++it)
        {
            if ((*it)->getIntraState() == key) //根据内部状态索引,若存在，直接返回该对象
            {
                return *it; 
            }
        }

        Flyweight* newFlyweight = new ConcreteFlyweight(key);
        _vecFlyweight.push_back(newFlyweight);
        return newFlyweight;           //若不存在，则创建之并存入flyweight容器，返回该对象
    }

    int getConcreteFlyweightCount(void)
    {
        return _vecFlyweight.size();
    }

    // 获取不可共享的flyweight，直接创建并返回
    Flyweight* getUnsharedConcreteFlyweight(const string& key)
    {
        return new UnsharedConcreteFlyweight(key);
    }
};
```

4. 测试享元模式：
```
void FlyweightAbstractTest()
{
    // factory
    FlyweightFactory *factory = new FlyweightFactory();

    //shared flyweight
    Flyweight *concreteFlyweight = factory->getConcreteFlyweight("shared intra state");
    Flyweight *concreteFlyweight2 = factory->getConcreteFlyweight("shared intra state"); // the same, return obj directly                                                                                        // extra state
    const string extraState1 = "extra1";
    const string extraState2 = "extra2";
    concreteFlyweight->Operate(extraState1);
    concreteFlyweight2->Operate(extraState2);
    cout << "flyweight container size :" << factory->getConcreteFlyweightCount() << endl;

    //unshared flyweight
    const string extraState3 = "extra3";
    Flyweight *unsharedConcreteFlyweight = factory->getUnsharedConcreteFlyweight("no shared intra state");
    unsharedConcreteFlyweight->Operate(extraState3);
}
```

运行结果：

    concrete flyweight intraState: shared intra state
    concrete flyweight extraState: extra1
    concrete flyweight intraState: shared intra state
    concrete flyweight extraState: extra2
    flyweight container size :1
    UnsharedConcrete flyweight extraState: extra3

### 享元模式的分类

标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式。

#### 单纯享元模式
在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。模式图如：
![simple_flyweight](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FSimple_Flyweight.PNG)

#### 复合享元模式
将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。模式图如：
![composite_flyweight](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FComposite_Flyweight.PNG)

### 使用场景
- 一个系统有大量相同或者相似的对象，造成内存的大量耗费
-  对象的大部分状态都可以外部化，可以将这些外部状态传入对象中
-  在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式
-  如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象

>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象
>在一个系统中，通常只有唯一一个享元工厂，因此可以使用单例模式进行享元工厂类的设计
>享元模式可以结合组合模式形成复合享元模式，统一对多个享元对象设置外部状态

### 优缺点
- 优点
    + 可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能
    +  享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享
    + 如果能发现这些实例数据除了几个参数外基本都是相同的，使用享元模式就可以大幅度地减少对象的数量
- 缺点
    + 为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长

## 享元模式具体实例
---

### 围棋程序
**使用享元模式简单的实现前言说描述的围棋棋子**

#### 代码实现
1. 首先分别定义棋子的外部属性(Position)和内部属性(Color):
```
// 棋子位置 (extra state)
class Position 
{
private:
    int x;
    int y;
public:
    Position(int a, int b): x(a), y(b) {};
    virtual ~Position() {};
    int getX(void)
    {
        return x;
    }
    int getY(void)
    {
        return y;
    }

//棋子的颜色(intra state) Key
typedef enum tag_Color
{
    BLACK,
    WHITE
}COLOR;
```

2. 定义抽象棋子类,包含内部属性(Color),和操作`DrawPiece(Position &pos)`,传入外部状态对象引用:
```
// 抽象棋子类(Abstract Flyweight)
class Piece
{
protected:
    COLOR    m_Color;  // intra state
public:
    Piece(COLOR color): m_Color(color) {}; // only color 
    virtual ~Piece() {};
public:
    virtual COLOR GetColor()  // intra state
    {
        return m_Color;
    }
    virtual void DrawPiece(Position &pos) = 0; // operate(extra state)
};
```

3. 分别定义具体的黑棋子和白棋子类，分别实现其操作：
```
// 具体黑棋子类(Concrete Flyweight)
class BlackPiece : public Piece
{
public:
    BlackPiece() : Piece(BLACK) {};
    virtual ~BlackPiece() {};
public:
    void DrawPiece(Position &pos)
    {
        cout << "Draw A Black Piece, Position is:" << "X:" << pos.getX() << " Y:" << pos.getY() << endl;
    }
};

// 具体白棋子类(Concrete Flyweight)
class WhitePiece : public Piece
{
public:
    WhitePiece() : Piece(WHITE) {};
    virtual ~WhitePiece() {};
public:
    void DrawPiece(Position &pos)
    {
        cout << "Draw A White Piece, Position is:" << "X:" << pos.getX() << " Y:" << pos.getY() << endl;
    }
};

```

4. 定义棋子工厂类，来提供黑和白棋子
```
// 棋子工厂类，提供生产白色、黑色棋子 (Flyweight Factory)
class PieceFactory
{
private:
    // 棋子容器（享元池）
    vector<Piece*> m_vecPiece;
public:
    PieceFactory() {};
    virtual ~PieceFactory()
    {
        for (vector<Piece*>::iterator it = m_vecPiece.begin();
             it != m_vecPiece.end();
             ++it)
        {
            if (NULL != (*it))
            {
                delete *it;
                *it = NULL;
            }
        }
    }
private:
    Piece* CreateAndAddPiece(COLOR color)
    {
        Piece *pRes;

        if (WHITE ==  color)
        {
            pRes = new WhitePiece();
        }
        else if (BLACK == color)
        {
            pRes = new BlackPiece();
        }
        m_vecPiece.push_back(pRes);

        return pRes;
    }
public:
    Piece* GetPiece(COLOR color)
    {
         // 若不为空，则判断vector容器里面是否有给定颜色的Piece
        for (vector<Piece*>::iterator it = m_vecPiece.begin(); 
             it != m_vecPiece.end();
             ++it)
        {
            if (color == (*it)->GetColor()) // 找到了给定颜色的Piece
            {
                return (*it);
            }
        }
        
        //  若未空，则new一个Piece， 并添加Piece
        return CreateAndAddPiece(color);
    }
};
```

5. 测试棋子享元模式：
```
void FlyweightPieceTest()
{
    PieceFactory *pPF = new PieceFactory();

    // Player 1 get a white piece from the pieces bowl
    Piece       *pWP_1 = pPF->GetPiece(WHITE);
    pWP_1->DrawPiece(Position(1,10)); // new a white piece, set pos = 1,10

    // Player 2 get a black piece from the pieces bowl
    Piece       *pBP_1 = pPF->GetPiece(BLACK); // new a black piece , set pos = 1,20
    pBP_1->DrawPiece(Position(1,20)); 

    // Player 1 get a white piece from the pieces bowl
    Piece       *pWP_2 = pPF->GetPiece(WHITE); // get the existing white piece, but set pos = 2,10
    pWP_2->DrawPiece(Position(2,10));

    // Player 2 get a black piece from the pieces bowl
    Piece       *pBP_2 = pPF->GetPiece(BLACK); // get the existing a black piece , but set pos = 2,20
    pBP_2->DrawPiece(Position(2,20));

    if (NULL != pPF)
    {
        delete pPF; pPF = NULL;
    }
```

6. 运行结果：

    Draw A White Piece, Position is:X:1 Y:10
    Draw A Black Piece, Position is:X:1 Y:20
    Draw A White Piece, Position is:X:2 Y:10
    Draw A Black Piece, Position is:X:2 Y:20


