---
title: 享元模式(结构型)
date: 
categories: Design Pattern
tags:
- C++
- Design Pattern
- Structural Pattern
---

## 前言
---
最近的Google AlphaGo大战李世石的围棋人机大战很火，虽然人类最终败北，但是正如Google执行董事施密特所说，不管输赢，都是人类的巨大的胜利。感兴趣的如果想要设计围棋软件程序，你会发现在围棋中，存在着大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大，为了解决这个问题，可以考虑使用对象共享复用模式---享元模式来设计该围棋软件的棋子对象
<!--more-->

## 享元模式
---
享元模式,该模式通过共享技术实现相同或相似对象的重用。如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用较多的内存空间，那么我们如何去避免系统中出现大量相同或相似的对象，享元模式正为解决这一类问题而诞生。**在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例**。在享元模式中，存储这些共享实例对象的地方称为**享元池**。我们可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，需要时再从享元池取出

>享元模式以共享的方式支持大量细粒度对象的重用，享元对象使用的关键是区分对象内部状态和外部状态
> 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享
> 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部
>区分了内部状态和外部状态，我们可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份

### 意图
运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。

>由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式

### 参与者
- Flyweight
描述一个接口，通过这个接口flyweight可以接受并作用于外部状态

- ConcreteFlyweight
实现Flyweight接口，并为内部状态(如果有的话)增加存储空间
ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的，即必须独立于ConcreteFlyweight对象的场景

- UnsharedConcreteFlyweight
并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享
在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点

- FlyweightFactory
创建并管理flyweight对象
确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个(如果不存在的话)

- Client
维持一个对flyweight的引用
计算或存储一个或多个Flyweight的外部状态

>flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于`ConcreteFlyweight`
对象之中；而外部对象则由client对象存储或计算。当用户调用`Flyweight`对象的操作时，将该状态传递给它
>用户不应直接对`ConcreteFlyweight`类进行实例化，而只能从`FlyweightFactory`对象得到
`ConcreteFlyweight`对象，这可以保证对它们适当地进行共享

### 模式结构
![flyweight_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FFacade_Abstract.PNG)

### 代码实现
1. 首先定义两个子系统类,及操作接口：
```
class SubsystemA
{
public:
    void operateA(void)
    {
        cout << "Subsytem A operate" << endl;
    }
};

class SubsystemB
{
public:
    void operateB(void)
    {
        cout << "Subsytem B operate" << endl;
    }
};

```

2. 再定义Facade类，该类封装了子系统的内部的操作：
```
//外观类
class Facade
{
public:
    void facadeOperate(void)
    {
        SubsystemA sa;
        SubsystemB sb;
        sa.operateA();
        sb.operateB();
    }
};
```

3. 测试外观模式：
```
void FacadeTest()
{
    Facade facade;
    facade.facadeOperate();
}
```

运行结果：

    Subsytem A operate
    Subsytem B operate

### 对外观模式的改进

在标准的外观模式结构图中，如果要修改与外观类交互的子系统类，必须修改外观类或客户端代码，违背了开闭原则，可以通过引入“抽象外观”来对系统进行改进，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象,如：
```
// 抽象外观类
class Facade 
{
    virtual void totalOperate(void) = 0;    
}
// 具体外观类
class ConcreteFacadeA : Facade 
{
    virtual void totalOperate(void)
    {
        SubSystemA subSystemA;
        SubSystemB subSystemB;
        ...    

        subSystemA.op();
        subSystemB.op();
        ...
    }
}
// 具体外观类
class ConcreteFacadeNewA : Facade 
{
    virtual void totalOperate(void)
    {
        SubSysteNewA subSystemNewA;
        SubSystemB subSystemB;
        ...    
           
        subSystemNewA.op();
        subSystemB.op();
        ...
    }

}

//客户端
Facade *facade = new ConcreteFacadeA();
facade->totalOperate();

Facade *facadenew = new ConcreteFacadeNewA();
facadenew->totalOperate();

```

### 使用场景
- 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式
- 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性
- 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度

>通常来讲，仅需要一个Facade对象，因此Facade对象通常属于Singleton模式

### 优缺点
- 优点
    + 它对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目，并使得子系统使用起来更加方便
    + 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的
    + 外观模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要
- 缺点
    + 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性

## 外观模式具体实例
---

### 编译过程
**实现前言说描述的编译外观模型**

#### 代码实现
1. 各个子系统类:
```
class Scanner
{
public:
    void Scan()
    {
        cout << "I am Scan SubSystem" << endl;
    }
};

class Parser
{
public:
    void Parse()
    {
        cout << "I am Parser SubSystem" << endl;
    }
};

class GenMidCode
{
public:
    void GenCode()
    {
        cout << "I am Generate Middle Code SubSytem" << endl;
    }
};

class GenMachineCode
{
public:
    void GenCode()
    {
        cout << "I am Generate Machine Code SubSystem" << endl;
    }
};
```

2. 高层接口,CompileFacade类:
```
// 高层接口
class CompileFacade
{
public:
    void Compile()
    {
        Scanner scanner;
        Parser  pareser;
        GenMidCode genmidcode;
        GenMachineCode genmachinecode;

        scanner.Scan();
        pareser.Parse();
        genmidcode.GenCode();
        genmachinecode.GenCode();
    }
};
```

5. 测试Compile Facade模式：
```
void CompileFacadeTest()
{
    CompileFacade compilefacade;
    compilefacade.Compile();
}
```

5. 运行结果：

    I am Scan SubSystem
    I am Parser SubSystem
    I am Generate Middle Code SubSytem
    I am Generate Machine Code SubSystem


