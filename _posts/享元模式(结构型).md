---
title: 享元模式(结构型)
date: 
categories: Design Pattern
tags:
- C++
- Design Pattern
- Structural Pattern
---

## 前言
---
最近的Google AlphaGo大战李世石的围棋人机大战很火，虽然人类最终败北，但是正如Google执行董事施密特所说，不管输赢，都是人类的巨大的胜利。感兴趣的如果想要设计围棋软件程序，你会发现在围棋中，存在着大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大，为了解决这个问题，可以考虑使用对象共享复用模式---享元模式来设计该围棋软件的棋子对象
<!--more-->

## 享元模式
---
享元模式,该模式通过共享技术实现相同或相似对象的重用。如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用较多的内存空间，那么我们如何去避免系统中出现大量相同或相似的对象，享元模式正为解决这一类问题而诞生。**在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例**。在享元模式中，存储这些共享实例对象的地方称为**享元池**。我们可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，需要时再从享元池取出

>享元模式以共享的方式支持大量细粒度对象的重用，享元对象使用的关键是区分对象内部状态和外部状态
> 内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享
> 外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部
>区分了内部状态和外部状态，我们可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份

### 意图
运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。

>由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式

### 参与者
- Flyweight
描述一个接口，通过这个接口flyweight可以接受并作用于外部状态

- ConcreteFlyweight
实现Flyweight接口，并为内部状态(如果有的话)增加存储空间
ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的，即必须独立于ConcreteFlyweight对象的场景

- UnsharedConcreteFlyweight
并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享
在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点

- FlyweightFactory
创建并管理flyweight对象
确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个(如果不存在的话)

- Client
维持一个对flyweight的引用
计算或存储一个或多个Flyweight的外部状态

>flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于`ConcreteFlyweight`
对象之中；而外部对象则由client对象存储或计算。当用户调用`Flyweight`对象的操作时，将该状态传递给它
>用户不应直接对`ConcreteFlyweight`类进行实例化，而只能从`FlyweightFactory`对象得到
`ConcreteFlyweight`对象，这可以保证对它们适当地进行共享

### 模式结构
![flyweight_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FFlyweight_Abstract.PNG)

### 代码实现
1. 首先定义抽象的`Flyweight`,并提供`Operate()`接口，接受外部状态：
```
// Flyweight抽象类
class Flyweight
{
private:
    // 内部状态，也可以放在ConcreteFlyweight中
    string _intraState;
protected:
    Flyweight(string intraState) : _intraState(intraState) {};
public:
    //操作外部状态extraState
    virtual void Operate(const string& extraState) = 0;
    virtual ~Flyweight() {};
public:
    // 内部状态回读接口，也可以放在ConcreteFlyweight中
    string getIntraState(void)
    {
        return _intraState;
    }
};
```

2. 再分别定义`Flyweight`类的两个子类，共享的`ConcreteFlyweight`类和非共享的 `UnsharedConcreteFlyweight`类，并分别实现其`Operate()`接口：
```
// 共享Flyweight的具体子类
class ConcreteFlyweight : public Flyweight
{
public:
    ConcreteFlyweight(string intraState) : Flyweight(intraState) {};
public:
    virtual void Operate(const string& extraState)
    {
        cout << "concrete flyweight intraState: " <<  getIntraState() << endl; // intra state & extra state
        cout << "concrete flyweight extraState: " <<  extraState << endl;
    }
    virtual ~ConcreteFlyweight() {};
};


// 非共享Flyweight的具体子类
class UnsharedConcreteFlyweight : public Flyweight
{
public:
    UnsharedConcreteFlyweight(string intraState) : Flyweight(intraState) {};
public:
    virtual void Operate(const string& extraState)
    {
        cout << "UnsharedConcrete flyweight extraState: " << extraState << endl; // only extra state
    }
    virtual ~UnsharedConcreteFlyweight() {};
};
```

3. 定义`Flyweight`的工厂类，对于共享和非共享分别提供一个获取对象实例的接口：
```
// flyweight工厂类，若该对象已存在，直接返回该对象，否则新建一个对象，存入容器中，再返回
class FlyweightFactory
{
    //保存内部状态的flyweight对象容器
private:
    vector<Flyweight*> _vecFlyweight;
public:
    FlyweightFactory() {};
    // 获取可共享的flyweight，从共享pool中获取
    Flyweight* getConcreteFlyweight(const string& key)
    {
        vector<Flyweight*>::iterator it = _vecFlyweight.begin();
        for (; it != _vecFlyweight.end(); ++it)
        {
            if ((*it)->getIntraState() == key) //根据内部状态索引,若存在，直接返回该对象
            {
                return *it; 
            }
        }

        Flyweight* newFlyweight = new ConcreteFlyweight(key);
        _vecFlyweight.push_back(newFlyweight);
        return newFlyweight;           //若不存在，则创建之并存入flyweight容器，返回该对象
    }

    int getConcreteFlyweightCount(void)
    {
        return _vecFlyweight.size();
    }

    // 获取不可共享的flyweight，直接创建并返回
    Flyweight* getUnsharedConcreteFlyweight(const string& key)
    {
        return new UnsharedConcreteFlyweight(key);
    }
};
```

4. 测试享元模式：
```
void FlyweightAbstractTest()
{
    // factory
    FlyweightFactory *factory = new FlyweightFactory();

    //shared flyweight
    Flyweight *concreteFlyweight = factory->getConcreteFlyweight("shared intra state");
    Flyweight *concreteFlyweight2 = factory->getConcreteFlyweight("shared intra state"); // the same, return obj directly                                                                                        // extra state
    const string extraState1 = "extra1";
    const string extraState2 = "extra2";
    concreteFlyweight->Operate(extraState1);
    concreteFlyweight2->Operate(extraState2);
    cout << "flyweight container size :" << factory->getConcreteFlyweightCount() << endl;

    //unshared flyweight
    const string extraState3 = "extra3";
    Flyweight *unsharedConcreteFlyweight = factory->getUnsharedConcreteFlyweight("no shared intra state");
    unsharedConcreteFlyweight->Operate(extraState3);
}
```

运行结果：

    concrete flyweight intraState: shared intra state
    concrete flyweight extraState: extra1
    concrete flyweight intraState: shared intra state
    concrete flyweight extraState: extra2
    flyweight container size :1
    UnsharedConcrete flyweight extraState: extra3

### 享元模式的分类

标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式。

#### 单纯享元模式
在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。模式图如：
![simple_flyweight]()

#### 复合享元模式
将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。模式图如：
![composite_flyweight]()

### 使用场景
- 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式
- 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性
- 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度

>通常来讲，仅需要一个Facade对象，因此Facade对象通常属于Singleton模式

### 优缺点
- 优点
    + 它对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目，并使得子系统使用起来更加方便
    + 它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的
    + 外观模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要
- 缺点
    + 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性

## 外观模式具体实例
---

### 编译过程
**实现前言说描述的编译外观模型**

#### 代码实现
1. 各个子系统类:
```
class Scanner
{
public:
    void Scan()
    {
        cout << "I am Scan SubSystem" << endl;
    }
};

class Parser
{
public:
    void Parse()
    {
        cout << "I am Parser SubSystem" << endl;
    }
};

class GenMidCode
{
public:
    void GenCode()
    {
        cout << "I am Generate Middle Code SubSytem" << endl;
    }
};

class GenMachineCode
{
public:
    void GenCode()
    {
        cout << "I am Generate Machine Code SubSystem" << endl;
    }
};
```

2. 高层接口,CompileFacade类:
```
// 高层接口
class CompileFacade
{
public:
    void Compile()
    {
        Scanner scanner;
        Parser  pareser;
        GenMidCode genmidcode;
        GenMachineCode genmachinecode;

        scanner.Scan();
        pareser.Parse();
        genmidcode.GenCode();
        genmachinecode.GenCode();
    }
};
```

5. 测试Compile Facade模式：
```
void CompileFacadeTest()
{
    CompileFacade compilefacade;
    compilefacade.Compile();
}
```

5. 运行结果：

    I am Scan SubSystem
    I am Parser SubSystem
    I am Generate Middle Code SubSytem
    I am Generate Machine Code SubSystem


