---
title: 命令模式(行为型)
date: 
categories: Design Pattern
tags:
- C++
- Design Pattern
- Behavior Pattern
---

## 前言
---
一般的文档编辑器都会提供一个主菜单(Menu),主菜单中包含一些菜单项(MenuItem),每个菜单项包含很多的命令操作，包括打开命令，创建命令，编辑命令等等，要设计这样的文档编辑系统，可以考虑使用命令模式。

<!--more-->

## 命令模式
---

### 意图
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作,别名为动作(Action)模式或事务(Transaction)模式

> 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求
> 命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开
> 命令模式是回调机制的一个面向对象替代品，所谓回调函数是指函数现在某处注册，而它将在稍后某个需要的时候被调用

### 参与者
- Command
抽象命令类，在其中执行请求的execute()方法，通过这些方法可以调用请求接收者的相关操作

- ConcreteCommand
具体命令类，抽象命令类的子类,处理用户请求,实现抽象命令类的方法
一般持有接收者对象的引用。它对应具体的接收者对象,将接收者对象的动作绑定其中,在实现execute()方法时，将调用接收者对象的相关操作(Action)

- Invoker
调用者即请求发送者，持有抽象命令对象的引用.它通过命令对象来执行请求。
一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系
在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作

- Receiver
接收者，接收者执行与请求相关的操作，它具体实现对请求的业务处理

### 模式结构
![command_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FReponse_Abstract.PNG)

### 代码实现
1.首先定义抽象的`Handler`,并提供`HandlerRequest()`接口：
```
// Abstract Handler
class Handler
{
protected: // protected,子类继承能访问和使用
    Handler *m_pHandler; // 请求的下个抽象处理者
    int     m_nState; // 请求的参数
public:
    Handler(Handler *pHandler) : m_pHandler(pHandler) {}; 
    //在构造函数中传入下一个处理者
    //也可以通过提供一个setHandler方法，传入Handler，动态设置传入下一个处理者
public:
    virtual void HandlerRequest(int nState) = 0;
};
```

2.再分别定义`Handler`类的三个具体处理子类，并实现其中的`HandlerRequest()`接口，该接口主要作用是处理该请求或转发请求给下个处理者：
```
#define  NULL_POINTER(ptr) (NULL == ptr)

// Concrete Handler A
class ConcreteHandlerA : public Handler
{
public:
    ConcreteHandlerA(Handler *pHandler) : Handler(pHandler) {};
public:
    virtual void HandlerRequest(int nState)
    {
        if (nState < 10)    // 权限范围内，处理该请求
        {
            cout << "Concrete Handler A Do The Request !!!" << "State: " << nState << endl;
            return;
        }
        // >10 的情况下一个ConcreteHandler处理
        if (NULL_POINTER(m_pHandler))
        {
            cout << "No Handler Do The Request !!!" << "State: " << nState << endl;
            return;
        }
        m_pHandler->HandlerRequest(nState);  // 权限范围外，转发该请求让下一个处理者m_pHandler处理
    }
};

// Concrete Handler B
class ConcreteHandlerB : public Handler
{
public:
    ConcreteHandlerB(Handler *pHandler) : Handler(pHandler) {};
public:
    virtual void HandlerRequest(int nState)
    {
        if (nState < 20)
        {
            cout << "Concrete Handler B Do The Request !!!" << "State: " << nState << endl;
            return;
        }
        // >20 的情况下一个ConcreteHandler处理
        if (NULL_POINTER(m_pHandler))
        {
            cout << "No Handler Do The Request !!!" << "State: " << nState << endl;
            return;
        }
        m_pHandler->HandlerRequest(nState);
    }
};

// Concrete Handler C
class ConcreteHandlerC : public Handler
{
public:
    ConcreteHandlerC(Handler *pHandler) : Handler(pHandler) {};
public:
    virtual void HandlerRequest(int nState)
    {
        if (nState < 30)
        {
            cout << "Concrete Handler C Do The Request !!!" << "State: " << nState << endl;
            return;
        }
        // >30 的情况下一个ConcreteHandler处理
        if (NULL_POINTER(m_pHandler))
        {
            cout << "No Handler Do The Request !!!" << "State: " << nState << endl;
            return;
        }
        m_pHandler->HandlerRequest(nState);
    }
};
```

3.测试责任链模式：
```
#define  SAFE_RELASE_POINTER(ptr) if(!NULL_POINTER(ptr)) {delete ptr; ptr = NULL;}

void ResponseTest_General()
{
    Handler *pCHC = new ConcreteHandlerC(NULL);
    Handler *pCHB = new ConcreteHandlerB(pCHC);
    Handler *pCHA = new ConcreteHandlerA(pCHB); 
    //在构造函数的参数内指明每一个Handler的下一个Handler 

    // 从Concrete Handler A 开始往下处理
    pCHA->HandlerRequest(5);
    pCHA->HandlerRequest(15);
    pCHA->HandlerRequest(25);
    pCHA->HandlerRequest(35);

    SAFE_RELASE_POINTER(pCHA);
    SAFE_RELASE_POINTER(pCHB);
    SAFE_RELASE_POINTER(pCHC);
}
```

4.运行结果：

    Concrete Handler A Do The Request !!!State: 5
    Concrete Handler B Do The Request !!!State: 15
    Concrete Handler C Do The Request !!!State: 25
    No Handler Do The Request !!!State: 35

### 责任链模式的分类

责任链模式根据请求是否能同时被多个处理对象处理或者请求是否能最终不被任何请求者处理，分为以下两类：

#### 纯的责任链模式
- 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况
- 要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况

#### 不纯的职责链模式
- 一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求
- 而且一个请求可以最终不被任何处理者对象所接收

>事件浮升(Event Bubbling)机制：在GUI组件的事件处理机制中,当事件发生在某一个组件时候,先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。
在这种场景中，每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况

### 使用场景
- 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的
- 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
- 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序

### 优缺点
- 优点
    + 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度
    + 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接
    + 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责
- 缺点
    + 如果建链不当，可能会造成循环调用，将导致系统陷入死循环
    + 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理


## 责任链模式具体实例
---

### 请假审批问题
**使用责任链模式简单实现前言所述的请假审批过程**

#### 代码实现
1.定义抽象的`HoliadyHandler`类，并提供`HandleHolidayRequest`接口:
```
// Request Class to represent request content
class HolidayRequest
{
private:
    string _type;
    int    _days;
public:
    HolidayRequest(string type, int days) : _type(type), _days(days) {};
public:
    string getType(void)
    {
        return _type;
    }
    int getDays(void)
    {
        return _days;
    }
};

// Abstract Handler
class HoliadyHandler
{
protected:
    HoliadyHandler *_handler;
public:
    HoliadyHandler() : _handler(NULL) {};
public:
    // 通过set方法来设置下一个处理者，供client调用
    void setHandler(HoliadyHandler *handler) 
    {
        _handler = handler;
    }
public:
    virtual void HandleHolidayRequest(HolidayRequest &request) = 0;
};
```

2.分别定义处理者`HolidayRequest`的子类`SectionChief`和`Minister`及`Director`:
```
// Sectin Chief Handler
class SectionChief : public HoliadyHandler
{
private:
    string _name;
public:
    SectionChief(string name) : _name(name) {};
public:
    void HandleHolidayRequest(HolidayRequest &request)
    {
        if (request.getDays() <= 1)
        {
            cout << "Section chief " << _name << " approve your " << request.getDays() << " days for " << request.getType() << " request !" << endl;
        }
        else
        {
            if (NULL_POINTER(_handler))
            {
                cout << "No holiday handler is assigned !" << endl;
            }
            else
            {
                _handler->HandleHolidayRequest(request);
            }
            
        }
    }
};

// Minister Handler
class Minister : public HoliadyHandler
{
private:
    string _name;
public:
    Minister(string name) : _name(name) {};
public:
    void HandleHolidayRequest(HolidayRequest &request)
    {
        if (request.getDays() <= 3)
        {
            cout << "Minister " << _name << " approve your " << request.getDays() << " days for " << request.getType() << " request !" << endl;
        }
        else
        {
            if (NULL_POINTER(_handler))
            {
                cout << "No holiday handler is assigned !" << endl;
            }
            else
            {
                _handler->HandleHolidayRequest(request);
            }

        }
    }
};

// Director Handler
class Director : public HoliadyHandler
{
private:
    string _name;
public:
    Director(string name) : _name(name) {};
public:
    void HandleHolidayRequest(HolidayRequest &request)
    {
        if (request.getDays() > 3)
        {
            cout << "Director " << _name << " approve your " << request.getDays() << " days for " << request.getType() <<  " request !" << endl;
        }
        else
        {
            if (NULL_POINTER(_handler))
            {
                cout << "No holiday handler is assigned !" << endl;
            }
            else
            {
                _handler->HandleHolidayRequest(request);
            }

        }
    }
};
```

3.测试责任链模式:
```
void ResponseTest_Holiday()
{
    // 请求处理者
    HoliadyHandler *pD = new Director("john");
    HoliadyHandler *pM = new Minister("bob");
    HoliadyHandler *pS = new SectionChief("bill");

    //设置责任链
    pS->setHandler(pM);
    pM->setHandler(pD);
    pD->setHandler(NULL);

    // 请求
    HolidayRequest request1("dragon boat festival", 1);
    HolidayRequest request2("mid-autumn festival", 2);
    HolidayRequest request3("spring festival", 3);
    HolidayRequest request4("spring festival", 4);

    //处理请求(第一个处理者是SectionChief,从其开始)
    pS->HandleHolidayRequest(request1);
    pS->HandleHolidayRequest(request2);
    pS->HandleHolidayRequest(request3);
    pS->HandleHolidayRequest(request4);

    SAFE_RELASE_POINTER(pD);
    SAFE_RELASE_POINTER(pM);
    SAFE_RELASE_POINTER(pS);
}
```

4.运行结果:

    Section chief bill approve your 1 days for dragon boat festival request !
    Minister bob approve your 2 days for mid-autumn festival request !
    Minister bob approve your 3 days for spring festival request !
    Director john approve your 4 days for spring festival request !
