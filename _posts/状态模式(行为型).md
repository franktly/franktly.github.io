---
title: 状态模式(行为型)
date: 
categories: Design Pattern
tags:
- Design Pattern
- Behavior Pattern
---

## 前言
---


<!--more-->

## 状态模式
---
在dota即时对战中，不同的时期，战争的行为是不一样的。如在游戏战争前期，主要是辅助英雄包鸡包眼游走gank，后期英雄发育为主，一般不会参与团战，这时候主要以前期辅助英雄为主角；在游戏战争中期，后期英雄发育经过前期的发育，开始与辅助英雄抱团推塔，参加团战，辅助作用慢慢减弱，后期英雄慢慢变强；而在游戏战争的后期，经过前期的发育，中期团战金钱的积累，后期英雄成为了战场的主角，开始带领辅助英雄推高地，占领基地。像这种随着时间的推移，角色对象在不同的状态下具有不同的行为或者状态在某些情况下能够相互转换的行为，可以通过状态模式来解决。

>在状态模式中，我们将对象在每一个状态下的行为和状态转移语句封装在一个个状态类中，通过这些状态类来分散冗长的条件转移语句，让系统具有更好的灵活性和可扩展性

### 意图
允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类，别名是状态对象

>系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理

### 参与者
- Context
环境类，拥有多种状态的对象
维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象

- State
抽象状态类，定义一个接口以封装与环境类Context的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法
抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中

- ConcreteState
具体状态类，抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同


### 模式结构
![state_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FObserver_Abstract.PNG)

### 代码实现
1.首先定义抽象主题目标类`Subject`,并声明`Notify()`接口和增删观察者对象的接口：
```
// Abstract Subject
class Subject
{
public:
    virtual void Attach(Observer *pObserver) = 0;
    virtual void Detach(Observer *pObserver) = 0;
    virtual void Notify() = 0;         // 变化通知接口
    virtual void SetState(int state) = 0;
    virtual int GetState() = 0;
};
```

2.再定义具体的主题目标类`ConcreteSubject`,并实现`Notify()`及增删观察者接口：
```
// ConcreteSubject
class ConcreteSubject : public Subject
{
private:
    list<Observer*> m_listObserver; // 观察者集合
    int m_State;          // 主题目标状态
public:
    ConcreteSubject(): m_State(0){};
public:
    virtual void Attach(Observer *pObserver)
    {
        m_listObserver.push_back(pObserver);
    }
    virtual void Detach(Observer *pObserver)
    {
        m_listObserver.remove(pObserver);
    }
    virtual void Notify()
    {
        for (list<Observer*>::iterator it = m_listObserver.begin();
             it != m_listObserver.end();
             ++it)
        {
            (*it)->Update(); // 调用各个观察者的update方法
        }
    }
    virtual void SetState(int state)
    {
        m_State = state;
    }
    virtual int GetState()
    {
        return m_State;
    }
};
```

3.再定义抽象的观察者类`Observer`,并声明更新接口`Update()`：
```
// Abstract Observer
class Observer
{
public:
    virtual void Update() = 0;
    virtual void ShowState() = 0;
};
```

4.然后定义具体的观察者类`ConcreteObserver`，并实现接口`Update()`:
```
// ConcreteObserver
class ConcreteObserver : public Observer
{
private: 
    Subject *m_pSubject;  // 具体的观察者维护一个具体的主题目标对象引用
    int m_State; // 观察者状态
public:
    ConcreteObserver(Subject *pSubject): m_pSubject(pSubject),m_State(0) {};//  具体的Observer关联的Subject，调用该Subject的方法Update（）
public:
    virtual void Update()
    {
        m_State = m_pSubject->GetState();  //使主题目标对象状态与观察者状态一致
    }
    virtual void ShowState()
    {
        cout << "Concrete Observer State: " << m_State << endl;;
    }
};
```

5.测试观察者模式：
```
void ObserverTest_General()
{
    Subject *pCS = new ConcreteSubject();

    Observer *pCO1 = new ConcreteObserver(pCS);
    Observer *pCO2 = new ConcreteObserver(pCS);

    pCS->Attach(pCO1);
    pCS->Attach(pCO2); // 添加观察者对象到主题目标集合中

    pCS->SetState(100);
    pCS->Notify(); // 通知各个观察者更新状态

    pCO1->ShowState();  // 100
    pCO2->ShowState();  // 100

    pCS->Detach(pCO2);

    pCS->SetState(200);
    pCS->Notify();

    pCO1->ShowState();  // 200
    pCO2->ShowState();  // 100

    SAFE_RELASE_POINTER(pCS);
    SAFE_RELASE_POINTER(pCO1);
    SAFE_RELASE_POINTER(pCO2);
}
```

5.运行结果：

    Concrete Observer State: 100
    Concrete Observer State: 100
    Concrete Observer State: 200
    Concrete Observer State: 100


### 使用场景
- 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使他们可以独立的改变和复用
- 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁

### 优缺点
- 优点
    + 可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色
    + 观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次
    + 支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度
    + 满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码
- 缺点
    + 果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃
    + 没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化

>MVC架构中也应用了观察者模式，MVC是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容

## 观察者模式具体实例
---

### 博客订阅通知问题
**使用观察者模式简单实现前言所述的博客订阅通知功能**

**代码实现**
1.定义抽象的目标主题类`Blog`:
```
// Abstract Blog
class Blog
{
public:
    virtual void AttachBlogObserver(BlogObserver *pBlogObserver) = 0;
    virtual void DetachBlogObserver(BlogObserver *pBlogObserver) = 0;
    virtual void Notify()                                        = 0; //  通知
    virtual string GetName()                                     = 0;
    virtual void PublishMsg(string msg)                          = 0;
    virtual string GetMsg()                                      = 0;
};
```

2.定义具体的目标主题类`CsdnBlog`,并实现通知接口:
```
// Concrete Blog: Csdn Blog
class CsdnBlog : public Blog
{
private:
    list<BlogObserver*> m_listBlogObserver;
    string m_BlogName;
    string m_msg;
public:
    CsdnBlog(string name): m_BlogName(name), m_msg("") {};
public:
    string GetName()
    {
        return m_BlogName;
    }
public:
    virtual void AttachBlogObserver(BlogObserver *pBlogObserver)
    {
        m_listBlogObserver.push_back(pBlogObserver);
        cout << "[Blog Observer]" << pBlogObserver->GetName() << " Attached To " << "[Blog]" << m_BlogName << endl;
    }
    virtual void DetachBlogObserver(BlogObserver *pBlogObserver)
    {
        m_listBlogObserver.remove(pBlogObserver);
        cout << "[Blog Observer]" << pBlogObserver->GetName() << " Detached From " << "[Blog]" << m_BlogName << endl;
    }
    virtual void Notify()
    {
        for (list<BlogObserver*>::iterator it  = m_listBlogObserver.begin();
             it != m_listBlogObserver.end();
             ++it)
        {
            (*it)->Update(this); // Update本Blog对象的Message到所有订阅该Blog对象的Observer
        }
    }
    virtual void PublishMsg(string msg)
    {
        cout << m_BlogName <<  " Send Message: " << msg << endl;
        m_msg = msg;
    }
    virtual string GetMsg()
    {
        return m_msg;
    }
};
```

3.定义抽象的观察者类`BlogObserver`,声明`Update()`接口:
```
class BlogObserver
{
public:
    virtual void Update(Blog *pBlog)     = 0;  // Update指定Blog对象的Message
    virtual string GetName()             = 0;
    virtual void ShowMsg()               = 0;
};
```

4.定义具体的观察者类`ConcreteBlogObserver`，实现`Update()`接口：
```
// Concrete Blog Observer
class ConcreteBlogObserver : public BlogObserver
{
private:
    map<Blog*, string> m_mapBlog_Msg;  // 保存订阅的Blog及对应的消息
    string m_BlogObserverName;
public:
    ConcreteBlogObserver(string name): m_BlogObserverName(name) {};
public:
    string GetName()
    {
        return m_BlogObserverName;
    }
public:
    virtual void Update(Blog *pBlog)  // 传入某个主题对象的指针
    {
        cout << "[Blog Observer]" << m_BlogObserverName << " Update Message: " << pBlog->GetMsg() << " From [Blog]" << pBlog->GetName() << endl;

        map<Blog*, string>::iterator it = m_mapBlog_Msg.begin();
        for (;it != m_mapBlog_Msg.end();++it)
        {
            if (((*it).first)->GetName() == pBlog->GetName())
            {
                (*it).second = pBlog->GetMsg(); // 找到了直接替换跟新Msg
                return;
            }    
        }
        // 未找到，则插入到map
        if (it == m_mapBlog_Msg.end())
        {
            m_mapBlog_Msg.insert(make_pair(pBlog, pBlog->GetMsg()));
            cout << "[Blog Observer]" << m_BlogObserverName << " Add a New " << "[Blog]" << pBlog->GetName() << endl;
        }   
    }

    virtual void ShowMsg()
    {
        cout << "\nShow All Blog Message:" << endl;
        for (map<Blog*,string>::iterator it = m_mapBlog_Msg.begin();
             it != m_mapBlog_Msg.end();
             ++it)       // 显示所有list中的Message
        {
            cout << "[Blog Observer]" << m_BlogObserverName << " Message: " << (*it).second << " From [Blog]" << ((*it).first)->GetName() << "\n" << endl;
        }   
        cout << "\n" << endl;
    }
};
```

4.测试观察者模式:
```
void ObserverTest_Blog()
{
    Blog *pCsdn_Tly = new CsdnBlog("Tly_Bloger");
    Blog *pCsdn_Frank = new CsdnBlog("Frank Bloger");

    BlogObserver *pBgOb_A = new ConcreteBlogObserver("A");
    BlogObserver *pBgOb_B = new ConcreteBlogObserver("B");
    BlogObserver *pBgOb_C = new ConcreteBlogObserver("C");

    pCsdn_Tly->AttachBlogObserver(pBgOb_A);
    pCsdn_Tly->AttachBlogObserver(pBgOb_B);
    pCsdn_Tly->AttachBlogObserver(pBgOb_C);

    // 第一个Blog：Tly Blog发布并通知跟新消息到A，B，C Observer
    pCsdn_Tly->PublishMsg("I am Tly");
    pCsdn_Tly->Notify();
    
    // 依次显示A,B,C Observer订阅的所有Blog（此时均只有Tly)的信息
    pBgOb_A->ShowMsg();
    pBgOb_B->ShowMsg();
    pBgOb_C->ShowMsg();

    pCsdn_Frank->AttachBlogObserver(pBgOb_A);
    pCsdn_Frank->AttachBlogObserver(pBgOb_B);

    // 另外一个Blog：Frank Blog发布并通知跟新消息到A，B Observer
    pCsdn_Frank->PublishMsg("I am Frank");
    pCsdn_Frank->Notify();
    
    // 依次显示A,B,C Observer订阅的所有Blog（此时有A,B有Tly、Frank,C只有Tly)的信息
    pBgOb_A->ShowMsg();
    pBgOb_B->ShowMsg();
    pBgOb_C->ShowMsg();

    // A 取消订阅了Tly, Tly 重新发布消息到B,C Observer
    pCsdn_Tly->DetachBlogObserver(pBgOb_A);
    pCsdn_Tly->PublishMsg("I am Tly Two");
    pCsdn_Tly->Notify();

    // 依次显示A,B,C Observer订阅的所有Blog的信息
    pBgOb_A->ShowMsg();
    pBgOb_B->ShowMsg();
    pBgOb_C->ShowMsg();

    // A 取消订阅了Frank，Frank 重新发布消息到B Observer
    pCsdn_Frank->DetachBlogObserver(pBgOb_A);
    pCsdn_Frank->PublishMsg("I am Frank Two");
    pCsdn_Frank->Notify();

    // 依次显示A,B,C Observer订阅的所有Blog的信息
    pBgOb_A->ShowMsg();
    pBgOb_B->ShowMsg();
    pBgOb_C->ShowMsg();

    SAFE_RELASE_POINTER(pBgOb_A);
    SAFE_RELASE_POINTER(pBgOb_B);
    SAFE_RELASE_POINTER(pBgOb_C);
    SAFE_RELASE_POINTER(pCsdn_Tly);
    SAFE_RELASE_POINTER(pCsdn_Frank);
}
```

5.运行结果:

    [Blog Observer]A Attached To [Blog]Tly_Bloger
    [Blog Observer]B Attached To [Blog]Tly_Bloger
    [Blog Observer]C Attached To [Blog]Tly_Bloger
    Tly_Bloger Send Message: I am Tly
    [Blog Observer]A Update Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]A Add a New [Blog]Tly_Bloger
    [Blog Observer]B Update Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]B Add a New [Blog]Tly_Bloger
    [Blog Observer]C Update Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]C Add a New [Blog]Tly_Bloger
    Show All Blog Message:
    [Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
    Show All Blog Message:
    [Blog Observer]B Message: I am Tly From [Blog]Tly_Bloger
    Show All Blog Message:
    [Blog Observer]C Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]A Attached To [Blog]Frank Bloger
    [Blog Observer]B Attached To [Blog]Frank Bloger
    Frank Bloger Send Message: I am Frank
    [Blog Observer]A Update Message: I am Frank From [Blog]Frank Bloger
    [Blog Observer]A Add a New [Blog]Frank Bloger
    [Blog Observer]B Update Message: I am Frank From [Blog]Frank Bloger
    [Blog Observer]B Add a New [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]A Message: I am Frank From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]B Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]B Message: I am Frank From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]C Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]A Detached From [Blog]Tly_Bloger
    Tly_Bloger Send Message: I am Tly Two
    [Blog Observer]B Update Message: I am Tly Two From [Blog]Tly_Bloger
    [Blog Observer]C Update Message: I am Tly Two From [Blog]Tly_Bloger
    Show All Blog Message:
    [Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]A Message: I am Frank From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]B Message: I am Tly Two From [Blog]Tly_Bloger
    [Blog Observer]B Message: I am Frank From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]C Message: I am Tly Two From [Blog]Tly_Bloger
    [Blog Observer]A Detached From [Blog]Frank Bloger
    Frank Bloger Send Message: I am Frank Two
    [Blog Observer]B Update Message: I am Frank Two From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
    [Blog Observer]A Message: I am Frank From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]B Message: I am Tly Two From [Blog]Tly_Bloger
    [Blog Observer]B Message: I am Frank Two From [Blog]Frank Bloger
    Show All Blog Message:
    [Blog Observer]C Message: I am Tly Two From [Blog]Tly_Bloger

