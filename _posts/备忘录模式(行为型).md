---
title: 备忘录模式(行为型)
date: 
categories: Design Pattern
tags:
- C++
- Design Pattern
- Behavior Pattern
---

## 前言
---
在玩RPG之类游戏的时候，每次通过一次游戏关卡的时候，一般我们都会把游戏的角色状态保存一下，继续通下一关，如果下一关难度比较大很难通过失败后，又懒得从第一关开始重新。幸亏有关卡的保存功能，我们可以直接从上次保存的关卡中重新开始即可，提高了通关的效率。这里的游戏角色的保存和恢复功能就是本文将要介绍的备忘录模式

<!--more-->

## 备忘录模式
---
备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件用到的撤销功能就是基于此模式的

>一个备忘录是一个对象，它存储另一个对象在某个瞬间的内部状态，而后者称为备忘录的原发器(Originator)。当需要设置原发器的检查点时, 取消操作机制会向原发器请求一个备忘录。原发器用描述当前状态的信息初始化该备忘录。只有原发器可以向备忘录中存取信息，备忘录对其他的对象“不可见”

### 意图
在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态

### 参与者
- Memento
备忘录，存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态
防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口:
1.管理者(Caretaker)只能看到备忘录的窄接口—它只能将备忘录传递给其他对象;
2.相反,原发器能够看到一个宽接口,允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态

- Originator
原发器，创建一个备忘录,用以记录当前时刻它的内部状态
使用备忘录恢复内部状态

- Caretaker
负责人，负责保存好备忘录
不能对备忘录的内容进行操作或检查

>管理器向原发器请求一个备忘录, 保留一段时间后,将其送回给原发器
>备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索

### 模式结构
![mediator_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FMediator_Abstract.jpg)

### 代码实现
1.首先定义抽象的中介这类`Mediator`,并提供`Notify()`接口用于各个同事之间进行通信：
```
// Abstract Mediator 
class Colleague;
class Mediator
{
protected:
    list<Colleague*> m_listColleague;
public:
    virtual void AttachColleague(Colleague* pColleague)     = 0; 
    virtual void Notify(Colleague *pColleague, string msg)  = 0;
};
```

2.再定义具体中介者类`ConcreteMediator`，并实现相应的接口:
```
// Concrete Mediator
class ConcreteMediator : public Mediator
{
public:
    virtual void AttachColleague(Colleague* pColleague)
    {
        m_listColleague.push_back(pColleague);  // 加入需要通信的同事对象
    }
// 指定的Colleague pColleague发送消息（通过Mediator），其他的Colleague接受消息
    virtual void Notify(Colleague *pColleague, string msg) 
    {
        for (list<Colleague*>::iterator it = m_listColleague.begin();
            it != m_listColleague.end();
            ++it)
        {
            if ((*it) != pColleague)
            {
                (*it)->RecvMsg(msg); // 调用其他同事类的RecvMsg方法
            }
        }
    }
};
```

3.再定义抽象的同事类`Colleague`，该同事类具有抽象中介者对象的引用，并声明了各个同事子类需要实现的方法：
```
// Abstract Colleague
class Colleague
{
protected:
    Mediator* m_pMediator;
    string m_Name;
public:
    Colleague(Mediator* pMediator, string name): m_pMediator(pMediator),m_Name(name) {};
public:
    virtual void SendMsg(string msg) = 0;
    virtual void RecvMsg(string msg) = 0;
    virtual string GetName()         = 0;
};
```

4.定义两个具体的同事类`ConcreteColleagueA`及`ConcreteColleagueB`,实现抽象同事类的相应接口:
```
// Concrete Colleague A
class ConcreteColleagueA : public Colleague
{
public:
    ConcreteColleagueA(Mediator* pMediator, string name): Colleague(pMediator, name) {};
public:
    virtual void SendMsg(string msg)
    {
        cout << m_Name << "[CCA] Send Msg: "<< msg << endl;
        m_pMediator->Notify(this, msg);
        //(依赖方法)调用中介者的方法，与其他具体同事通信
    }
    virtual void RecvMsg(string msg)
    {
        cout << m_Name << "[CCA] Recv Msg: "<< msg << endl;
         //(自身方法) 处理自己的行为
    }
public:
    virtual string GetName()
    {
        return m_Name;
    }
};

// Concrete Colleague B
class ConcreteColleagueB : public Colleague
{
public:
    ConcreteColleagueB(Mediator* pMediator, string name): Colleague(pMediator, name) {};
public:
    virtual void SendMsg(string msg)
    {
        cout << m_Name << "[CCB] Send Msg: "<< msg << endl;
        m_pMediator->Notify(this, msg); 
        //(依赖方法)调用中介者的方法，与其他具体同事通信
    }
    virtual void RecvMsg(string msg)
    {
        cout << m_Name << "[CCB] Recv Msg: "<< msg << endl;
        //(自身方法) 处理自己的行为
    }
public:
    virtual string GetName()
    {
        return m_Name;
    }
};
```

5.测试中介者模式：
```
void MediatorTest_General()
{
    Mediator *pM = new ConcreteMediator();

    Colleague *pCA  = new ConcreteColleagueA(pM, "Monitor1");
    Colleague *pCA2 = new ConcreteColleagueA(pM, "Monitor2");
    Colleague *pCB  = new ConcreteColleagueB(pM, "Student1");
    Colleague *pCB2 = new ConcreteColleagueB(pM, "Student2");

    pM->AttachColleague(pCA);
    pM->AttachColleague(pCA2);
    pM->AttachColleague(pCB);
    pM->AttachColleague(pCB2);

    // Monitor 1 Send Msg
    pCA->SendMsg("Hello Everyone I am Monitor 1 ");

    // Monitor 2 Send Msg
    pCA2->SendMsg("Hello Everyone I am Monitor 2 ");

    // Student 2 Send Msg
    pCB->SendMsg("Hello Everyone I am Student 1");

    SAFE_RELASE_POINTER(pM);
    SAFE_RELASE_POINTER(pCA);
    SAFE_RELASE_POINTER(pCA2);
    SAFE_RELASE_POINTER(pCB);
    SAFE_RELASE_POINTER(pCB2);
};
```

6.运行结果：

    Monitor1[CCA] Send Msg: Hello Everyone I am Monitor 1
    Monitor2[CCA] Recv Msg: Hello Everyone I am Monitor 1
    Student1[CCB] Recv Msg: Hello Everyone I am Monitor 1
    Student2[CCB] Recv Msg: Hello Everyone I am Monitor 1
    Monitor2[CCA] Send Msg: Hello Everyone I am Monitor 2
    Monitor1[CCA] Recv Msg: Hello Everyone I am Monitor 2
    Student1[CCB] Recv Msg: Hello Everyone I am Monitor 2
    Student2[CCB] Recv Msg: Hello Everyone I am Monitor 2
    Student1[CCB] Send Msg: Hello Everyone I am Student 1
    Monitor1[CCA] Recv Msg: Hello Everyone I am Student 1
    Monitor2[CCA] Recv Msg: Hello Everyone I am Student 1
    Student2[CCB] Recv Msg: Hello Everyone I am Student 1


>1. 如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现
>2. 如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用

### 使用场景
- 系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解
- 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象
- 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类

### 优缺点
- 优点
    + 减少了子类生成，Mediator将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成Meditator的子类即可。这样各个Colleague类可被重用
    + 它将各Colleague解耦，Mediator有利于各Colleague间的松耦合。你可以独立的改变和复用各Colleague类和Mediator类
    + 简化了对象协议，用Mediator和Colleague间的一对多的交互来代替多对多的交互。一对多的关系更容易理解、维护和扩展
    + 对对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的
- 缺点
    + 使控制集中化，中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议，它可能变得比任一个Colleague都复杂这可能使得中介者自身成为一个难于维护的庞然大物

### 与外观模式和代理模式及适配器模式及观察者模式的区别
1.各自定义：
+ 中介者模式(行为型)：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
+ 外观模式(结构型)：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
+ 代理模式(结构型)：为其他对象提供一个代理以控制对这个对象的访问
+ 适配器模式(结构型)：将一个类的接口转换成客户希望的另外一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
+ 观察者模式(行为型): 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新

2.区别和联系：
+ 外观模式与中介者的不同之处在于外观模式是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。它的协议是单向的，即外观对象对这个子系统类提出请求，但反之则不行。相反，中介者提供了各同事对象不支持或不能支持的协作行为，而且协议是多向的
+ 外观模式是对已有的子系统的所有对象的封装，对子系统提供统一的接口是根本目的。
+ 代理模式是一对一，一个代理只能代表一个对象，对已有对象的封装，控制访问是根本目的。中介者模式则是多对多，中介者的功能多样，客户也可以多个
+ 适配器模式也是一对一的，对已有对象的封装，适配是根本目的
+ 观察者模式涉及到两个概念：观察者和目标，解决的是观察者和众多目标之间通信的问题，不是目标之间的通信的问题，应用场景如手机应用给客户推送消息，注意手机应用是目标，顾客是观察者，而不是反之；而中介者模式也设计两个概念：中介和客户，它解决的是客户之间消息传递问题，应用场景如群组和中介所

## 中介者模式具体实例
---

### 即时通信群发消息问题
**使用中介者模式简单实现前言所述的群发消息功能**

**代码实现**
1.定义抽象中介者类`IMGroup`,声明同事之间通信的`notify()`接口:
```
class IMColleague;
// instance message abstract mediator class: IMGroup
class IMGroup
{
protected:
    list<IMColleague*> _listColleague; // 子类使用
public:
    virtual void attachColleague(IMColleague* colleague) 
    // 关联同事对象，子类不需要重写
    {
        _listColleague.push_back(colleague);
    }
    virtual void notify(IMColleague* sender, string msg) = 0;
};
```

2.分别定义两个具体的中介者类`WeiXinIMGroup`和`QQIMGroup`,并实现同事之间通信的`notify()`接口:
```
// instance message weixin mediator class: WeiXinIMGroup
class WeiXinIMGroup : public IMGroup
{
public:
    virtual void notify(IMColleague* sender, string msg)
    {
        for (list<IMColleague*>::iterator it = _listColleague.begin();
             it != _listColleague.end(); ++it)
        {
            if (sender != *it) // 发送者不需要接收消息
            {
                cout << "[Wei Xin Notify:] ";
                (*it)->recvMsg(msg);
                //调用其他同事类的接收消息方法，通过中介者（群）来通知其他同事接收消息
            }
        }
    }
};

// instance message qq mediator class: QQIMGroup
class QQIMGroup : public IMGroup
{
public:
    virtual void notify(IMColleague* sender, string msg)
    {
        for (list<IMColleague*>::iterator it = _listColleague.begin();
            it != _listColleague.end(); ++it)
        {
            if (sender != *it) // 发送者不需要接收消息
            {
                cout << "[QQ Notify:] ";
                (*it)->recvMsg(msg); 
                //调用其他同事类的接收消息方法，通过中介者（群）来通知其他同事接收消息
            }
        }
    }
};

```

3.定义抽象的同事类`IMColleague`,声明发送接口`sendMsg()`和接受消息接口`recvMsg()`:
```
// instance message abstract colleage class: IMColleague
class IMColleague
{
protected:
    IMGroup *_groupMediator; // 子类使用
public:
    IMColleague(IMGroup *mediator) : _groupMediator(mediator) {}; 
    //构造注入中介者对象
public:
    virtual void setIMGroup(IMGroup *mediator) 
    //客户端手动注入中介者对象，子类不需要重写
    { 
        _groupMediator = mediator;
    }
public:
    virtual void sendMsg(string msg) = 0; //dependon method
    virtual void recvMsg(string msg) = 0; // self method
};
```

4.分别定义具体的朋友类`FriendIMColleage`及亲戚类`RelativeIMColleage`,实现发送接口`sendMsg()`和接受消息接口`recvMsg()`：
```
// instance message friend colleage class: FriendIMColleage
class FriendIMColleage : public IMColleague
{
public:
    FriendIMColleage(IMGroup *mediator) : IMColleague(mediator) {};
public:
    void sendMsg(string msg)
    {
        cout << "Friend IM Colleage send msg: " << msg << endl;
        _groupMediator->notify(this, msg); //  调用中介者对象通知其他同事
    }
    void recvMsg(string msg)
    {
        cout << "Friend IM Colleage recv msg: " << msg << endl;
    }
};

// instance message friend colleage class: RelativeIMColleage
class RelativeIMColleage : public IMColleague
{
public:
    RelativeIMColleage(IMGroup *mediator) : IMColleague(mediator) {};
public:
    void sendMsg(string msg)
    {
        cout << "Relative IM Colleage send msg: " << msg << endl;
        _groupMediator->notify(this, msg); //  调用中介者对象通知其他同事
    }
    void recvMsg(string msg)
    {
        cout << "Relative IM Colleage recv msg: " << msg << endl;
    }
};
```

5.测试中介者器模式:
```
void MediatorTest_IMCommunication()
{
    IMGroup *weixin_mediator = new WeiXinIMGroup();

    // 初始化设置im_friend_a,im_friend_b,im_relative同事类的中介者为weixin
    IMColleague *im_friend_a = new FriendIMColleage(weixin_mediator);
    IMColleague *im_friend_b = new FriendIMColleage(weixin_mediator);
    IMColleague *im_relative = new RelativeIMColleage(weixin_mediator);

    // 将im_friend_a,im_friend_b,im_relative加入到weixin_mediator的list中：
    weixin_mediator->attachColleague(im_friend_a);
    weixin_mediator->attachColleague(im_friend_b);
    weixin_mediator->attachColleague(im_relative);

    im_relative->sendMsg("happy new year!!!"); // im_friend_a、im_friend_b均能收到

    // 重新设置im_friend_a,im_relative同事类的中介者为qq,而im_friend_b中介者仍为weixin
    IMGroup *qq_mediator = new QQIMGroup();
    im_friend_a->setIMGroup(qq_mediator);
    im_relative->setIMGroup(qq_mediator);

    // 将im_friend_a,im_relative加入到qq_mediator的list中：
    qq_mediator->attachColleague(im_friend_a);
    qq_mediator->attachColleague(im_relative);
    im_relative->sendMsg("happy birthday!!!");  // 只有im_friend_a能收到
};
```

6.运行结果:

    Relative IM Colleage send msg: happy new year!!!
    [Wei Xin Notify:] Friend IM Colleage recv msg: happy new year!!!
    [Wei Xin Notify:] Friend IM Colleage recv msg: happy new year!!!
    Relative IM Colleage send msg: happy birthday!!!
    [QQ Notify:] Friend IM Colleage recv msg: happy birthday!!!
