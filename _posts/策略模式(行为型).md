---
title: 策略模式(行为型)
date: 2016-5-26
categories: Design Pattern
tags:
- Design Pattern
- Behavior Pattern
---

## 前言
---
在出去旅游的时候，有很多种交通方式均能达到旅游的目的地。可以选择汽车，方便自由，也可以选择火车，速度较快，也可以沿途看风景，路程较远可以选择飞机，时间快。实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径，这就是本章要将要介绍的策略模式。

<!--more-->

## 策略模式
---
在策略模式中，定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法(策略)，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类，将算法的定义和使用分离，也就是将算法的行为和环境分开

### 意图
定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化

### 参与者
- Context
环境类，用一个ConcreteStrategy对象类配置
维护一个对Strategy对象的引用
可以定义一个接口来让Strategy访问它的数据

- Strategy
抽象策略类，定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy对象定义的算法

- ConcreteState
具体策略类，以Strategy接口实现某具体算法
可以拥有一个Context对象引用访问Context的数据

### 模式结构
![strategy_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FState_Abstract.PNG)

### 代码实现
1.首先定义状态上下类`StateContext`，维护了一个`State`类引用：
```
// State Context
class StateContext
{
private:
    State *m_pState; // 上下文的State引用
    int  m_value; //  上下文的信息
public:
    StateContext(State *pState, int value) : m_pState(pState), m_value(value) {};
public:
    void Request()
    {
        if (!NULL_POINTER(m_pState))
        {
            m_pState->Handle(this);
        }
    }
    void SetState(State *pState)
    {
        m_pState = pState;
    }
    State* GetState(void)
    {
        return m_pState;
    }
public:
    int GetValue(void)
    {
        return m_value;
    }
    void SetValue(int value)
    {
        m_value = value;
    }
};
```

2.再定义抽象的状态类`State`,并声明`Handle()`接口：
```
class State
{
public:
    virtual void Handle(StateContext *pSC) = 0;
};
```

3.再定义两个具体的状态类`ConcreteStateA`和`ConcreteStateB`,并实现`Handle()`接口：
```
// Concrete State A
class ConcreteStateA : public State
{
public:
    virtual void Handle(StateContext *pSC)
    {
        cout << "value is " << pSC->GetValue() << endl;
        cout << "Concrete State A Handle!!!" << endl;
    }
};

// Concrete State B
class ConcreteStateB : public State
{
public:
    virtual void Handle(StateContext *pSC)
    {
        cout << "value is " << pSC->GetValue() << endl;
        cout << "Concrete State B Handle!!!" << endl;
    }
};
```

4.测试状态模式：
```
void StateTest_General()
{
    State *pStateA = new ConcreteStateA();
    State *pStateB = new ConcreteStateB();

    StateContext *pSC = new StateContext(pStateA, 10); // 构造注入ConcreteStateA
    pSC->Request();

    // 在客户端根据上下文信息进行状态选择切换
    if (pSC->GetValue() <= 10)
    {
        pSC->SetState(pStateB);
    }
    else
    {
        pSC->SetState(pStateA);
    }
    pSC->Request();

    SAFE_RELASE_POINTER(pStateA);
    SAFE_RELASE_POINTER(pStateB);
    SAFE_RELASE_POINTER(pSC);
}
```

5.运行结果：

    value is 10
    Concrete State A Handle!!!
    value is 10
    Concrete State B Handle!!!


### 改进版
上述，是在客户端中根据上下文信息对状态进行切换，比较好的做法是将状态切换放在状态上下文类或具体的状态类中

#### 改进版1-在StateContext中切换状态

代码如下：
```
class StateContextEx
{
private:
    StateEx    *m_pCurrentState;
    ConcreteStateExA *m_pStateA;
    ConcreteStateExB *m_pStateB;
    int m_value;
public:
    StateContextEx(int value = 10)
    {
        m_pStateA = new ConcreteStateExA();
        m_pStateB = new ConcreteStateExB();
        m_pCurrentState = m_pStateA; // 初始化为状态A
        m_value = value;
    }
    virtual ~StateContextEx()
    {
        SAFE_RELASE_POINTER(m_pStateA);
        SAFE_RELASE_POINTER(m_pStateB);
    }
public:
    void SetState(StateEx *pState)
    {
        m_pCurrentState = pState;
    }
    void SetValue(int value)
    {
        m_value = value;
    }
    int GetValue(void)
    {
        return m_value;
    }
public:
    void Request()         // 在状态上下文中进行判断和切换
    {
        if (GetValue() < 10)
        {
            SetState(m_pStateA);
        }
        else
        {
            SetState(m_pStateB);
        }
        m_pCurrentState->Handle(); 
    }
};
```

#### 改进版2-在具体State中切换状态

1.具体State实现：
```
// Concrete State A
class ConcreteStateA : public State
{
public:
    virtual void Handle(StateContext *pSC) 
    {
        if (pSC->GetValue() < 10)
        {
            cout << "Concrete State A Handle!!!" << endl;
        }
        else if(pSC->GetValue() < 20)
        {
            pSC->SetState(new ConcreteStateB); // 可以优化为单例模式
            pSC->GetState()->Handle(pSC);
        }
        else
        {
            pSC->SetState(new ConcreteStateC); // 可以优化为单例模式
            pSC->GetState()->Handle(pSC);
        }
    }
};

// Concrete State B
class ConcreteStateB : public State
{
public:
    virtual void Handle(StateContext *pSC)
    {
        if (pSC->GetValue() < 10)
        {
            pSC->SetState(new ConcreteStateA); // 可以优化为单例模式
            pSC->GetState()->Handle(pSC);
        }
        else if (pSC->GetValue() < 20)
        {
            cout << "Concrete State B Handle!!!" << endl;
        }
        else
        {
            pSC->SetState(new ConcreteStateC); // 可以优化为单例模式
            pSC->GetState()->Handle(pSC);
        }
    }
};

// Concrete State C
class ConcreteStateC : public State
{
public:
    virtual void Handle(StateContext *pSC)
    {
        if (pSC->GetValue() < 10)
        {
            pSC->SetState(new ConcreteStateA); // 可以优化为单例模式
            pSC->GetState()->Handle(pSC);
        }
        else if (pSC->GetValue() < 20)
        {
            pSC->SetState(new ConcreteStateB); // 可以优化为单例模式
            pSC->GetState()->Handle(pSC);
        }
        else
        {
            cout << "Concrete State C Handle!!!" << endl;
        }
    }
};
```

2.这时候在环境上下文的设置状态接口中要增加释放内存的操作(若是单例模式则不需要)：
```
// State Context
class StateContext
{
private:
    State *m_pState; // 上下文的State引用
    int  m_value; //  上下文的信息
public:
    StateContext(State *pState, int value) : m_pState(pState), m_value(value) {};
public:
    void SetState(State *pState)
    {
        if(!NULL_POINTER(m_pState))
        {
            delete m_pState;  // 先删除之前的State对象指针
        }
        m_pState = pState;
    }
```

3.客户端调用：
```
void StateTest_GeneralEx()
{
    StateContextEx *pSCEx = new StateContextEx(5);
    pSCEx->Request(); // 只需Request，内部进行状态转换(包括上下文内部或具体状态内部)

    pSCEx->SetValue(20);
    pSCEx->Request();

    SAFE_RELASE_POINTER(pSCEx);
}
```

### 使用场景
- 对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化
- 代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强

### 优缺点
- 优点
    + 封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理
    + 将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为
    + 允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起
    + 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数
- 缺点
    + 会增加系统中类和对象的个数，导致系统运行开销增大
    + 对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态

## 状态模式具体实例
---

### Dota游戏战争状态问题
**使用状态模式简单实现前言所述的Dota游戏战争状态不同英雄行为不同功能**

**代码实现**
1.定义War上下文类`War`:
```
// War  (State Context)
class War
{
private:
    WarState *m_pWarState;
    int m_ElapsedDays;
public:
    War(WarState *pWarState) : m_pWarState(pWarState), m_ElapsedDays(0) {};
public:
    int GetElapsedDays()
    {
        return m_ElapsedDays;
    }
    void SetElapsedDays(int days)
    {
        m_ElapsedDays = days;
    }
    void SetWarState(WarState *pWarState)
    {
        m_pWarState = pWarState;
    }
    WarState* GetWarState()
    {
        return m_pWarState;
    }
    void RunWar() // 具体的War状态类负责状态选择和转换
    {
        m_pWarState->Run(this);
    }

    //void RunWar() //  环境变量类负责状态选择和转换
    //{
    //  if (GetElapsedDays() < PREPHASE_DAY_MAX)
    //  {
    //      m_pWarState = PrephaseWarState::Instance();
    //  }
    //  else if (GetElapsedDays() < METAPHASE_DAY_MAX)
    //  {
    //      m_pWarState = MetaphaseWarState::Instance();
    //  }
    //  else
    //  {
    //      m_pWarState = AnaphaseWarState::Instance();
    //  }
    //  m_pWarState->Run(); // 无需传入contxt
    //}

};
```

2.定义抽象的War状态类`WarState`,并声明`Run()`接口:
```
class WarState
{
public:
    virtual void Run(War *pWar) = 0;
};
```

3.定义具体的三个时期的War状态类后期`AnaphaseWarState`,中期`MetaphaseWarState`及前期`PrephaseWarState`, 实现`Run()`接口,并内部根据War进行的时间进行状态选择和切换:
```
// AnaphaseWarState
class AnaphaseWarState : public WarState // 单例模式
{
private:
    static AnaphaseWarState *m_pWarState;
    class Garbage //  单例模式内部类
    {
    public:
        virtual ~Garbage()
        {
            if (NULL_POINTER(AnaphaseWarState::Instance()))
            {
                delete AnaphaseWarState::Instance();
            }
        }
    };
    static Garbage g;  //根据类的静态成员变量在宿主类析构的时候自动调用静态成员类的析构函数的原理来释放单例模式对象
private:
    AnaphaseWarState() {};
    AnaphaseWarState(const AnaphaseWarState&) {};
    AnaphaseWarState& operator = (const AnaphaseWarState) {};
public:
    static AnaphaseWarState* Instance()
    {
        if (NULL_POINTER(m_pWarState))
        {
            m_pWarState = new AnaphaseWarState();
        }
        return m_pWarState;
    }
public:
    virtual void Run(War *pWar)
    {
        cout << "Now The War Is On Anaphase State, Anaphase dota heroes become the protagonist, War is coming to end" << "[time = " << pWar->GetElapsedDays()<< "]" << endl;
    }
};
AnaphaseWarState* AnaphaseWarState::m_pWarState = NULL;


// Metaphase War State
class MetaphaseWarState : public WarState // 单例模式
{
private:
    static MetaphaseWarState *m_pWarState;
    class Garbage
    {
    public:
        virtual ~Garbage()
        {
            if (NULL_POINTER(MetaphaseWarState::Instance()))
            {
                delete MetaphaseWarState::Instance();
            }
        }
    };
    static Garbage g;//根据类的静态成员变量在宿主类析构的时候自动调用静态成员类的析构函数的原理来释放单例模式对象
private:
    MetaphaseWarState() {};
    MetaphaseWarState(const MetaphaseWarState&) {};
    MetaphaseWarState& operator = (const MetaphaseWarState) {};
public:
    static MetaphaseWarState* Instance()
    {
        if (NULL_POINTER(m_pWarState))
        {
            m_pWarState = new MetaphaseWarState();
        }
        return m_pWarState;
    }
public:
    virtual void Run(War *pWar)    //  各个具体状态内部负责状态的选择和转换
    {
        if (pWar->GetElapsedDays() <= METAPHASE_DAY_MAX)
        {
            cout << "Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot" << "[time = " << pWar->GetElapsedDays()<< "]" << endl;
        }
        else
        {
            pWar->SetWarState(AnaphaseWarState::Instance());
            pWar->GetWarState()->Run(pWar);
        }
    }
};
MetaphaseWarState* MetaphaseWarState::m_pWarState = NULL;

// Prephase War State
class PrephaseWarState : public WarState // 单例模式
{
private:
    static PrephaseWarState *m_pWarState;
    class Garbage
    {
    public:
        virtual ~Garbage()
        {
            if (NULL_POINTER(PrephaseWarState::Instance()))
            {
                delete PrephaseWarState::Instance();
            }
        }
    };
    static Garbage g;//根据类的静态成员变量在宿主类析构的时候自动调用静态成员类的析构函数的原理来释放单例模式对象
private:
    PrephaseWarState() {};
    PrephaseWarState(const PrephaseWarState&) {};
    PrephaseWarState& operator = (const PrephaseWarState) {};
public:
    static PrephaseWarState* Instance()
    {
        if (NULL_POINTER(m_pWarState))
        {
            m_pWarState = new PrephaseWarState();
        }
        return m_pWarState;
    }
public:
    virtual void Run(War *pWar) //  各个具体状态内部负责状态的选择和转换
    {
        if (pWar->GetElapsedDays() <= PREPHASE_DAY_MAX)
        {
            cout << "Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin" << "[time = " << pWar->GetElapsedDays()<< "]" << endl;
        }
        else
        {
            pWar->SetWarState(MetaphaseWarState::Instance());
            pWar->GetWarState()->Run(pWar);
        }
    }
};
PrephaseWarState* PrephaseWarState::m_pWarState = NULL;
```

4.测试状态模式:
```
void StateTest_War()
{
    War *pW = new War(PrephaseWarState::Instance());

    for (int ElapsedDays = 0; ElapsedDays < 30; ElapsedDays+=4)
    {
        pW->SetElapsedDays(ElapsedDays);
        pW->RunWar(); // 客户端只负责调用RunWar即可，具体War状态内部进行了转换
    }

    SAFE_RELASE_POINTER(pW);
}
```

5.运行结果:

    Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin[time = 0]
    Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin[time = 4]
    Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin[time = 8]
    Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot[time = 12]
    Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot[time = 16]
    Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot[time = 20]
    Now The War Is On Anaphase State, Anaphase dota heroes become the protagonist, War is coming to end[time = 24]
    Now The War Is On Anaphase State, Anaphase dota heroes become the protagonist, War is coming to end[time = 28]

