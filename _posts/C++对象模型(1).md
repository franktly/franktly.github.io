---
title: C++对象模型(1)
date: 2016-6-14
categories: C++
tags:
- C++
- Object Model
---

## 前言
---
在C++中经常出现的问题就是求某个对象的大小，包括各种场景，如空类，含虚函数的类，不含虚函数的类等等，与之相关的就是C++最重要的特性多态的实现方式-虚函数的内部实现机制，这些问题都涉及到C++的对象模型布局，下面就从计算对象空间大小问题引出对象内部的实现方式，并介绍各个继承体系下对象内存布局情况大小，如未特殊说明本例均在VS2015环境下测试结果

<!--more-->

## 关于计算C++对象空间大小
---

### 一个空类的对象大小
---

如下面空类，求该类大小
```
class EmptyClass
{
};
```

测试：
```
void EmptyClassTest(void)
{
    EmptyClass e;
    std::cout << "Empty class size is: " << sizeof(e) << std::endl;
}
```

运行结果：

    Empty class size is: 1

一个类什么都没有，怎么还有一个Byte的空间呢？因为空类需要一个占位符，当类实例化对象时候，不同的对象有不同的地址从而区分不同的对象，如：

```
EmptyClass ee[3];
std::cout << "ee[0]:" << &ee[0] << " ee[1]:" << &ee[1] << " ee[2]:" << &ee[2] << std::endl;
```

运行结果：

        ee[0]:00AFFBF0 ee[1]:00AFFBF1 ee[2]:00AFFBF2

### 一个正常类的对象大小
求如下类对象的大小：

```
class FullClass
{
public:
    FullClass()
    {}
public:
    void Func1(void) // 普通成员函数
    {}
    static void Func2(void) // 静态成员函数
    {}
    virtual void Func3(void) // 虚成员函数
    {}
private:
    int _var1;  // 普通成员变量
    static int _var2; // 静态成员变量
};
```

测试：
```
void FullClassTest(void)
{
    FullClass f;
    std::cout << "Full class size is: " << sizeof(f) << std::endl;
}
```

运行结果：

        Full class size is: 8

可以看到对象的大小为8，通过VS查看内存布局的命令：

        cl inside_cpp_object_model.cpp /d1reportSingleClassLayoutFullClas

>`cl`命令的使用为： cl [filename] /d1reportSingleClassLayout[classname]

可以看到FullClass的VS下的内存布局为：

        class FullClass size(16):
                +---
         0      | {vfptr}
         8      | _var1
                | <alignment member> (size=4)
                +---
        FullClass::$vftable@:
                | &FullClass_meta
                |  0
         0      | &FullClass::Func3
        FullClass::Func3 this adjustor: 0

>即只有一个虚函数表的指针变量vfptr(指针类型(32位)占4 Bytes)和一个普通的成员变量_var1(int占4 Bytes)，其余的函数和变量不在对象的内存布局范围内
>静态数据成员、静态成员函数和普通成员函数均不占对象内存空间

### 考虑字节对齐
在上述`FullClass`类中增加一个`char`类型普通变量:

```
class FullClass
{
public:
    FullClass()
    {}
public:
    void Func1(void) // 普通成员函数
    {}
    static void Func2(void) // 静态成员函数
    {}
    virtual void Func3(void) // 虚成员函数
    {}
private:
    int _var1;  // 普通成员变量
    static int _var2; // 静态成员变量
    char _var3; // 增加的普通char类型变量，内存对齐
};
```

再次查看该类对象的大小：

    Full class size is: 12

此时查看对象大小不是`8 + 1 = 9`，而是`8 + 4 = 12`，因为最后一个`char`有4字节对齐(32位按照int大小对齐，数据宽度32位，使总线的运输效率最大化)处理，增加了padding，通过VS cl命令的结果：

        class FullClass size(16):
                +---
         0      | {vfptr}
         8      | _var1
        12      | _var3
                | <alignment member> (size=3)
                +---
        FullClass::$vftable@:
                | &FullClass_meta
                |  0
         0      | &FullClass::Func3
        FullClass::Func3 this adjustor: 0

> 使用`#pragma pack(1)`命令强制让其1字节对齐而不是默认的4字节对齐，从而结果为9 Bytes

### 对象大小总结
从上面的例子可以看出影响一个类对象的内存大小主要包括以下几个方面：
1. 其非静态数据成员的总和大小
2. 由于字节对齐而填补的空间大小
3. 为了支持virtual而由内部产生的额外空间(包括虚函数表指针vfptr和虚拟继承表指针vbptr)


## 对象模型种类
在C++中由两种类数据成员：static、nostatic；三种类成员函数：static、nostatic、virtual

>由于static不能修饰virtual，因为static属于类的而不是某个对象的，不存在this指针，而虚函数实现机制虚函数表需要this指针。所以此处的nostatic成员函数是指普通成员函数

对于类中各种成员的布局，有以下三种模式：
### 简单对象模型
特点：
对象由一系列的slots组成，每个slot指向一个成员，成员按照声明的次序依次被指定一个slot,每个数据成员和成员函数都有自己的slot(包括静态的或非静态的)
对于FullClass类，若用简单对象模型，则如下图所示：


### 表格驱动模型

### C++对象模型


## 三种对象模型总结

| 函数类型 | 是否有新对象产生 | 是否有深拷贝浅拷贝问题| 参数是否必须为引用| 执行时机 |
|:------------:|:--------------:|:-------------:|:-------------:|:-----------:|
| 普通构造函数  |    有       |   无，直接构造无拷贝过程   | 不必  |new或直接定义|
| 拷贝构造函数  |    有       |     有                   | 必须  |直接定义调用或函数入参对象传值或返回临时对象
| 赋值拷贝函数  |无，只是对象内成员变量拷贝|   有          | 最好是 |直接调用|


>1.这三个函数如果任意一个用户没有实现的时候，编译器在 **需要的时候**都会自动生成一个相应的函数，但是对于拷贝构造和赋值拷贝函数都是浅拷贝，如果涉及到操作指针成员最好 **自己重写两个函数**，否则在对象析构时候会对指针成员指向内存释放两次，如果被拷贝的指针成员以前指向的内存不为空还会出现内存泄漏问题
>2.这三个函数都可以存在多个，即可以参数不同可以重载多个


