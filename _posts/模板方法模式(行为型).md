---
title: 模板方法模式(行为型)
date: 2016-5-30
categories: Design Pattern
tags:
- Design Pattern
- Behavior Pattern
---

## 前言
---
在找工作写简历的时候，会发现网上有许多简历模板，这些简历模板都包含一些了解一个求职者的基本信息，包括个人基本信息，教育经历，工作经历等等，还有些非英语专业毕业的还需要包括CET的成绩，若英语专业则不需要。像这种简历模板只提供一个基本的模板，而具体的内容由具体的使用者(具体子类)实现的模式可以通过模板方式模式来实现。

<!--more-->

## 模板方法模式
---
模板方法模式是一种基于**继承**的代码复用技术，它是一种类行为型模式
模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为**模板方法**的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些基本方法，从而使得相同的算法框架可以有不同的执行结果

### 意图
定义了操作算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤

### 参与者
- AbstractClass
抽象类，定义抽象的原语操作(primitive operation)，具体的子类将重定义它们以实现一个算法
的各个步骤
实现一个模板方法,定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作

- ConcreteClass
具体类，实现原语操作(primitive operation)以完成算法中与特定子类相关的步骤

>**模板方法**：定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法，模板方法是一个具体方法。它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口
>**基本方法**：基本方法是实现算法各个步骤的方法，是模板方法的组成部分，分为三类
>1.抽象方法：抽象类声明、由其具体子类实现
>2.具体方法：个具体方法由一个抽象类或具体类声明并实现，其子类可以进行重写也可以直接继承
>3.钩子方法：由一个抽象类或具体类声明并实现，而其子类可能会加以扩展，一般来说有两种钩子方法，一种是父类是空的实现钩子方法，子类通过重写该方法来控制父类的流程；另一种是父类是个返回bool型的钩子方法，一般有个默认值，而子类通过重写该bool返回值的钩子方法，来控制父类的流程以实现在不同条件下执行模板方法中的不同步骤


### 模式结构
![template_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic/Strategy_Abstract.PNG)

### 代码实现
1.首先定义抽象策略类`Strategy`，声明算法接口`AlgorithmInterface()`：
```
// Abstract Strategy
class Strategy
{
public:
    virtual void AlgorithmInterface() = 0;
};
```

2.再定义三个具体的策略类`ConcreteStrategyA`、`ConcreteStrategyB`及`ConcreteStrategyC`,并实现算法接口`AlgorithmInterface()`：
```
// Concrete Strategy A
class ConcreteStrategyA : public Strategy
{
public:
    virtual void AlgorithmInterface()
    {
        cout << " I am Concrete Strategy A" << endl;
    }
};

// Concrete Strategy B
class ConcreteStrategyB : public Strategy
{
public:
    virtual void AlgorithmInterface()
    {
        cout << " I am Concrete Strategy B" << endl;
    }
};

// Concrete Strategy C
class ConcreteStrategyC : public Strategy
{
public:
    virtual void AlgorithmInterface()
    {
        cout << " I am Concrete Strategy C" << endl;
    }
};
```

3.再定义策略环境类`StrategyContext`,具有`Strategy`对象的引用：
```
// Context
class StrategyContext
{
private:
    Strategy *m_pStrategy;
public:
    StrategyContext(Strategy *pS) : m_pStrategy(pS) {};  // 构造静态注入策略对象
    virtual ~StrategyContext() 
    {
        SAFE_RELASE_POINTER(m_pStrategy);
    }
public:
    void SetStrategy(Strategy *pS)   // 动态注入策略对象
    {
        SAFE_RELASE_POINTER(m_pStrategy);// 释放之前申请的对象
        m_pStrategy = pS;
    }
public:
    void ContextInterface()
    {
        if (NULL_POINTER(m_pStrategy))
        {
            m_pStrategy->AlgorithmInterface(); // 调用注入的策略对象算法
        }
    }
};
```

4.测试策略模式：
```
void StrategyTest_General()
{
    Strategy *pCSA = new ConcreteStrategyA();
    Strategy *pCSB = new ConcreteStrategyB();
    Strategy *pCSC = new ConcreteStrategyC();

    StrategyContext *pSContext = new StrategyContext(pCSA);
    pSContext->ContextInterface();

    pSContext->SetStrategy(pCSB);
    pSContext->ContextInterface();

    pSContext->SetStrategy(pCSC);
    pSContext->ContextInterface();

    SAFE_RELASE_POINTER(pSContext);
}
```

5.运行结果：

     I am Concrete Strategy A
     I am Concrete Strategy B
     I am Concrete Strategy C


### 改进版

#### 改进版1-通过将Strategy作为C++模板参数来实现

在C++中，可利用模板机制用一个Strategy来配置一个类。然而这种技术仅当下面条件满足时才可以使用:
- 可以在编译时选择Strategy
- 它不需在运行时改变
在这种情况下，要被配置的类（如Context）被定义为以一个Strategy类作为一个参数的模板类

>使用模板不再需要定义给Strategy定义接口的抽象类。把Strategy作为一个模板参数也使得可以将一个Strategy和它的Context静态地绑定在一起，从而提高效率

1.实现代码如下：
```
template <typename T>
class StrategyContextEx  // StrategyContext以Strategy为模板参数
{
public:
    void ContextInterface(void)
    {
        _strategy.AlgorithmInterface();
    }
private:
    T _strategy;
};

//把具体的Strategy作为一个模板参数将一个Strategy和它的Context静态地绑定在一起
typedef StrategyContextEx<ConcreteStrategyA> StrategyContextA;
typedef StrategyContextEx<ConcreteStrategyB> StrategyContextB;
typedef StrategyContextEx<ConcreteStrategyC> StrategyContextC;
```

2.客户端测试代码：
```
void StrategyTest_GeneralTemplateEx()
{
    StrategyContextA SC_A;
    SC_A.ContextInterface();

    StrategyContextB SC_B;
    SC_B.ContextInterface();    
    
    StrategyContextC SC_C;
    SC_C.ContextInterface();
}
```

3.运行结果：

     I am Concrete Strategy A
     I am Concrete Strategy B
     I am Concrete Strategy C



#### 改进版2-通过工厂方法模式来创建具体策略对象
在上述策略模式中，客户端通过new不同的具体策略类来创建对象，对于多个策略可以将创建工作通过工厂方法模式来实现

1.具体实现：
```
// Use Factory Pattern to Produce Concrete Strategy

// Abstract Strategy Factory
class StrategyAbstractFactory
{
public:
    virtual Strategy* CreateStrategy() = 0;
};

// Concrete Strategy Factory A
class StrategyFactoryA : public StrategyAbstractFactory
{
public:
    virtual Strategy* CreateStrategy()
    {
        return new ConcreteStrategyA();
    }
};

// Concrete Strategy Factory B
class StrategyFactoryB : public StrategyAbstractFactory
{
public:
    virtual Strategy* CreateStrategy()
    {
        return new ConcreteStrategyB();
    }
};

// Concrete Strategy Factory C
class StrategyFactoryC : public StrategyAbstractFactory
{
public:
    virtual Strategy* CreateStrategy()
    {
        return new ConcreteStrategyC();
    }
};
```

2.客户端调用直接调用工厂方法即可：
```
void StrategyTest_GeneralEx()
{
    StrategyAbstractFactory *pSFA = new StrategyFactoryA();
    Strategy *pSA = pSFA->CreateStrategy();   // 调用工厂方法创建具体策略对象

    StrategyAbstractFactory *pSFB = new StrategyFactoryB();
    Strategy *pSB = pSFB->CreateStrategy();

    StrategyAbstractFactory *pSFC = new StrategyFactoryC();
    Strategy *pSC = pSFC->CreateStrategy();

    StrategyContext *pSContext =new StrategyContext(pSA);
    pSContext->ContextInterface();

    pSContext->SetStrategy(pSB);
    pSContext->ContextInterface();

    pSContext->SetStrategy(pSC);
    pSContext->ContextInterface();

    SAFE_RELASE_POINTER(pSFA);
    SAFE_RELASE_POINTER(pSFB);
    SAFE_RELASE_POINTER(pSFC);
    SAFE_RELASE_POINTER(pSContext);
}
```


3.进一步的，对于工厂方法，同样也可以通过C++模板特性来替换抽象Strategy类的多态特性，代码如下：
```
template <class T>
class StrategyFactoryBase
{
public:
    T* CreateStrategy(void)
    {
        return new T;
    }
};

typedef StrategyFactoryBase<ConcreteStrategyA>  StrategyFactoryTemplateA;
typedef StrategyFactoryBase<ConcreteStrategyB>  StrategyFactoryTemplateB;
typedef StrategyFactoryBase<ConcreteStrategyC>  StrategyFactoryTemplateC;
```

4.客户端使用：
```
void StrategyTest_GeneralFactoryTemplateEx()
{
    StrategyFactoryTemplateA SFT_A;
    Strategy *pSA = SFT_A.CreateStrategy();

    StrategyFactoryTemplateB SFT_B;
    Strategy *pSB = SFT_B.CreateStrategy();

    StrategyFactoryTemplateC SFT_C;
    Strategy *pSC = SFT_C.CreateStrategy();

    StrategyContext *pSContext = new StrategyContext(pSA);
    pSContext->ContextInterface();

    pSContext->SetStrategy(pSB);
    pSContext->ContextInterface();

    pSContext->SetStrategy(pSC);
    pSContext->ContextInterface();

    SAFE_RELASE_POINTER(pSContext);
}
```

5.运行结果：

     I am Concrete Strategy A
     I am Concrete Strategy B
     I am Concrete Strategy C


### 使用场景
- 许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种
- 需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间、时间权衡的算法。当这些变体实现为一个算法的类层次时,可以使用策略模式
- 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的与算法相关的数据结构，让算法和对象分开来，使得算法可以独立于使用它的客户而变化
- 一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句

### 优缺点
- 优点
    + 相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为 继承有助于析取出这些算法中的公共功能
    + 将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展
    + 消除了一些if else条件语句
    + 实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间、空间权衡取舍要求从不同策略中进行选择
- 缺点
    + 客户端必须知道所有的策略类，并自行决定使用哪一个策略类，该模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时才需要使用Strategy模式
    + 无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的ConcreteStrategy可能不使用其中的任何信息。这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题，那么将需要在Strategy和Context之间更进行紧密的耦合
    + 策略模式将造成产生很多策略类

### 与其他可以消除if-else条件模式的区别(状态模式、策略模式、工厂模式、责任链模式)

1.状态模式
- 可以认为“状态模式是完全封装且自修改的策略模式”
- 策略模式只是的条件选择只执行一次;而状态模式是随着实例参数（对象实例的状态）的改变不停地更改执行模式。换言之，策略模式只是在对象初始化的时候更改执行模式;而状态模式是根据对象实例的周期时间而动态地改变对象实例的执行模式
- 在状态模式中，状态的变迁是由对象的内部条件决定，外界只需关心其接口，不必关心其状态对象的创建和转化;而策略模式里，采取何种策略由外部条件(Context)决定
- 策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类;而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系
- 使用策略模式时，客户端需要知道所选的具体策略是哪一个;而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换
- 如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式;如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式

2.工厂模式
- 工厂模式是创建型模式，它关注对象创建提供创建对象的接口让对象的创建与具体的使用客户无关;策略模式是对象行为型模式，它关注行为和算法的封装。它定义一系列的算法，把每一个算法封装起来,，并且使它们可相互替换，使得算法可独立于使用它的客户而变化

3.责任链模式
- 状态与责任链两个设计模式最大的区别就是状态模式是让各个状态对象自己知道其下一个处理的对象是谁;而职责链模式中的各个对象并不指定其下一个处理的对象到底是谁，只有在客户端才设定

## 策略模式具体实例
---

### 旅游交通工具选择问题
**使用策略模式简单实现前言所述的旅游交通工具选择问题**

**代码实现**
1.定义抽象旅游策略类`TravelStrategy`，并声明`Travel()`接口:
```
// Abstract Travel Strategy
class TravelStrategy
{
public:
    virtual void Travel() = 0;
};
```

2.定义三种具体的旅游类`CarStrategy`、`AirplaneStrategy`和`TrainStrategy`，并实现`Travel()`接口:
```
// Concrete Travel Strategy : Car Strategy
// Singleton & Atuo memory delete
class CarStrategy : public TravelStrategy
{
private:
    static CarStrategy *m_pStrategy;
    class Garbage
    {
        ~Garbage()
        {
            if (!NULL_POINTER(CarStrategy::GetInstance()))
            {
                delete CarStrategy::GetInstance();
            }
        }
    };
    static Garbage g;
public:
    static CarStrategy* GetInstance()
    {
        if (NULL_POINTER(m_pStrategy))
        {
            m_pStrategy =  new CarStrategy();
        }

        return m_pStrategy;
    }
private:
    CarStrategy() {};
    CarStrategy(const CarStrategy&) {};
    CarStrategy& operator = (const CarStrategy&) {};
public:
    virtual void Travel()
    {
        cout << "Select The Way of Car For Traveling" << endl;
    }
};
CarStrategy* CarStrategy::m_pStrategy = NULL;

// Concrete Travel Strategy : Airplane Strategy
// Singleton & Atuo memory delete
class AirplaneStrategy : public TravelStrategy
{
private:
    static AirplaneStrategy *m_pStrategy;
    class Garbage
    {
        ~Garbage()
        {
            if (!NULL_POINTER(AirplaneStrategy::GetInstance()))
            {
                delete AirplaneStrategy::GetInstance();
            }
        }
    };
    static Garbage g;
public:
    static AirplaneStrategy* GetInstance()
    {
        if (NULL_POINTER(m_pStrategy))
        {
            m_pStrategy =  new AirplaneStrategy();
        }

        return m_pStrategy;
    }
private:
    AirplaneStrategy() {};
    AirplaneStrategy(const AirplaneStrategy&) {};
    AirplaneStrategy& operator = (const AirplaneStrategy&) {};
public:
    virtual void Travel()
    {
        cout << "Select The Way of Airplane For Traveling" << endl;
    }
};
AirplaneStrategy* AirplaneStrategy::m_pStrategy = NULL;

// Concrete Travel Strategy : Train Strategy
// Singleton & Atuo memory delete
class TrainStrategy : public TravelStrategy
{
private:
    static TrainStrategy *m_pStrategy;
    class Garbage
    {
        ~Garbage()
        {
            if (!NULL_POINTER(TrainStrategy::GetInstance()))
            {
                delete TrainStrategy::GetInstance();
            }
        }
    };
    static Garbage g;
public:
    static TrainStrategy* GetInstance()
    {
        if (NULL_POINTER(m_pStrategy))
        {
            m_pStrategy =  new TrainStrategy();
        }

        return m_pStrategy;
    }
private:
    TrainStrategy() {};
    TrainStrategy(const TrainStrategy&) {};
    TrainStrategy& operator = (const TrainStrategy&) {};
public:
    virtual void Travel()
    {
        cout << "Select The Way of Train For Traveling" << endl;
    }
};
TrainStrategy* TrainStrategy::m_pStrategy = NULL;
```

3.定义旅游的上下文调用类`Person`, 具有`TravelStrategy`的一个对象引用:
```
// Travel Context : Person
class Person
{
private:
    TravelStrategy *m_pTravelStrategy;
public:
    Person(TravelStrategy *pTS) : m_pTravelStrategy(pTS) {};
public:
    void SetTravelStrategy(TravelStrategy *pTS) // 有Garbage类，不需要手动释放ConcreteTravelStrategy对象了
    {
        m_pTravelStrategy = pTS;
    }
public:
    void Travel()
    {
        m_pTravelStrategy->Travel(); // 委托调用具体Strategy的Travel方法
    }
};
```

4.测试策略模式:
```
void StrategyTest_Travel()
{
    Person *pPerson = new Person(CarStrategy::GetInstance());
    pPerson->Travel();

    pPerson->SetTravelStrategy(AirplaneStrategy::GetInstance());
    pPerson->Travel();

    pPerson->SetTravelStrategy(TrainStrategy::GetInstance());
    pPerson->Travel();

    SAFE_RELASE_POINTER(pPerson);
}
```

5.运行结果:

    Select The Way of Car For Traveling
    Select The Way of Airplane For Traveling
    Select The Way of Train For Traveling

