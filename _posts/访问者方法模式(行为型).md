---
title: 访问者模式(行为型)
date: 2016-5-30
categories: Design Pattern
tags:
- Design Pattern
- Behavior Pattern
---

## 前言
---
在大型体育馆中有各种体育项目，如羽毛球室，乒乓球室，篮球室等等，每种运动项目场地都有会有各种职业背景的体育爱好者去，如学生，职工，老师；同时对于同一种职业背景的体育爱好者，可以访问多种运动项目。在软件开发中，有时候我们也需要处理像体育馆这样的不同的运动场所集合对象结构，在该对象结构中存储了多个不同类型的对象信息，而且对同一对象结构中的元素的操作方式并不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式等等，访问者模式，可以解决这样的问题，其模式动机就是以不同的方式操作复杂对象结构。

<!--more-->

## 访问者模式
---
访问者模式包含**访问者**和**被访问元素**两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作，访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作

>在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为**对象结构**，访问者通过遍历对象结构实现对其中存储的元素的逐个操作

### 意图
提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变个元素的类的前提下定义作用于这些元素的新的操作。访问者模式是一种对象行为型模式

### 参与者
- Visitor
抽象访问者，为该对象结构中ConcreteElement的每一个类声明一个visit操作。该操作的名字和特
征标识了发送visit请求给该访问者的那个类。这使得访问者可以确定被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它、

- ConcreteVisitor
具体访问者，实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片断乃是
对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果

- Element
定义一个accept操作，它以一个访问者为参数

- ConcreteElement
实现accept操作，该操作以一个访问者为参数

- ObjectStructure
能枚举它的元素
可以提供一个高层的接口以允许该访问者访问它的元素
可以是一个复合或是一个集合，如一个列表或一个无序集合

### 模式结构
![visitor_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic/Template_Abstract.PNG)

### 代码实现
1.首先定义抽象类`AbstractFrameWork`,声明和实现模板方法`SkeletonOperator()`,并声明或实现相应的原语操作:
```
// 骨架流程类
class AbstractFrameWork
{
public:  // 声明为public 客户端调用

    // 模板方法
    void SkeletonOperator()
    {
        PrimitiveOperator1();
        PrimitiveOperator2();
        PrimitiveOperator3();
        if (isSupportPrimitiveOperator4())
        {
            PrimitiveOperator4();
        }
        PrimitiveOperator5();
    }

protected:  
// 声明为protected 客户端不可见，子类可见, 也可以声明为private 对于virtual而言即使private属性也有多态

    //父类抽象虚拟方法，必须被子类实现
    virtual void PrimitiveOperator1() = 0;
    virtual void PrimitiveOperator2() = 0;

    // 父类具体普通方法，有默认实现，可以被子类覆盖（是有条件的,必须面对具体编程,且显式的直接调用PrimitiveOperator3,不能是模板方法SkeletonOperato）
    //最好是加virtual 子类就重写了该方法
    void PrimitiveOperator3()
    {
        cout << "PrimitiveOperator3 Default Implement" << endl;
        // 此时若在客户端通过基类指针来指向具体的子类对象(通过面对抽象编程)，此时不管指向哪个具体子类对象，调用的均是父类方法
        因为没有virtual,没有多态,是静态绑定的； 若想调用子类对象的方法，必须要面对具体对象编程，通过子类指针来指向子类对象，且显式的直接调用该方法
    }

    //父类具体虚拟方法，有默认实现，可以被子类重写
    virtual void PrimitiveOperator4()
    {
        cout << "PrimitiveOperator4 Default Implement" << endl;
    }

    // 父类具体钩子虚拟方法（默认是空的）,可以被子类重写,通过子类重写来控制父类的流程
    virtual void PrimitiveOperator5()
    {
    }
    // 父类具体钩子虚拟方法(返回bool类型）,可以被子类重写,通过子类重写来控制父类的流程
    virtual bool isSupportPrimitiveOperator4()
    {
        return true;
    }
};
```

2.再定义三个具体的实现类`ConcreteImplementA`、`ConcreteImplementB`和`ConcreteImplementC`,并实现或重写相应的原语操作：
```
//ConcreteImplementA
class ConcreteImplementA : public AbstractFrameWork
{
public:
    void PrimitiveOperator1()
    {
        cout << "ConcreteImplement A Primitive Operator1" << endl;
    }
    void PrimitiveOperator2()
    {
        cout << "ConcreteImplement A Primitive Operator2" << endl;
    }
    void PrimitiveOperator3() //覆盖了父类默认的普通方法PrimitiveOperator3，但是面对抽象编程时候子类该方法不会生效，除非父类该方法加virtual
    {
        cout << "ConcreteImplement A Primitive Operator3" << endl;
    }
    void PrimitiveOperator5()  // 重写了父类默认为空的钩子方法PrimitiveOperator5
    {
        cout << "ConcreteImplement A Primitive Operator5" << endl;
    }
};

//ConcreteImplementB
class ConcreteImplementB : public AbstractFrameWork
{
public:
    void PrimitiveOperator1()
    {
        cout << "ConcreteImplement B Primitive Operator1" << endl;
    }
    void PrimitiveOperator2()
    {
        cout << "ConcreteImplement B Primitive Operator2" << endl;
    }
    bool isSupportPrimitiveOperator4() // 重写了父类默认返回true的钩子方法isSupportPrimitiveOperator4
    {
        return false;
    }
};

////ConcreteImplementC
class ConcreteImplementC : public AbstractFrameWork
{
public:
    void PrimitiveOperator1()
    {
        cout << "ConcreteImplement C Primitive Operator1" << endl;
    }
    void PrimitiveOperator2()
    {
        cout << "ConcreteImplement C Primitive Operator2" << endl;
    }
    void PrimitiveOperator3() //覆盖了父类默认的普通方法PrimitiveOperator3，但是面对抽象编程时候子类该方法不会生效，除非父类该方法加virtual
    {
        cout << "ConcreteImplement C Primitive Operator3" << endl;
    }
    void PrimitiveOperator4() //重写了父类默认的虚方法PrimitiveOperator4
    {
        cout << "ConcreteImplement C Primitive Operator4" << endl;
    }
};
```

3.测试模板方法模式：
```
void TemplateTest_General()
{
    // 面对抽象编程
    AbstractFrameWork *pCI_A = new ConcreteImplementA();
    pCI_A->SkeletonOperator();

    AbstractFrameWork *pCI_B = new ConcreteImplementB();
    pCI_B->SkeletonOperator();

    AbstractFrameWork *pCI_C = new ConcreteImplementC();
    pCI_C->SkeletonOperator();

    // 面对具体编程
    ConcreteImplementA *pC_A = new ConcreteImplementA();
    pC_A->SkeletonOperator();   // 没有覆盖父类的方法，仍然调用的是父类的PrimitiveOperator3 Default Implement
    pC_A->PrimitiveOperator3(); // 覆盖了父类的方法：ConcreteImplement A Primitive Operator3
    ConcreteImplementC *pC_C = new ConcreteImplementC();
    pC_C->SkeletonOperator();   // 没有覆盖父类的方法，仍然调用的是父类的PrimitiveOperator3 Default Implement
    pC_C->PrimitiveOperator3(); // 覆盖了父类的方法：ConcreteImplement C Primitive Operator3

    SAFE_RELASE_POINTER(pCI_A);
    SAFE_RELASE_POINTER(pCI_B);
    SAFE_RELASE_POINTER(pCI_C);
    SAFE_RELASE_POINTER(pC_A);
    SAFE_RELASE_POINTER(pC_C);
}
```

4.运行结果：

    ConcreteImplement A Primitive Operator1
    ConcreteImplement A Primitive Operator2
    PrimitiveOperator3 Default Implement
    PrimitiveOperator4 Default Implement
    ConcreteImplement A Primitive Operator5
    ConcreteImplement B Primitive Operator1
    ConcreteImplement B Primitive Operator2
    PrimitiveOperator3 Default Implement
    ConcreteImplement C Primitive Operator1
    ConcreteImplement C Primitive Operator2
    PrimitiveOperator3 Default Implement
    ConcreteImplement C Primitive Operator4
    ConcreteImplement A Primitive Operator1
    ConcreteImplement A Primitive Operator2
    PrimitiveOperator3 Default Implement
    PrimitiveOperator4 Default Implement
    ConcreteImplement A Primitive Operator5
    ConcreteImplement A Primitive Operator3
    ConcreteImplement C Primitive Operator1
    ConcreteImplement C Primitive Operator2
    PrimitiveOperator3 Default Implement
    ConcreteImplement C Primitive Operator4
    ConcreteImplement C Primitive Operator3


### 与策略模式的区别
策略模式是对象行为型模式，是通过委托对象来达到复用目的；而模板方法模式是类行为型模，是通过继承来实现复用的

### 使用场景
- 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
- 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复
- 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制

### 优缺点
- 优点
    + 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序
    + 是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用
    + 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行
    + 可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则
- 缺点
    + 如果父类中可变的基本方法太多，将会导致类的个数增加，系统过于庞大


## 模板方法模式具体实例
---

### 简历模板问题
**使用模板方法模式简单实现前言所述的简历模板问题**

**代码实现**
1.定义简历模板类`Resume`，并声明和实现模板方法`WriteResume()`:
```
// 简历模板
class Resume
{
public:   // public,供客户端调用
    void WriteResume() //  模板方法
    {
        WritePersonalInfo();
        WriteEnducationExp();
        WriteWorkExp();
        if (isNotEnglishMajor())
        {
            WriteCETScore();
        }
        WritePublishedPaper();
    }
protected:  // protected
    virtual void WritePersonalInfo()  = 0;
    virtual void WriteEnducationExp() = 0;
    virtual void WriteWorkExp()       = 0;
    virtual bool isNotEnglishMajor() //钩子方法
    {
        return true;
    }
    virtual void WriteCETScore() = 0;
    virtual void WritePublishedPaper() //钩子方法
    {
    }
};
```

2.定义两个种具体的简历类`ResumeA`和`ResumeB`，并实现或重写相应的原语操作:
```
class ResumeA : public Resume
{
public:
    void WritePersonalInfo()
    {
        cout << "My Name is A" << endl;
    }
    void WriteEnducationExp()
    {
        cout <<"I Graduated from HUST" << endl;
    }
    void WriteWorkExp()
    {
        cout << "I Worked in ZTE" << endl;
    }
    void WriteCETScore()
    {
        cout << "CET4 is 550 score" << endl;
    }
};

class ResumeB : public Resume
{
public:
    void WritePersonalInfo()
    {
        cout << "My Name is B" << endl;
    }
    void WriteEnducationExp()
    {
        cout <<"I Graduated from WuHan University" << endl;
    }
    void WriteWorkExp()
    {
        cout << "I Worked in HW" << endl;
    }
    bool isNotEnglishMajor()
    {
        return false;
    }
    void WriteCETScore() // 必须实现，否则编译不过，不能实例化抽象类，此处为空实现
    {
    }
    void WritePublishedPaper()
    {
        cout << "I have published a paper about program learning " << endl;
    }
};
```

3.测试模板方法模式:
```
void TemplateTest_Resume()
{
    Resume *pR_A = new ResumeA();
    pR_A->WriteResume();

    Resume *pR_B = new ResumeB();
    pR_B->WriteResume();

    SAFE_RELASE_POINTER(pR_A);
    SAFE_RELASE_POINTER(pR_B);
}
```

4.运行结果:

    My Name is A
    I Graduated from HUST
    I Worked in ZTE
    CET4 is 550 score
    My Name is B
    I Graduated from WuHan University
    I Worked in HW
    I have published a paper about program learning

