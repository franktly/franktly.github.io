---
title: 设计模式(1)
date:
categories: Design Pattern 
tags:
- C++
- Design Pattern
- Design Principle
---

## 面向对象设计原则
1. 单一职责原则(SRO)
    **每个类应该专注于做一件事情**
    可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则
2. 里氏替换原则(LSP)
    **超类存在的地方，子类是可以替换的**
    子类必须实现父类中声明的所有方法，即基类对象替换为子类对象，程序将不会产生任何错误和异常，反之则不成立；使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现
3. 依赖倒置原则(DIP)
    **实现尽量依赖抽象(接口)编程，而不是面对实现编程**
    具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖
4. 接口隔离原则(ISP)
    **提供尽可能小的单独接口，而不要提供大的总接口**
    也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性
5. 迪米特法则(LOD)
    **又叫最少知识原则，即一个软件实体应当尽可能少的与其他实体发生相互作用**
    对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部；在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用
6. 开闭原则(OCP)
    **对扩展开放、对修改封闭**
    意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。**封装变化**是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象
7. 组合聚合复用原则(CARP)
    **尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象**
    在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用
## 设计模式概念
### 模式要义
1. **每个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复的劳动**
2. **对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述**
3. **一个设计模式命名、抽象和确定了一个通用设计结构的主要方面，这些设计结构能被用来构造可复用的面向对象设计。设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。每一个设计模式都集中于一个特定的面向对象设计问题或设计要点，描述了什么时候使用它，在另一些设计约束条件下是否还能使用，以及使用的效果和如何取舍**
### 模式要素
1. 模式名称(pattern name)
    **助记词，基于模式词汇表**
    在交流和讨论模式和编写文档时候用该词语
2. 问题(problem)
    **描述应该再何时使用模式，解释了设计问题和问题存在的前因后果**
    可能描述了特定的设计问题，也可能描述了导致不灵活设计的类或对象结构。有时候会包括使用模式必须满足的一系列先决条件
3. 解决方案(solution)
    **描述了设计的组成部分，它们之间的相互关系及各自的职责和协作方式**
    提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类或对象组合)来解决这个问题
4. 效果(consequences)
    **描述了模式应用的效果及使用模式赢权衡的问题**
    软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响
## 设计模式分类
根据两条准则对于模式进行分类：
1. 目的准则
   即模式是用来完成什么工作的。模式依据其目的可分为**创建型、结构型、或行为型**三种
   创建型模式与对象的创建有关；
   结构型模式处理类或对象的组合；
   行为型模式对类或对象怎样交互和怎样分配职责进行描述。
2. 范围准则
    指定模式主要是用于类还是用于对象，分为**类模式、对象模式**
    类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了；
    对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性；
    从某种意义上来说，几乎所有模式都使用继承机制，所以**类模式**只指那些集中于处理类间关系的模式，而大部分模式都属于**对象模式**的范畴