---
title: C++对象模型(2)
date: 2016-6-22
categories: C++
tags:
- C++
- Object Model
---

## 前言
---
前一篇主要介绍了C++对象的内部基本布局和三种对象模型，没有考虑到继承的情况，在各种继承情况下，对象的内存布局又有什么变化呢？接下来将从普通单继承，普通多继承，虚拟单继承，菱形普通继承，菱形虚拟继承等几种方式分别探究下C++对象模型的特点

<!--more-->

## 普通单继承
---

### 基类`Base`:

1.基类`Base`代码：

```
// Base 类： First Inheritance Level
class Base
{
public:
    Base(int var = 10) : _base_var(var) {};
public:
    virtual void Run(void) 
    {
        std::cout << "Base Class Run()" << std::endl;
    }
    virtual void RunBase(void) 
    {
        std::cout << "Base Class RunBase()" << std::endl;
    }
private:
    int _base_var;
};
```

2.基类`Base`在`cl`命令的内存布局：
通过`cl inside_cpp_object_model.cpp /d1reportSingleClassLayoutBase`命令查看VS内部的布局的结果如下：
```
class Base      size(16):
        +---
 0      | {vfptr}          // 第1个位置为虚函数表指针
 8      | _base_var        // 第2个位置为成员变量_base_var本身的数据
        | <alignment member> (size=4)
        +---
Base::$vftable@:        // 虚函数表指针指向的表内容：
        | &Base_meta   // 类元信息，相当于RTTI
        |  0
 0      | &Base::Run       // 虚函数表项0：&Base::Run
 1      | &Base::RunBase   // 虚函数表项1：&Base::RunBase
Base::Run this adjustor: 0
Base::RunBase this adjustor: 0
```

>

3.基类`Base`内存布局的代码验证：
+ 测试代码：
```
typedef void(*pFunc)(void); // 函数指针定义，后续使用到的函数指针均为此
void BaseTest(void)
{
    Base b;
    std::cout << "---------begin base object inner memory layout test-------" << std::endl;

    std::cout << " object size is: " << sizeof(b) << std::endl;
    std::cout << " object addr is: " << &b << std::endl; // 
    std::cout << " object vfptr addr is: " << (int*)*(int*)&b << std::endl; //vfptr 在对象第1个位置 最外层(int*)是把第一个位置的值转换为int地址类型
    std::cout << " typeid(b) is: " << typeid(b).name() << std::endl;  // b对象类型
    //std::cout << " object vfptr[-1] type info name is: " << ((type_info*)((int*)(*(int*)&b) - 1))->name() << std::endl;
    std::cout << " object vfptr[0] func ptr  is: " << (int*)*(int*)(*(int*)&b)<< std::endl; //vfptr[0]的值 
    std::cout << " object vfptr[0] func invoke res: ";
    pFunc pRun = (pFunc)(*(int*)(*(int*)&b));
    (*pRun)(); //调用vfptr[0](函数地址值)指向的函数
    std::cout << " object vfptr[1] func ptr  is: " << (int*)*((int*)(*(int*)&b) + 1) << std::endl; //vfptr[1]的值 
    std::cout << " object vfptr[1] func invoke res: ";
    pFunc pRunBase = (pFunc)(*((int*)(*(int*)&b) + 1));
    (*pRunBase)(); //调用vfptr[1](函数地址值)指向的函数
    std::cout << " object _base_var addr is: " << (int*)&b + 1 << std::endl; //_base_var 在对象第2个位置 
    std::cout << " object _base_var value is: " << *((int*)&b + 1) << std::endl; //_base_var 在对象第2个位置 

    std::cout << "---------end  base object inner memory layout test-------" << std::endl;
}
```

>&b为对象的地址；
>*(int*)&b为对象内存第一个位置的值，即是虚函数表地址，因此需要强转为int型指针类型，因为表项也为指针类型(表项为函数地址指针类型，而指针视为int类型)
>*((int*)(*(int*)&b) + n) 为虚函数表第n(n从0开始)个表项的值(即虚函数地址值)，需要强转为pFunc类型
>*((int*)&b + m)为对象内存第m个位置的值,此处m = 1为变量_base_var的数据本身值

+ 运行结果：
```
---------begin base object inner memory layout test-------
 object size is: 8
 object addr is: 010FFB28
 object vfptr addr is: 00C89BD0
 typeid(b) is: class Base
 object vfptr[0] func ptr  is: 00C810D2
 object vfptr[0] func invoke res: Base Class Run()
 object vfptr[1] func ptr  is: 00C81190
 object vfptr[1] func invoke res: Base Class RunBase()
 object _base_var addr is: 010FFB2C
 object _base_var value is: 10
---------end  base object inner memory layout test-------
```

+ 基类`Base`的内存布局示意图：
![]()



### 普通单继承的子类`Derive_Sin_Com`:

```
// Single Common Derive： Second Inheritance Level
class Derive_Sin_Com : public Base
{
public:
    Derive_Sin_Com(int var = 10) : Base(var), _derive_var(var) {}
public:
    virtual void Run(void) // override Base::Run()
    {
        std::cout << "Derive_Sin_Com Class Run()" << std::endl;
    }
    virtual void RunDerive_Sin_Com(void) // new virtual function
    {
        std::cout << "Derive_Sin_Com Class RunDerive_Sin_Com()" << std::endl;
    }
private:
    int _derive_sin_com_var;
};
```
3. 
如下面空类，求该类大小
```
class EmptyClass
{
};
```

测试：
```
void EmptyClassTest(void)
{
    EmptyClass e;
    std::cout << "Empty class size is: " << sizeof(e) << std::endl;
}
```

运行结果：

    Empty class size is: 1

一个类什么都没有，怎么还有一个Byte的空间呢？因为空类需要一个占位符，当类实例化对象时候，不同的对象有不同的地址从而区分不同的对象，如：

```
EmptyClass ee[3];
std::cout << "ee[0]:" << &ee[0] << " ee[1]:" << &ee[1] << " ee[2]:" << &ee[2] << std::endl;
```

运行结果：

        ee[0]:00AFFBF0 ee[1]:00AFFBF1 ee[2]:00AFFBF2

### 一个正常类的对象大小
求如下类对象的大小：

```
class FullClass
{
public:
    FullClass()
    {}
public:
    void Func1(void) // 普通成员函数
    {}
    static void Func2(void) // 静态成员函数
    {}
    virtual void Func3(void) // 虚成员函数
    {}
private:
    int _var1;  // 普通成员变量
    static int _var2; // 静态成员变量
};
```

测试：
```
void FullClassTest(void)
{
    FullClass f;
    std::cout << "Full class size is: " << sizeof(f) << std::endl;
}
```

运行结果：

        Full class size is: 8

可以看到对象的大小为8，通过VS 查看内存布局的`cl`命令：

        cl inside_cpp_object_model.cpp /d1reportSingleClassLayoutFullClas

>`cl`命令查看内存布局的使用方式： `cl [filename] /d1reportSingleClassLayout[classname]`

可以看到`FullClass`的VS下的内存布局为：

        class FullClass size(16):
                +---
         0      | {vfptr}
         8      | _var1
                | <alignment member> (size=4)
                +---
        FullClass::$vftable@:
                | &FullClass_meta
                |  0
         0      | &FullClass::Func3
        FullClass::Func3 this adjustor: 0

>即只有一个虚函数表的指针变量vfptr(指针类型(32位)占4 Bytes)和一个普通的成员变量_var1(int占4 Bytes)，其余的函数和变量不在对象的内存布局范围内
>静态数据成员、静态成员函数和普通成员函数均不占对象内存空间

### 考虑字节对齐
在上述`FullClass`类中增加一个`char`类型普通变量:

```
class FullClass
{
public:
    FullClass()
    {}
public:
    void Func1(void) // 普通成员函数
    {}
    static void Func2(void) // 静态成员函数
    {}
    virtual void Func3(void) // 虚成员函数
    {}
private:
    int _var1;  // 普通成员变量
    static int _var2; // 静态成员变量
    char _var3; // 增加的普通char类型变量，内存对齐
};
```

再次查看该类对象的大小：

    Full class size is: 12

此时查看对象大小不是`8 + 1 = 9`，而是`8 + 4 = 12`，因为最后一个`char`有4字节对齐(32位按照int大小对齐，数据宽度32位，使总线的运输效率最大化)处理，增加了`padding`，通过VS `cl`命令的结果：

        class FullClass size(16):
                +---
         0      | {vfptr}
         8      | _var1
        12      | _var3
                | <alignment member> (size=3)
                +---
        FullClass::$vftable@:
                | &FullClass_meta
                |  0
         0      | &FullClass::Func3
        FullClass::Func3 this adjustor: 0

> 使用`#pragma pack(1)`命令强制让其1字节对齐而不是默认的4字节对齐，从而结果为9 Bytes

### 对象大小总结
从上面的例子可以看出影响一个类对象的内存大小主要包括以下几个方面：
1. **其非静态数据成员的总和大小**
2. **由于字节对齐而填补的空间大小**
3. **为了支持virtual而由内部产生的额外空间(包括虚函数表指针vfptr和虚拟继承表指针vbptr)**


## 对象模型种类
在C++中由两种类数据成员：static、nostatic；三种类成员函数：static、nostatic、virtual

>由于static不能修饰virtual，因为static属于类的而不是某个对象的，不存在this指针，而虚函数实现机制虚函数表需要this指针。所以此处的nostatic成员函数是指普通成员函数

对于类中各种成员的布局，有以下三种模式：
### 简单对象模型
对象由一系列的slots组成，每个slot指向一个成员，成员按照声明的次序依次被指定一个slot,每个数据成员和成员函数都有自己的slot(包括静态的或非静态的)
对于`FullClass`类，若用简单对象模型，则如下图所示：

![simple_object_model](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fsimple_obj_model.PNG)

>简单对象模型中只存放各个成员的指针，可以解决“不同类型成员有不同大小的存储空间问题”，所以大小是指针大小与成员个数相乘，各个成员可以通过slot索引来寻址

### 表格驱动模型(双表格模型)
表格驱动模型中只存放两个表指针：成员数据表和成员函数表，成员函数表内各个slot指向一个函数地址，成员数据表内各个slot存放具体成员变量数据
对于`FullClass`类，若用表格驱动模型，则如下图所示：

![table_driven_model](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ftable_driven_model.PNG)


### C++对象模型
C++对象模型对上面两种模型在时间和空间上做了平衡和优化，对象模型内只存放虚函数表指针和具体的成员变量数据(和虚基类指针，若存在的话)，静态成员和普通成员函数在对象模型之外
对于`FullClass`类，若用C++模型，则如下图所示：

![cplusplus_object_model](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fcplusplus_obj_model.PNG)

### 三种对象模型总结

| 对象模型 | 计算大小|存储空间大小|数据成员存取效率| 是否包含静态成员或普通成员函数 |
|:------------:|:--------------:|:-------------:|:-------------:|:-----------:|
| 简单对象模型  |  指针大小与所有成员个数相乘，较大 | 较大| 数据成员两级寻址 |有|
| 表格驱动模型  |    2个表指针大小，较小         | 较小 | 数据成员两级寻址 |有|
| C++对象模型 |虚表指针(加上虚基表指针，若有)大小与真实数据成员大小之和，适中|适中|数据成员一级寻址 |无|


>从表格中可以看出C++对象模型优点在于空间和存取时间的综合效率上，且为了实现多态在虚函数表的**第一个位置上面**增加了RTTI运行时类型决定信息

## 总结
本篇主要介绍了C++类对象大小的计算，并引出了对象模型内部的基本内存布局和三种对象模型，下一篇将继续介绍在各种继承情况下，继承类的内存布局变化情况




