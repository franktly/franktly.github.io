---
title: 工厂模式（创建型）
date :
categories: Design Pattern 
tags:
- C++
- Design Pattern
- Design Principle
- Construction Pattern
---

## 前言
---
上一篇简要介绍了OOD的设计原则及设计模式的基本概念和模式的基本内容，从本篇开始介绍从*创建型*到结构型*再到行为型*总共**23种基本的设计模式**的概念和C++代码实现。本篇介绍**工厂模式**，包括以下三种模式：
- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

<!--more-->

## 简单工厂模式
---
在介绍工厂方法模式之前，先介绍下简单工厂模式

### 意图
定义一个创建对象的工厂类，并提供相应的创建对象的接口，简单工厂模式并不把一个类的实例化延迟到子类(也不存在子类)

### 参与者
- Concrete Factory
提供创建对象的接口，可以使用一个create接口来进行硬编码，也可以针对不同具体产品提供不同的create接口

- Abstract Product
抽象产品类，可以派生出多个具体产品

- Concrete Product
具体产品类

### 模式结构
![simple_factory](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FSimpleFactory.jpg)

### 代码实现
1. 首先定义一个抽象产品类，只提供一个简单的`Show()`接口显示不同产品类型的打印
```
class AbstractProduct
{
public:
    virtual void Show() = 0;
};
```

2. 然后分别根据抽象产品派生两个不同的产品类,
```
class ProductA: public AbstractProduct
{
public:
    void Show()
    {
        cout << "I am Product A" << endl;
    }
};

class ProductB: public AbstractProduct
{
public:
    void Show()
    {
        cout << "I am Product B" << endl;
    }
};
```
3. 最后定义一个简单的工厂类，并提供一个静态的create方法，通过硬编码的方法来创建对象
```
class SimpleFactory
{
public:
    static AbstractProduct* CreateProduct(int ProductType)
    {
        switch (ProductType)
        {
        case 1:
            return new ProductA();
            break;
        case 2:
            return new ProductB();
            break;
        default:
            return NULL;
            break;
        }
    }
};

```
除了硬编码还可以通过根据不同的产品提供不同create接口来实现：
```
class SimpleFactory
{
public:
    static AbstractProduct* CreateProductA()
    {
        return new ProductA();
    }
    static AbstractProduct* CreateProductB()
    {
        return new ProductB();
    }
};
```

4. 测试简单工厂
```
void SimpleFactoryTest()
{
    AbstractProduct *pPA = SimpleFactory::CreateProduct(1);
    // AbstractProduct *pPA = SimpleFactory::CreateProductA;
    pPA->Show();
    AbstractProduct *pPB = SimpleFactory::CreateProduct(2);
    // AbstractProduct *pPA = SimpleFactory::CreateProductB;
    pPB->Show();

    delete pPA; pPA = NULL;
    delete pPB; pPB = NULL;
};
```

运行结果：

    I am Product A
    I am Product B

### 适用场景
比较简单的对象创建

### 优缺点
- 优点：简单
- 缺点：要增加新的产品类型时，就需要修改工厂类，这就违反了开放封闭原则

## 工厂方法模式
---
如果想在增加新的产品类型时候，不需要修改原来的工厂类，从而符合开发封闭原则，可以考虑使用工厂方法模式类定义一个抽象接口，并增加新的产品工厂类即可

### 意图
定义一个用于创建对象的接口让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类

### 参与者
- Abstract Factory
声明工厂方法，该方法返回一个Abstract Product类型的对象。Abstract Factory也可以定义一个工厂方法的缺省实现，它返回一个缺省的Concrete Product对象；
工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品

- Concrete Factory
Concrete Factory决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现；
重定义工厂方法以返回一个Concrete Product实例；

- Abstract Product
抽象产品类，可以派生出多个具体产品

- Concrete Product
具体产品类

### 模式结构
![factory_method](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FFactoryMethod.jpg)

### 代码实现
1. 抽象产品和具体的产品代码见上节的**简单工厂模式**的*代码实现*部分
2. 与简单工厂模式不同的是，新增加了个抽象工厂类，提供一个virtual的create产品方法
```
class AbstractFactory
{
public:
    virtual AbstractProduct* CreateProduct() = 0;
};
```
3. 然后针对不同的具体产品，定义不同的具体工厂类,并override抽象工厂的create方法
```
// 产品类A的具体工厂A
class FactoryA: public AbstractFactory
{
public:
    AbstractProduct* CreateProduct()
    {
        return new ProductA();
    }
};

// 产品类B的具体工厂B
class FactoryB: public AbstractFactory
{
public:
    AbstractProduct* CreateProduct()
    {
        return new ProductB();
    }
};
```
4. 测试工厂方法模式
```
void FactoryMethodTest()
{
    AbstractFactory *pFA = new FactoryA(); // 抽象的工厂指针指向具体的工厂对象
    AbstractProduct *pPA = pFA->CreateProduct(); // 抽象的产品指针具体的产品对象
    pPA->Show();

    AbstractFactory *pFB = new FactoryB();
    AbstractProduct *pPB= pFB->CreateProduct();
    pPB->Show();

    delete pFA; pFA = NULL;
    delete pPA; pPA = NULL;
    delete pFB; pFB = NULL;
    delete pPB; pPB = NULL;
}
```

运行结果：

    I am Product A
    I am Product B


### 使用场景
- 当一个类不知道它所必须创建的对象的类的时候
- 当一个类希望由它的子类来指定它所创建的对象的时候
- 工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。
假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度
- 需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装

### 优缺点
- 优点：
    - 可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，
    只需依赖工厂即可得到自己想要的产品
    - 对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。
    - 降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的，即使变更了具体的实现，对调用者来说没有任何影响
- 缺点：
新增加一个产品类型就需要引入一个工厂类，会增加系统的复杂度

## 抽象工厂模式
---

### 意图

### 参与者

### 模式结构

### 代码实现

### 使用场景

### 优缺点


