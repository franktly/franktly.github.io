---
title: 观察者模式(行为型)
date: 
categories: Design Pattern
tags:
- Design Pattern
- Behavior Pattern
---

## 前言
---


<!--more-->

## 观察者模式
---
在网站博客系统中，当我们对某个博主的博客空间比较感兴趣的时候，都会选择订阅该博客，这时候就使我们很方便的获取到博主博客的更新文章了，当我们订阅的博客有更新变化时，它们也自动推送相应的更新通知给所有订阅该博客的订阅者，同时，作为订阅者，可以订阅多个博主博客。像这种一对多的对象之间的依赖关系，一个对象的改变能够影响其他对象的行为，可以通过观察者模式来实现。

>观察者用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。
在观察者模式中，发生改变的对象称为**观察目标**
而被通知的对象称为**观察者**
一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展

### 意图
定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。别名包括发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。是一种对象行为型模式

### 参与者
- Subject
观察者抽象目标，可以有任意多个观察者观察同一个目标
提供注册和删除观察者对象的接口
同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类

- ConcreteSubject
具体目标，抽象目标子类，它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知
实现了在目标类中定义的抽象业务逻辑方法

- Observer
抽象观察者，对观察目标的改变做出反应，观察者一般定义为接口
为那些在目标发生改变时需获得通知的对象定义一个更新接口update()

- ConcreteObserver
具体观察者，维护一个指向ConcreteSubject对象的引用
存储有关状态，这些状态应与目标的状态保持一致
实现Observer的更新接口update()以使自身状态与目标的状态保持一致

>当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者ConcreteObserver
>在得到一个具体目标的改变通知后, ConcreteObserver对象可向目标对象查询信息。
ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致

### 模式结构
![observer_pattern](http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FMemnto_Abstract.PNG)

### 代码实现
1.首先定义备忘录类`Memento`,备忘录类内部状态成员是私有的为了保证封装性,只有原发器能看到,声明原发器类为`friend`：
```
//状态信息类
struct MementoState
{
private:
    string m_stateinformation;
public:
    MementoState(string state): m_stateinformation(state) {};
public:
    string GetStateInform()
    {
        return m_stateinformation;
    }
};

// 备忘录
class Originator;
class Memento
{
private:
    MementoState m_state;
public:
    Memento(MementoState state) : m_state(state) {};
    friend class Originator; // Originator为友元类，只有Originator才能访问Memento成员
};
```

2.再定义原发器类`Originator`，并提供创建备忘录的接口`SaveStateToCreatedMemento()`和恢复备忘录的接口`LoadStateFromMemento()`:
```
// 原发器
class Originator
{
private:
    MementoState m_state;
public:
    Originator(MementoState state) : m_state(state) {};
public:
    Memento* SaveStateToCreatedMemento()
    {
        Memento *pMemento = new Memento(m_state);  // 生成备忘录
        return pMemento;
    }
    void LoadStateFromMemento(Memento *pMemento) // 恢复备忘录
    {
        m_state = pMemento->m_state;   // 只有Originator才能访问Memento的私有成员
    }
    void ChangeState(MementoState state)
    {
        m_state = state;
    }
    void ShowState()
    {
        cout << "State Information Is: " << m_state.GetStateInform() << endl;
    }
};
```

3.再定义备忘录的管理者类`Caretaker`，该类负责管理`Mememto`，负责保存备忘录，但是不能对备忘录的内容进行操作或检查，不能修改对象，也无须知道对象的实现细节：
```
// 备忘录管理
class Caretaker
{
private:
    vector<Memento*> m_vecMemento;  // vector 支持随机存取，list不支持,保存多个备忘录对象，可以支持多次撤销和恢复
public:
    Caretaker() {};
    virtual ~Caretaker()
    {
        for (vector<Memento*>::iterator it = m_vecMemento.begin();
             it != m_vecMemento.end();
             ++it)
        {
            SAFE_RELASE_POINTER(*it);  // 备忘录管理者负责释放备忘录对象内存
        }
        m_vecMemento.clear();
    }
public:
    void SaveMemento(Memento *pMemento)
    {
        m_vecMemento.push_back(pMemento);
    }
    Memento* LoadMementoByIndex(int MementoIndex)
    {
        return m_vecMemento[MementoIndex];
    }
};
```

4.测试备忘录模式：
```
void MementoTest_General()
{
    Caretaker *pCT = new Caretaker();
    MementoState state1("First Step");
    MementoState state2("Second Step");
    MementoState state3("Third Step");

    Originator *pO = new Originator(state1);
    pO->ShowState();

    pCT->SaveMemento(pO->SaveStateToCreatedMemento()); // Caretaker 管理添加新建的第一个Memento
    pO->ChangeState(state2);
    pO->ShowState();

    pCT->SaveMemento(pO->SaveStateToCreatedMemento()); // Caretaker 管理添加新建的第二个Memento
    pO->ChangeState(state3);
    pO->ShowState();

    cout << "Restore State 1: ";
    pO->LoadStateFromMemento(pCT->LoadMementoByIndex(1)); // 从Caretaker中取第二个Memento保存的状态
    pO->ShowState();

    cout << "Restore State 0: ";
    pO->LoadStateFromMemento(pCT->LoadMementoByIndex(0)); // 从Caretaker中取第一个Memento保存的状态
    pO->ShowState();

    SAFE_RELASE_POINTER(pO);
    SAFE_RELASE_POINTER(pCT);
}
```

5.运行结果：

    State Information Is: First Step
    State Information Is: Second Step
    State Information Is: Third Step
    Restore State 1: State Information Is: Second Step
    Restore State 0: State Information Is: First Step


>备忘录的封装：
>备忘录是一个很特殊的对象，只有原发器对它拥有控制的权力，负责人只负责管理，而其他类无法访问到备忘录,它只需要从负责人处取出备忘录对象并将原发器对象的状态恢复，而无须关心备忘录的保存细节。理想的情况是只允许生成该备忘录的那个原发器访问备忘录的内部状态，
>在C++中可以使用friend关键字，让原发器类和备忘录类成为友元类，互相之间可以访问对象的一些私有的属性；在Java语言中可以将原发器类和备忘录类放在一个包中，让它们之间满足默认的包内可见性；也可以将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据

### 使用场景
- 必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态
- 如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性

### 优缺点
- 优点
    + 提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤
    + 备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作
- 缺点
    + 如果原发器在生成备忘录时必须拷贝并存储大量的信息或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销

>存储增量式改变：如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变

## 备忘录模式具体实例
---

### 游戏角色状态保存恢复问题
**使用备忘录模式简单实现前言所述的游戏角色保存和恢复功能**

**代码实现**
1.定义游戏角色备忘录类`GameRoleMemento`:
```
// 游戏角色备忘录
class GameRole;
class GameRoleMemento
{
private:
    int m_RoleAgileValue;
    int m_RolePowerValue;
    int m_RoleIntelligenceValue;
public:
    GameRoleMemento(int agile, int powr, int intelligence)
        : m_RoleAgileValue(agile), m_RolePowerValue(powr), m_RoleIntelligenceValue(intelligence) {};
    friend class GameRole;
};

```

2.定义游戏角色原发器类`GameRole`,包含创建和恢复游戏角色备忘录的接口:
```
// 游戏角色(原发器)
class GameRole
{
private:
    int m_RoleAgileValue;
    int m_RolePowerValue;
    int m_RoleIntelligenceValue;
public:
    GameRole(int agile, int powr, int intelligence)
        : m_RoleAgileValue(agile), m_RolePowerValue(powr), m_RoleIntelligenceValue(intelligence) {};
public:
    GameRoleMemento* CreateMemento()
    {
        return new GameRoleMemento(m_RoleAgileValue, m_RolePowerValue, m_RoleIntelligenceValue);
    }
    void SetMemento(GameRoleMemento *pGameRoleMemento)
    {
        m_RoleAgileValue = pGameRoleMemento->m_RoleAgileValue;
        m_RolePowerValue = pGameRoleMemento->m_RolePowerValue;
        m_RoleIntelligenceValue = pGameRoleMemento->m_RoleIntelligenceValue;
    }
    void Attack()
    {
        m_RolePowerValue-= 10;
    }
    void ShowAttribute()
    {
        cout << "Hero Attribution: [Agile]:" << m_RoleAgileValue << " [Power]:" << m_RolePowerValue << 
        " [Intelligence]:" << m_RoleIntelligenceValue << endl;
    }
};
```

3.定义游戏角色备忘录管理者类`GameRoleCaretaker`,负责管理游戏角色备忘录:
```
// 游戏角色备忘录管理者
class GameRoleCaretaker
{
private:
    vector<GameRoleMemento*> m_vecGameRoleMemento;
public:
    GameRoleCaretaker() {};
    virtual ~GameRoleCaretaker()
    {
        for (vector<GameRoleMemento*>::iterator it = m_vecGameRoleMemento.begin();
             it != m_vecGameRoleMemento.end();
             ++it)
        {
            SAFE_RELASE_POINTER(*it);
        }
        m_vecGameRoleMemento.clear();
    }
public:
    void SaveGameRoleMemento(GameRoleMemento *pGRM)
    {
        m_vecGameRoleMemento.push_back(pGRM);
    }
    GameRoleMemento* LoadGameRoleMementoByIndex(int GameRoleMementoIndex)
    {
        return m_vecGameRoleMemento[GameRoleMementoIndex];
    }
};
```

4.测试备忘录模式:
```
void MementoTest_GameRole()
{
    GameRoleCaretaker *pGRCT = new GameRoleCaretaker();

    //原始属性状态
    GameRole  *pGR = new GameRole(50,50,50);
    pGR->ShowAttribute();

    //攻击一次后的状态，先保存,并显示属性
    pGRCT->SaveGameRoleMemento(pGR->CreateMemento());
    pGR->Attack();
    pGR->ShowAttribute();


    //再攻击一次后的状态，先保存,并显示属性
    pGRCT->SaveGameRoleMemento(pGR->CreateMemento());
    pGR->Attack();
    pGR->ShowAttribute();

    //恢复第二次攻击前的状态,并显示属性
    cout << "Game Role Restore 1： ";
    pGR->SetMemento(pGRCT->LoadGameRoleMementoByIndex(1));
    pGR->ShowAttribute();
    
    //恢复第一次攻击前的状态,并显示属性
    cout << "Game Role Restore 0： ";
    pGR->SetMemento(pGRCT->LoadGameRoleMementoByIndex(0));
    pGR->ShowAttribute();

    SAFE_RELASE_POINTER(pGRCT);
    SAFE_RELASE_POINTER(pGR);
}
```

5.运行结果:

    Hero Attribution: [Agile]:50 [Power]:50 [Intelligence]:50
    Hero Attribution: [Agile]:50 [Power]:40 [Intelligence]:50
    Hero Attribution: [Agile]:50 [Power]:30 [Intelligence]:50
    Game Role Restore 1： Hero Attribution: [Agile]:50 [Power]:40 [Intelligence]:50
    Game Role Restore 0： Hero Attribution: [Agile]:50 [Power]:50 [Intelligence]:50
