<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Just Do It]]></title>
  <subtitle><![CDATA[Love Read | Film | Song | Snooker]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.franktly.com/"/>
  <updated>2016-01-24T07:15:25.223Z</updated>
  <id>http://www.franktly.com/</id>
  
  <author>
    <name><![CDATA[Frank Tao]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Git使用总结]]></title>
    <link href="http://www.franktly.com/2016/01/23/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://www.franktly.com/2016/01/23/Git使用总结/</id>
    <published>2016-01-22T16:00:00.000Z</published>
    <updated>2016-01-24T07:15:25.223Z</updated>
    <content type="html"><![CDATA[<h2 id="Git_u7B80_u4ECB"><a href="#Git_u7B80_u4ECB" class="headerlink" title="Git简介"></a>Git简介</h2><hr>
<p>Git 是一个免费的、分布式版本控制工具，或是一个强调了速度快的源代码管理工具<br><a id="more"></a></p>
<h3 id="u96C6_u4E2D_u5F0FVS_u5206_u5E03_u5F0F"><a href="#u96C6_u4E2D_u5F0FVS_u5206_u5E03_u5F0F" class="headerlink" title="集中式VS分布式"></a>集中式VS分布式</h3><h4 id="u96C6_u4E2D_u5F0F"><a href="#u96C6_u4E2D_u5F0F" class="headerlink" title="集中式"></a>集中式</h4><ol>
<li>概念：<br>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。<br>集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如 果脱离了服务器，开发者基本上是不可以工作的。</li>
<li>特点：<ul>
<li>服务器压力太大，数据库容量暴增。</li>
<li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li>
<li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fcentralization.png" alt="centralization"></li>
</ul>
</li>
<li>工作流程像是这样的：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fjizhongshi.png" alt="jzs"></li>
<li>代表：<br>SVN </li>
</ol>
<h4 id="u5206_u5E03_u5F0F"><a href="#u5206_u5E03_u5F0F" class="headerlink" title="分布式"></a>分布式</h4><ol>
<li>概念：<br>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了<br>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</li>
<li>特点：<ul>
<li>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了</li>
<li>适合分布式开发，强调个体</li>
<li>公共服务器压力和数据量都不会太大。</li>
<li>速度快、灵活</li>
<li>任意两个开发者之间可以很容易的解决冲突。<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fdistributed.png" alt="distributed"></li>
</ul>
</li>
<li>工作流程像是这样的：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ffenbushi.png" alt="fbs"><br>分布式和集中式的最大区别在于开发者可以在本地提交。每个开发者机器上都有一个服务器的数据库</li>
<li>代表：<br>Git</li>
</ol>
<h3 id="Git_u5DE5_u4F5C_u533A_26amp_3B_u6682_u5B58_u533A_26amp_3B_u7248_u672C_u5E93"><a href="#Git_u5DE5_u4F5C_u533A_26amp_3B_u6682_u5B58_u533A_26amp_3B_u7248_u672C_u5E93" class="headerlink" title="Git工作区&amp;暂存区&amp;版本库"></a>Git工作区&amp;暂存区&amp;版本库</h3><p>Git分为三个区域：</p>
<ol>
<li>工作区(working directory): 本地电脑能看到的目录(即<code>git init</code>执行的文件目录)</li>
<li>暂存区(stage index):工作区一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库，里面的stage（或者叫index）称为暂存区</li>
<li>版本库(master): Git为我们自动创建的第一个分支master，以及指向master的一个指针叫<code>HEAD</code><br>区域的示意图如下：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fgit_three_zones.png" alt="git-three-zones"><blockquote>
<p><code>git add</code>命令将使工作区的目录树写到暂存区中，暂存区中的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中<br><code>git commit</code>命令使暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树<br><code>git checkout</code>或者<code>git checkout --&lt;filename&gt;</code>命令会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动；即工作区未<code>add</code>的修改被丢弃，暂存区不变<br><code>git reset HEAD</code>命令会使暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响；即暂存区未<code>commit</code>的修改被丢弃，工作区不变<br><code>git checkout HEAD</code>或者<code>git checkout HEAD &lt;filename&gt;</code>命令会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动；即版本库不变，工作区未<code>add</code>和暂存区未<code>commit</code>的修改被丢弃<br><code>git rm --cached &lt;filename&gt;</code>命令会直接从暂存区删除文件，工作区则不做出改变<br><code>git diff</code>比较的是工作区和暂存区的差别<br><code>git diff --cached</code>比较的是暂存区和版本库的差别<br><code>git diff HEAD</code>比较的是工作区和版本库的差别</p>
</blockquote>
</li>
</ol>
<h2 id="Git_u5E38_u7528_u64CD_u4F5C"><a href="#Git_u5E38_u7528_u64CD_u4F5C" class="headerlink" title="Git常用操作"></a>Git常用操作</h2><hr>
<h3 id="u672C_u5730_u4ED3_u5E93Repository_u7BA1_u7406"><a href="#u672C_u5730_u4ED3_u5E93Repository_u7BA1_u7406" class="headerlink" title="本地仓库Repository管理"></a>本地仓库Repository管理</h3><h4 id="u521D_u59CB_u5316Git_u4ED3_u5E93"><a href="#u521D_u59CB_u5316Git_u4ED3_u5E93" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h4><pre><code>git init
</code></pre><blockquote>
<p>仓库(repository)，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的</p>
</blockquote>
<h4 id="u6DFB_u52A0_u6587_u4EF6_u5230Git_u4ED3_u5E93"><a href="#u6DFB_u52A0_u6587_u4EF6_u5230Git_u4ED3_u5E93" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h4><p>Step 1.  添加文件到暂存区(stage index)</p>
<pre><code>git add &lt;filename&gt;
</code></pre><blockquote>
<p>可反复多次使用，添加多个文件<br>每次修改，如果不add到暂存区，那就不会加入到commit中</p>
</blockquote>
<p>Step 2. 提交文件到Git仓库</p>
<pre><code>git commit [-m]
</code></pre><blockquote>
<p>可选参数-m 后面添加提交的说明信息</p>
</blockquote>
<h4 id="u5220_u9664Git_u4ED3_u5E93_u4E2D_u7684_u6587_u4EF6"><a href="#u5220_u9664Git_u4ED3_u5E93_u4E2D_u7684_u6587_u4EF6" class="headerlink" title="删除Git仓库中的文件"></a>删除Git仓库中的文件</h4><p>首先<code>git rm</code> ,然后 <code>git commit</code>：</p>
<pre><code>git rm &lt;filename&gt;
git commit [-m]
</code></pre><blockquote>
<p>如果本地误删了，版本库中还没有删除，可以通过<code>git checkout -- &lt;filename&gt;</code>还原仓库中版本到工作区</p>
</blockquote>
<h4 id="u67E5_u770B_u7248_u672C_u72B6_u6001"><a href="#u67E5_u770B_u7248_u672C_u72B6_u6001" class="headerlink" title="查看版本状态"></a>查看版本状态</h4><pre><code>git status
</code></pre><blockquote>
<p>命令可以让我们时刻掌握工作区的状态</p>
</blockquote>
<pre><code>git diff &lt;filename&gt;
</code></pre><blockquote>
<p>可以查看修改内容<br>查看工作区和版本库里面最新版本的区别:<code>git diff HEAD -- &lt;filename&gt;</code></p>
</blockquote>
<h4 id="u64CD_u4F5C_u56DE_u9000"><a href="#u64CD_u4F5C_u56DE_u9000" class="headerlink" title="操作回退"></a>操作回退</h4><h5 id="u7248_u672C_u56DE_u9000"><a href="#u7248_u672C_u56DE_u9000" class="headerlink" title="版本回退"></a>版本回退</h5><p>版本回退指丢弃版本库的修改，从Git本地版本库中回退版本到本地工作区<br>在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code><br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向回退的目标版本：<br>回退版本命令</p>
<pre><code>git reset --hard &lt;commit_id&gt;
</code></pre><blockquote>
<p><code>--hard</code>参数将版本库，暂存区和工作区的内容全部重置为某个commit_id的状态<br><code>git reset</code>默认是<code>git reset --mixed &lt;commit_id&gt;</code>可以让版本库重置到某个commit状态，该commit之后的commit不会保留，并重置暂存区，但是不改变工作区。即这个时候，上次提交的内容在工作区中还会存在<br><code>git revert</code>比<code>git reset</code>更加温柔一点，回滚到某次commit且该commit之后的提交记录都会保留，并且会在此基础上新建一个提交。对于已经<code>git push</code>到服务器上的内容作回滚，推荐使用<code>git revert</code><br>回退到指定的版本，commit_id可以通过<code>git log</code>命令查看<br>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了<br>回退到上一个版本：<code>git reset --hard HEAD^</code><br>回退到上上一个版本：<code>git reset --hard HEAD^^</code></p>
</blockquote>
<pre><code>git log
</code></pre><blockquote>
<p>查看提交历史，包含提交时间，作者和commit_id，以便确定要回退到哪个版本</p>
</blockquote>
<pre><code>git reflog
</code></pre><blockquote>
<p>查看命令历史，包含commit_id,命令操作信息等，以便确定要回到未来的哪个版本</p>
</blockquote>
<h5 id="u4FEE_u6539_u56DE_u9000"><a href="#u4FEE_u6539_u56DE_u9000" class="headerlink" title="修改回退"></a>修改回退</h5><p>修改回退指丢弃工作区或暂存区的修改，从Git本地暂存区或工作区中回退修改到本地工作区</p>
<ol>
<li><p>工作区修改回退<br>如果想丢弃工作的修改可以输入：</p>
<pre><code>git checkout -- &lt;filename&gt; 
</code></pre><p><code>git checkout</code>其实是会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动，无论工作区是修改还是删除，都可以“一键还原”，操作后就回到和暂存区一模一样的状态，这里有两种情况：</p>
<ul>
<li>一种是filename自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态（即丢弃了工作区的修改）</li>
<li>一种是filename已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态(即暂存区的修改仍然存在，只是工作区的修改丢弃了)<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。<br><code>git checkout -- &lt;filename&gt;</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令</li>
</ul>
</li>
<li><p>暂存区修改回退<br>如果你的修改只是通过<code>git add</code>添加到了暂存区，还没有提交，想撤销掉暂存区的修改(unstage),可以输入：</p>
<pre><code>git reset HEAD &lt;filename&gt;
</code></pre><p>可以把暂存区的修改撤销掉（unstage），重新把修改放回工作区,操作后，暂存区是干净的(暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响)工作区有修改;如果再想进一步的丢弃工作区的修改可以参照上面<strong>工作区修改回退</strong><br><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本</p>
</li>
</ol>
<h5 id="u5E38_u7528_u7684_u5404_u79CD_u573A_u666F_u56DE_u9000_u547D_u4EE4_u64CD_u4F5C_u6D41_u7A0B"><a href="#u5E38_u7528_u7684_u5404_u79CD_u573A_u666F_u56DE_u9000_u547D_u4EE4_u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="常用的各种场景回退命令操作流程"></a>常用的各种场景回退命令操作流程</h5><ol>
<li><p>修改了工作区，丢弃工作区的修改：</p>
<pre><code>modify code in filename of working dir 
git checkout --filename
</code></pre></li>
<li><p>修改了工作区，并add到了暂存区了，丢弃暂存区的修改：</p>
<pre><code>modify code in filename of working dir 
git add
git reset HEAD filename
</code></pre><p>如果想进一步丢弃暂存区回退到工作区的修改：</p>
<pre><code>git checkout -- filenmae
</code></pre><p>至此，工作区与版本库中一样了</p>
</li>
<li><p>修改了工作区，并add到了暂存区了，又修改工作区，丢弃工作区的修改：</p>
<pre><code>modify code in filename of working dir 
git add
modify code in filename of workding dir again
git checkout -- filenmae
</code></pre><p>如果又想丢弃暂存区的修改，继续输入：</p>
<pre><code>git reset HEAD filename
</code></pre><p>如果继续想把暂存区回退到工作区的修改也丢弃掉，继续输入：</p>
<pre><code>git checkout -- filenmae
</code></pre><p>至此，工作区与版本库中一样了</p>
</li>
<li><p>修改了工作区，并commit到仓库，撤销掉仓库的指定commit:</p>
<pre><code>modify code in filename of working dir
git add
git commit
git log
git reset --hard commit_id
</code></pre><p>如果突然发现是误撤销，又想回到之前的状态：</p>
<pre><code>git reflog
git reset --hard commit_id
</code></pre></li>
</ol>
<h4 id="u5206_u652F_u7BA1_u7406"><a href="#u5206_u652F_u7BA1_u7406" class="headerlink" title="分支管理"></a>分支管理</h4><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。默认情况下，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支</p>
<h5 id="u5206_u652F_u64CD_u4F5C_u547D_u4EE4"><a href="#u5206_u652F_u64CD_u4F5C_u547D_u4EE4" class="headerlink" title="分支操作命令"></a>分支操作命令</h5><p>创建branchname分支，并切换到该分支：</p>
<pre><code>git checkout -b &lt;branchname&gt;
</code></pre><blockquote>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<pre><code>git branch &lt;branchname&gt;
git checkout &lt;branchname&gt;
</code></pre><p><code>git branch &lt;branchname&gt;</code>：表示创建指定分支<br><code>git checkout &lt;branchname&gt;</code>：表示切换到指定分支</p>
</blockquote>
<p>查看当前分支：</p>
<pre><code>git branch
</code></pre><blockquote>
<p>该命令会列出所有分支，当前分支前面会标一个*号</p>
</blockquote>
<p>合并branchname分支：</p>
<pre><code>git merge &lt;branchname&gt;
</code></pre><blockquote>
<p><code>git merge</code>命令用于合并指定分支到当前分支(当前git的工作分支，即最后一次<code>git checkout &lt;branchname&gt;</code>)。合并后被合并的分支和当前分支就一样了<br>默认情况下，是进行“快进模式”的合并，也就是直接把master（当前分支）指向dev(被合并的分支)的当前提交，所以合并速度非常快<br>Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用FF模式，可以增加<code>--no-ff</code>参数，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p>
</blockquote>
<p>删除branchname分支：</p>
<pre><code>git branch -d &lt;branchname&gt;
</code></pre><blockquote>
<p><code>-D</code>参数强行删除分支</p>
</blockquote>
<p>保存当前工作现场：</p>
<pre><code>git stash
</code></pre><p>查看保存的工作现场：</p>
<pre><code>git stash list
</code></pre><p>恢复现场：</p>
<pre><code>git stash pop
</code></pre><blockquote>
<p>该命令会在恢复的同时把stash内容也删了，等同于下面两个命令：</p>
<pre><code>git stash apply 恢复现场单并不删除stash内容
git stash drop 删除stash内容
</code></pre><p>可以多次stash,先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：<br>    git stash apply stash@{stash_id}</p>
</blockquote>
<h5 id="u5E38_u7528_u7684_u5404_u79CD_u573A_u666F_u5206_u652F_u547D_u4EE4_u64CD_u4F5C_u6D41_u7A0B"><a href="#u5E38_u7528_u7684_u5404_u79CD_u573A_u666F_u5206_u652F_u547D_u4EE4_u64CD_u4F5C_u6D41_u7A0B" class="headerlink" title="常用的各种场景分支命令操作流程"></a>常用的各种场景分支命令操作流程</h5><ol>
<li><p>创建dev分支，修改提交代码后再合并到master分支：</p>
<pre><code>git branch dev
git checkout dev 
(or git checkout -b dev)
modifty code in dev branch
git add
git commit

git checkout master
git merge dev 
git branch -d dev
</code></pre></li>
<li><p>master分支和dev分支各自都分别有各自的代码修改和新的提交,并有冲突:</p>
<pre><code>git branch dev
git checkout dev 
(or git checkout -b dev)
modify code in dev branch
git add
git commit

git master
modify code in master branch 
git add
git commit

git merge dev (master modify is conflict with dev modify)
</code></pre><p>产生冲突后,手动解决后，再在当前master上提交,并删除dev分支即可：</p>
<pre><code>git add 
git commit
git branch -d dev   
</code></pre><blockquote>
<p>使用<code>git log --graph</code>可以看到分支合并图</p>
</blockquote>
</li>
<li><p>修改dev分支时候，需要修改master分支上的bug,先保存现场，再修改bug,最后恢复现场:</p>
<pre><code>git stash

git checkout master
git checkout -b bug
modify code in bug branch
git add
git commit

git checkout master
git merge bug
git branch -d bug

git checkout dev
git stash pop
</code></pre></li>
</ol>
<h4 id="u6807_u7B7E_u7BA1_u7406"><a href="#u6807_u7B7E_u7BA1_u7406" class="headerlink" title="标签管理"></a>标签管理</h4><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照</p>
<h5 id="u521B_u5EFA_u6807_u7B7E"><a href="#u521B_u5EFA_u6807_u7B7E" class="headerlink" title="创建标签"></a>创建标签</h5><p>首先切换到需要打标签的分支上,输入下面命令即可：</p>
<pre><code>git tag [-a] &lt;tagname&gt; [-m] [commit_id]
</code></pre><blockquote>
<p><code>git tag &lt;tagname&gt;</code>命令默认标签是打在最新提交的commit上的,给历史提交打标签可以加上<code>commit_id</code>可选项，选择要打标签的commit id即可<br>还可以创建带有说明的标签，用<code>-a</code>可选参数指定标签名，<code>-m</code>可选参数指定说明文字<br>还可以通过<code>-s</code>可选参数用私钥签名一个标签<br>查看该分支下的所有标签：</p>
</blockquote>
<pre><code>git tag
</code></pre><p>查看标签信息：</p>
<pre><code>git show &lt;tagname&gt;
</code></pre><h5 id="u5220_u9664_u6807_u7B7E"><a href="#u5220_u9664_u6807_u7B7E" class="headerlink" title="删除标签"></a>删除标签</h5><p>创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除:</p>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre><h5 id="u8FDC_u7A0B_u6807_u7B7E"><a href="#u8FDC_u7A0B_u6807_u7B7E" class="headerlink" title="远程标签"></a>远程标签</h5><p>如果要把标签推送到远程可以用：</p>
<pre><code>git push origin &lt;tagname&gt;
</code></pre><p>也可以一次性推送所有的本地标签：</p>
<pre><code>git push origin --tags
</code></pre><p>如果要删除远程的标签，要分两步：<br>Step 1: 先从本地删除：</p>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre><p>Step 2: 从远程删除：</p>
<pre><code>git push origin :refs/tags/&lt;tagname&gt;
</code></pre><h3 id="u8FDC_u7A0B_u4ED3_u5E93_u7BA1_u7406"><a href="#u8FDC_u7A0B_u4ED3_u5E93_u7BA1_u7406" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h3><h4 id="u5173_u8054_u672C_u5730_u4ED3_u5E93_u5230_u8FDC_u7A0B_u4ED3_u5E93"><a href="#u5173_u8054_u672C_u5730_u4ED3_u5E93_u5230_u8FDC_u7A0B_u4ED3_u5E93" class="headerlink" title="关联本地仓库到远程仓库"></a>关联本地仓库到远程仓库</h4><ol>
<li><p>登陆GitHub,点击<code>Create a new repo</code>创建一个新的仓库,在本地仓库运行：</p>
<pre><code>git remote add origin git@server-name:path/repo-name.git
</code></pre><blockquote>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库</p>
</blockquote>
</li>
<li><p>推送本地库内容到新建的远程仓库</p>
<pre><code>git push -u origin master
</code></pre><blockquote>
<p>由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>
</blockquote>
</li>
<li>以后每次修改本地代码后，就可以将本地的master分支最新修改推送栋GitHub了：<pre><code>git push origin master
</code></pre></li>
</ol>
<h4 id="u4ECE_u8FDC_u7A0B_u4ED3_u5E93_u514B_u9686_u5230_u672C_u5730_u4ED3_u5E93"><a href="#u4ECE_u8FDC_u7A0B_u4ED3_u5E93_u514B_u9686_u5230_u672C_u5730_u4ED3_u5E93" class="headerlink" title="从远程仓库克隆到本地仓库"></a>从远程仓库克隆到本地仓库</h4><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin，克隆命令：</p>
<pre><code>git clone &lt;github_addrs&gt;
</code></pre><blockquote>
<p>Git支持多种协议，默认的git://使用ssh，通过ssh支持的原生git协议速度最快,但也可以使用https等其他协议，使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令</p>
</blockquote>
<h4 id="u4ECE_u8FDC_u7A0B_u83B7_u53D6_u6700_u65B0_u7248_u672C_u5230_u672C_u5730"><a href="#u4ECE_u8FDC_u7A0B_u83B7_u53D6_u6700_u65B0_u7248_u672C_u5230_u672C_u5730" class="headerlink" title="从远程获取最新版本到本地"></a>从远程获取最新版本到本地</h4><pre><code>git fetch
</code></pre><blockquote>
<p>从远程获取最新版本到本地，不会自动merge</p>
</blockquote>
<pre><code>git pull
</code></pre><blockquote>
<p>从远程获取最新版本并merge到本地, 其命令相当于：</p>
<pre><code>git fetch
git merge
</code></pre></blockquote>
<h4 id="u67E5_u770B_u8FDC_u7A0B_u5E93_u4FE1_u606F"><a href="#u67E5_u770B_u8FDC_u7A0B_u5E93_u4FE1_u606F" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h4><pre><code>git remote 
</code></pre><blockquote>
<p>想查看更详细的信息可以加上<code>-v</code>参数</p>
</blockquote>
<h4 id="u4F7F_u7528_u8FDC_u7A0B_u4ED3_u5E93_u7684_u4E00_u822C_u6D41_u7A0B"><a href="#u4F7F_u7528_u8FDC_u7A0B_u4ED3_u5E93_u7684_u4E00_u822C_u6D41_u7A0B" class="headerlink" title="使用远程仓库的一般流程"></a>使用远程仓库的一般流程</h4><ol>
<li>可以试图用<code>git push origin &lt;branchname&gt;</code>推送自己的修改</li>
<li>如果推送失败，则因为远程仓库分支比你的本地仓库更新，需要先用<code>git pull</code>试图合并<blockquote>
<p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream &lt;branchname&gt; origin/&lt;branchname&gt;</code></p>
</blockquote>
</li>
<li>如果合并有冲突，则解决冲突，并在本地提交</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branchname&gt;</code>推送就能成功</li>
</ol>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">liaoxuefeng</a><br><a href="http://selfcontroller.iteye.com/blog/1786644" target="_blank" rel="external">git 缓存区的理解</a><br><a href="http://gitref.org/index.html" target="_blank" rel="external">git reference</a><br><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">Pro Git book</a><br><a href="http://git.oschina.net/wzw/git-quick-start" target="_blank" rel="external">git-quick-start</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Git_u7B80_u4ECB"><a href="#Git_u7B80_u4ECB" class="headerlink" title="Git简介"></a>Git简介</h2><hr>
<p>Git 是一个免费的、分布式版本控制工具，或是一个强调了速度快的源代码管理工具<br>]]>
    
    </summary>
    
      <category term="Git" scheme="http://www.franktly.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://www.franktly.com/tags/GitHub/"/>
    
      <category term="SVN" scheme="http://www.franktly.com/tags/SVN/"/>
    
      <category term="版本管理" scheme="http://www.franktly.com/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
      <category term="Git" scheme="http://www.franktly.com/categories/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown进阶]]></title>
    <link href="http://www.franktly.com/2016/01/22/Markdown%E8%BF%9B%E9%98%B6/"/>
    <id>http://www.franktly.com/2016/01/22/Markdown进阶/</id>
    <published>2016-01-21T16:00:00.000Z</published>
    <updated>2016-01-22T15:46:39.871Z</updated>
    <content type="html"><![CDATA[<h2 id="Markdown_u5217_u8868_u5D4C_u5957"><a href="#Markdown_u5217_u8868_u5D4C_u5957" class="headerlink" title="Markdown列表嵌套"></a>Markdown列表嵌套</h2><p>Markdown列表(包括有序和无序列表）嵌套，可以通过缩进4个空格或1个Tab来实现：<br><a id="more"></a></p>
<pre><code>- China
    + Beijing
    + Shanghai
- Japan
    + Tokyo
- America
    + NewYork
    + Washington
</code></pre><p>效果：</p>
<ul>
<li>China<ul>
<li>Beijing</li>
<li>Shanghai</li>
</ul>
</li>
<li>Japan<ul>
<li>Tokyo</li>
</ul>
</li>
<li>America<ul>
<li>NewYork</li>
<li>Washington</li>
</ul>
</li>
</ul>
<h2 id="Markdown_u4EE3_u7801_u5D4C_u5165_u8FDE_u7EED3_u4E2A_60_u5B57_u7B26"><a href="#Markdown_u4EE3_u7801_u5D4C_u5165_u8FDE_u7EED3_u4E2A_60_u5B57_u7B26" class="headerlink" title="Markdown代码嵌入连续3个`字符"></a>Markdown代码嵌入连续3个`字符</h2><p>Markdown要想在代码里面保留三个`字符它的原始样子而不被转换成代码块(标准MD中没有)，可以增加4个或更多的` 来包裹：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="escape">``</span><span class="escape">``</span></span><br><span class="line"><span class="escape">``</span><span class="escape">`</span><br><span class="line"></span>void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Hello World!"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="escape">``</span><span class="escape">`</span><br><span class="line"></span><span class="escape">``</span><span class="escape">``</span></span><br></pre></td></tr></table></figure></p>
<p>效果：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`<span class="javascript"></span>``<span class="javascript"></span><br><span class="line"><span class="keyword">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span>``<span class="javascript"></span>`</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>对于连续N个`，需要N + 1 个`来进行包裹</p>
</blockquote>
<h2 id="Markdown_u9996_u884C_u7F29_u8FDB"><a href="#Markdown_u9996_u884C_u7F29_u8FDB" class="headerlink" title="Markdown首行缩进"></a>Markdown首行缩进</h2><p>写文章时，我们常常希望能够首行缩进，这时可以在段首加入<code>&amp;ensp;</code>来输入一个空格.加入<code>&amp;emsp;</code>来输入两个空格。<br>如：</p>
<pre><code>&gt; No Space In Line
&gt; &amp;emsp;Two Space In Line
&gt; &amp;emsp;&amp;emsp; Four Space In Line
&gt; &amp;ensp;One Space In Line
&gt; &amp;ensp;&amp;ensp; Two Space In Line
</code></pre><p>效果：</p>
<blockquote>
<p>No Space In Line<br>&emsp;Two Space In Line<br>&emsp;&emsp; Four Space In Line<br>&ensp;One Space In Line<br>&ensp;&ensp; Two Space In Line</p>
</blockquote>
<p>普通段落尽量不用空格或制表符来缩进，即使使用它们后得到的效果看似是对的</p>
<h2 id="Markdown_u811A_u6CE8"><a href="#Markdown_u811A_u6CE8" class="headerlink" title="Markdown脚注"></a>Markdown脚注</h2><p>Markdown脚注(标准MD中没有)的语法看起来是这样的：</p>
<pre><code>A[^A]
[^A]: 注释
</code></pre><p>如：</p>
<pre><code>Markdown[^Markdown]
[^Markdown]: Markdown 是一种轻量级的标记语言，以易读易写作为宗旨
GFM[^GFM]
[^GFM]: GFM全称为GitHub Flavored Markdown
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ffootn.PNG" alt="footn"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Markdown_u5217_u8868_u5D4C_u5957"><a href="#Markdown_u5217_u8868_u5D4C_u5957" class="headerlink" title="Markdown列表嵌套"></a>Markdown列表嵌套</h2><p>Markdown列表(包括有序和无序列表）嵌套，可以通过缩进4个空格或1个Tab来实现：<br>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://www.franktly.com/tags/markdown/"/>
    
      <category term="标记语言" scheme="http://www.franktly.com/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Markdown" scheme="http://www.franktly.com/categories/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GFM格式Markdown简介]]></title>
    <link href="http://www.franktly.com/2016/01/22/GFM%E6%A0%BC%E5%BC%8FMarkdown%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.franktly.com/2016/01/22/GFM格式Markdown简介/</id>
    <published>2016-01-21T16:00:00.000Z</published>
    <updated>2016-01-22T15:53:13.080Z</updated>
    <content type="html"><![CDATA[<h2 id="Markdown_u5404_u79CD_u6269_u5C55"><a href="#Markdown_u5404_u79CD_u6269_u5C55" class="headerlink" title="Markdown各种扩展"></a>Markdown各种扩展</h2><p>Markdown除了标准的语法格式外，还有各种格式的扩展<br><a id="more"></a></p>
<ul>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" target="_blank" rel="external">PHP Markdown Extra</a><ul>
<li>支持在html块元素中插入markdown语法</li>
<li>支持为一些元素添加id或class</li>
<li>支持将代码块用`或者<code>~</code>包起来，这样可以避免一些二义，还可以为代码块添加id或class</li>
<li>支持手写的表格</li>
<li>支持脚注引用</li>
</ul>
</li>
<li><a href="https://github.com/bhollis/maruku/blob/master/docs/markdown_syntax.md" target="_blank" rel="external">Maruku</a><br>是基于<strong>Ruby</strong>开发的解释器，具有以下特点：<ul>
<li>支持原生Markdown</li>
<li>支持所有PHP Markdown Extra的特性</li>
<li>支持新的元数据语法，实际上就是给元素添加属性的能力</li>
<li>支持公式格式输出<br>不过，该项目已经停止维护了</li>
</ul>
</li>
<li><a href="http://kramdown.gettalong.org/" target="_blank" rel="external">kramdown</a><br>同样是<strong>Ruby</strong>开发的解释器，kramdown吸取了Maruku几乎所有的特点，功能更为强大。其中有特点的功能有:<ul>
<li>引入EOB标记^作为块元素的分隔符</li>
<li>手写table的语法更加强大一些，支持table中的header和footer</li>
<li>还支持注释，以及在转化时配置一些转化选项</li>
<li>同样支持ALD(Attribute List Definitions属性列表定义)<br><a href="https://help.github.com/articles/migrating-your-pages-site-from-maruku/" target="_blank" rel="external">GitHub Page 推荐使用kramdown解释器</a></li>
</ul>
</li>
<li><a href="http://www.pell.portland.or.us/~orc/Code/discount/" target="_blank" rel="external">RDiscount</a><br>同样是<strong>Ruby</strong>开发的解释器，不过它是基于<a href="http://www.pell.portland.or.us/~orc/Code/discount/" target="_blank" rel="external">Discount</a>的语法移植的,以语法规则需要参考Discount。其语法支持几种上面没有提到过的特性:<ul>
<li>文本居中，即输出<code>&lt;center&gt;</code></li>
<li>图片大小定义<code>![dust mite](http://dust.mite =150x150)</code></li>
<li>输出alpha列表：<code>&lt;ol type=&#39;a&#39;&gt;&lt;/ol&gt;</code></li>
</ul>
</li>
<li><a href="https://github.com/vmg/redcarpet" target="_blank" rel="external">Redcarpet</a><br>Redcarpet是一个转化库，可以在标准Markdown的基础上，配置一些额外的功能:<ul>
<li>单词中间的_不处理</li>
<li>转化PHP-Markdown风格的手写表格</li>
<li>转化PHP-Markdown风格的带包含的代码块，也可禁用标准markdown的代码块语法自动link生成</li>
<li>删除线支持：<code>~~good~~</code></li>
<li>高亮标签<code>&lt;mark&gt;&lt;/mark&gt;</code>通过<code>==highlighted==</code>输出</li>
<li>引用标签<code>&lt;q&gt;&lt;/q&gt;</code>通过<code>&quot;quote&quot;</code>输出</li>
<li>转化PHP-Markdown风格脚注</li>
<li>一些二义性的约束支持</li>
</ul>
</li>
<li><a href="https://help.github.com/articles/writing-on-github/" target="_blank" rel="external">GitHub</a><br><strong>Github Page对于上述的基于<em>Ruby</em>的markdown都是支持的</strong>，从<a href="https://pages.github.com/versions/" target="_blank" rel="external">这里</a>可以看到。另外，Github对于Issue、comments等，还定义了GFM(<a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="external">GitHub Flavored Markdown</a>)，其中的语法一般基本来源于上面的提到的东西。除此之外，github还支持一些额外的特性：<ul>
<li>支持把列表变成带勾选框的任务列表</li>
<li>站内对分支、问题、用户等对象的直接引用</li>
<li><a href="http://www.emoji-cheat-sheet.com/" target="_blank" rel="external">表情</a></li>
</ul>
</li>
</ul>
<h2 id="GFM_Markdown"><a href="#GFM_Markdown" class="headerlink" title="GFM Markdown"></a>GFM Markdown</h2><hr>
<p>GitHub 使用的是“GitHub Flavored Markdown”，简称GFM，有site-in issues,comments,pull requests等功能，它与标准的Markdown有一些区别，并增加了些新的扩展功能，区别如下：</p>
<h3 id="u5355_u8BCD_u5185_u591A_u4E0B_u5212_u7EBF"><a href="#u5355_u8BCD_u5185_u591A_u4E0B_u5212_u7EBF" class="headerlink" title="单词内多下划线"></a>单词内多下划线</h3><p>标准的Markdown转换<code>_</code>成斜体，GFM忽略了单词内部的<code>_</code>，如：</p>
<pre><code>hi_great_world
do_this_and_do_other
</code></pre><p>效果：<br>hi_great_world<br>do_this_and_do_other</p>
<blockquote>
<p>这个特性允许代码里和名字里含有多个<code>_</code>的单词能够正确的解释，如果强调一个单词可以使用<code>*</code></p>
</blockquote>
<h3 id="URL_u81EA_u52A8_u94FE_u63A5"><a href="#URL_u81EA_u52A8_u94FE_u63A5" class="headerlink" title="URL自动链接"></a>URL自动链接</h3><p>标准Markdown使用<code>&lt;</code>URL<code>&gt;</code>来支持自动链接；GFM会自动链接标准的URLs，如果你想链接到一个URL(而不是设置链接文本)，你可以简单的输入一个URL地址，GFM会自动转换成一个URL链接，如:</p>
<pre><code>http://www.franktly.com
</code></pre><p>效果：<br><a href="http://www.franktly.com">http://www.franktly.com</a></p>
<h3 id="u5220_u9664_u7EBF"><a href="#u5220_u9664_u7EBF" class="headerlink" title="删除线"></a>删除线</h3><p>GFM增加了标准Markdown中没有的删除线的语法，使用两个<code>~</code>表示，如：</p>
<pre><code>~~wrong text.~~
</code></pre><p>效果：<br><del>wrong text.</del></p>
<h3 id="u6805_u680F_u5F0F_u7684_u4EE3_u7801_u5757"><a href="#u6805_u680F_u5F0F_u7684_u4EE3_u7801_u5757" class="headerlink" title="栅栏式的代码块"></a>栅栏式的代码块</h3><p>标准的Markdown把每行的开始带有4个空格或一个Tab的文本转换为代码块；GFM除了此，还支持<br>栅栏式代码块，仅仅需要把你的代码你用三个`包裹起来即可，不需要通过4个空格来区分了，如：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`<span class="javascript"></span>``<span class="javascript"></span><br><span class="line"><span class="keyword">void</span> hello()</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span>``<span class="javascript"></span>`</span><br></pre></td></tr></table></figure></p>
<p>效果(栅栏式代码块自动加了默认的高亮)：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    print(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>尽管栅栏式代码块并不需要在前面增加一个空行（不像缩进式代码块），GFM建议最好加上一个空行，这样方便原始的Markdown更容易阅读<br>在列表里面，你必须使用8个空格来表示一个非栅栏式的代码块</p>
</blockquote>
<h3 id="u8BED_u6CD5_u9AD8_u4EAE"><a href="#u8BED_u6CD5_u9AD8_u4EAE" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>代码块通过加语法高亮更容易阅读，在栅栏式代码块基础之上，增加一个可选的语言标字符(如 ruby,C,C++,pyhon等等)，GFM通过此种方式来进行代码语法高亮，如以下Ruby代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```ruby</span><br><span class="line">require <span class="string">'redcarpet'</span></span><br><span class="line">markdown = Redcarpet.<span class="function"><span class="title">new</span><span class="params">(<span class="string">"Hello World!"</span>)</span></span></span><br><span class="line">puts markdown<span class="class">.to_html</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure></p>
<p>效果：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'redcarpet'</span></span><br><span class="line">markdown = <span class="constant">Redcarpet</span>.new(<span class="string">"Hello World!"</span>)</span><br><span class="line">puts markdown.to_html</span><br></pre></td></tr></table></figure></p>
<p>而没加高亮是这样的(标准Markdown换行加空四格)：</p>
<pre><code>require &apos;redcarpet&apos;
markdown = Redcarpet.new(&quot;Hello World!&quot;)
puts markdown.to_html
</code></pre><blockquote>
<p>GFM使用<a href="https://github.com/github/linguist" target="_blank" rel="external">Linguist</a>来检测语言进行语法高亮，可以参阅<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml" target="_blank" rel="external">YAML file</a>来确定哪些关键字的语言被支持</p>
</blockquote>
<h3 id="u8868_u683C"><a href="#u8868_u683C" class="headerlink" title="表格"></a>表格</h3><p>1)GFM在标准的Markdown语法基础上增加了表格，可以通过组合一系列单词通过连字符<code>-</code>（仅在第一行上使用）分隔第一行，通过<code>|</code>来分隔表格的每一列即可，如：</p>
<pre><code>First Header | Second Header
-------------| -------------
Content Cell | Content Cell 
Content Cell | Content Cell  
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ftable-1.PNG" alt="table-1"><br>2)为了好看，可以在最后一列增加<code>|</code>:</p>
<pre><code>First Header | Second Header |
-------------| ------------- |
Content Cell | Content Cell  |
Content Cell | Content Cell  | 
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ftable-2.PNG" alt="table-2"><br>3)表头开始的破折号并不需要一定要匹配Header文本的长度(匹配的目的也是为了格式美观):</p>
<pre><code>Name | Description           |
-------------| ------------- |
Open   | Open Door |
Close  | Close Door | 
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ftable-3.PNG" alt="table-3"><br>4)通过在第一个行的<code>-</code>序列中增加<code>:</code>可以格式化文本的对齐方式，如<code>:</code>位于<code>-</code>序列左边表示文本左对齐，两边都有表示文本中间对齐，位于右边则表示右对齐，如：</p>
<pre><code>| Left Aligned | Center Aligned | Right Aligned |
|:------------ |:--------------:| -------------:|
| c11          | c12            | c13           |
| c21          | c22            | c23           | 
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Ftable-4.PNG" alt="table-4"></p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>可以在GitHub的READMEs，issues和requests中使用HTML的子集，支持的标签和属性可以参考<a href="https://github.com/github/markup" target="_blank" rel="external">github/markup repository</a></p>
<h3 id="GFM_u6362_u884C"><a href="#GFM_u6362_u884C" class="headerlink" title="GFM换行"></a>GFM换行</h3><p>标准Markdown要在一行的最后加两个空格符才表示换行，否则是不换行的；但是GFM则没有此要求</p>
<pre><code>第一行(最后无两个空格)
第二行
</code></pre><h3 id="u4EFB_u52A1_u5217_u8868"><a href="#u4EFB_u52A1_u5217_u8868" class="headerlink" title="任务列表"></a>任务列表</h3><p>GFM支持将列表变为<a href="https://github.com/blog/1375%0A-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="external">任务列表</a>，通过在列表的前面增加 <code>[ ]</code>或<code>[x]</code>(分别代码未完成和完成)，如：</p>
<pre><code>+ [ ] a task list item
+ [ ] list syntax required
+ [ ] normal **formatting**,@emontions, #1232 refs
+ [ ] incomplete
+ [x] completed
</code></pre><p>看到的结果是checkboxes 列表，可以修改Markdown文本，可以Check或者Uncheck Boxes,文本会自动更新，像是这样的：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fgfm-tasklist.gif" alt="GFM Task List"><br>任务列表可以嵌套任务的深度,GFM建议最多嵌套1到2层，如：</p>
<pre><code>+ [ ] a bigger project
  + [ ] first subtask #1
  + [ ] second subtask #2
+ [x] a small project
  + [x] first substask #3
</code></pre><h3 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h3><p>特定的引用会自动被链接，如：</p>
<pre><code>- SHA: a5c3785ed8d6a35868bc169f07e40e889087fd2e
- User@SHA: jlord@a5c3785ed8d6a35868bc169f07e40e889087fd2e
- User/Repository@SHA: jlord/sheetsee.js@a5c3785ed8d6a35868bc169f07e40e889087fd2e
- #Num: #26
- GH-Num: GH-26
- User#Num: jlord#26
- User/Repository#Num: jlord/sheetsee.js#26
</code></pre><h3 id="u7279_u6027"><a href="#u7279_u6027" class="headerlink" title="特性"></a>特性</h3><ul>
<li>快速引用(<code>r</code>)</li>
<li>@mentions自动生成名字和组(<code>@</code>)</li>
<li>Emoji自动生成表情(<code>:</code>)</li>
<li>Issue自动生成(<code>#</code>)</li>
</ul>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.pchou.info/open-source/2014/07/07/something-about-markdown.html" target="_blank" rel="external">Markdown的各种扩展</a><br><a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="external">GitHub Flavored Markdown</a><br><a href="https://help.github.com/articles/markdown-basics/" target="_blank" rel="external">Markdown Basics</a><br><a href="https://help.github.com/articles/writing-on-github/" target="_blank" rel="external">Writing on GitHub</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Markdown_u5404_u79CD_u6269_u5C55"><a href="#Markdown_u5404_u79CD_u6269_u5C55" class="headerlink" title="Markdown各种扩展"></a>Markdown各种扩展</h2><p>Markdown除了标准的语法格式外，还有各种格式的扩展<br>]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://www.franktly.com/tags/GitHub/"/>
    
      <category term="Markdown" scheme="http://www.franktly.com/tags/Markdown/"/>
    
      <category term="标记语言" scheme="http://www.franktly.com/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Markdown" scheme="http://www.franktly.com/categories/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown使用介绍]]></title>
    <link href="http://www.franktly.com/2016/01/21/Markdown%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://www.franktly.com/2016/01/21/Markdown使用介绍/</id>
    <published>2016-01-20T16:00:00.000Z</published>
    <updated>2016-01-22T13:49:08.481Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Markdown 是一个从文本到HTML的转换工具，通过简单的易读易写的文本格式生成结构化的HTML文档，是一种用来写作的轻量级<strong>标记语言</strong>，它使得我们能够专心于码字，而用<strong>标记</strong>语法来代替常见的排版格式，Markdown可以支持导出HTML格式的网页形式，也可以很方便的导出PDF格式</p>
<a id="more"></a>
<h2 id="Markdown__u4ECB_u7ECD"><a href="#Markdown__u4ECB_u7ECD" class="headerlink" title="Markdown 介绍"></a>Markdown 介绍</h2><hr>
<p>Markdown的目标是<em>易读易写</em>，具有以下优点：</p>
<ul>
<li>兼容HTML，Markdown作为轻量级的标记语言，其初衷不是想取代HTML，而是让文档更容易读、写和随意更改，HTML是一种发布的格式，而Markdown是一种书写的格式。Markdown 的格式语法只涵盖纯文本可以涵盖的范围，不在Markdown涵盖范围之内的标签，都可以直接在文档里面用 HTML撰写，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了</li>
<li>专注你的文字内容而不是排版样式，安心写作</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件</li>
<li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱</li>
<li>可读、直观、学习成本低</li>
</ul>
<h2 id="Markdown__u8BED_u6CD5_uFF08Standard_uFF09"><a href="#Markdown__u8BED_u6CD5_uFF08Standard_uFF09" class="headerlink" title="Markdown 语法（Standard）"></a>Markdown 语法（<a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Standard</a>）</h2><hr>
<h3 id="Markdown_u672F_u8BED"><a href="#Markdown_u672F_u8BED" class="headerlink" title="Markdown术语"></a>Markdown术语</h3><h4 id="Markdown__u6BB5_u843D"><a href="#Markdown__u6BB5_u843D" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h4><p>一个 Markdown <strong>段落</strong>是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<blockquote>
<p>[由一个或多个连续的文本行组]成这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），如果你确实想要依赖 Markdown 来插入 <code>&lt;br/&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车<br>需要多费点事（多加空格然后回车）来产生<code>&lt;br/&gt;</code>，但是简单地[每个换行都转换为 <code>&lt;br/&gt;</code>]的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读</p>
</blockquote>
<h3 id="Markdown_u533A_u5757_u5143_u7D20"><a href="#Markdown_u533A_u5757_u5143_u7D20" class="headerlink" title="Markdown区块元素"></a>Markdown区块元素</h3><h4 id="u6807_u9898"><a href="#u6807_u9898" class="headerlink" title="标题"></a>标题</h4><p>Markdown支持两种标题的语法，类 Setext 和类 atx 形式:<br>类 Setext 形式是用底线的形式，利用 <code>=</code>（最高阶标题）和<code>-</code> （第二阶标题），例如:</p>
<pre><code>This is H1
=============
This is H2
-------------
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fset-h1.PNG" alt="setext-h1"></p>
<blockquote>
<p>任何数量的 = 和 - 都可以有效果</p>
</blockquote>
<p>类 Atx 形式则是在行首插入 1 到 6 个<code>#</code>，对应到标题 1 到 6 阶，例如:</p>
<pre><code># This is H1
## This is H2
### This is H3
#### This is H4
##### This is H5
###### This is H6
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fatx-h1.PNG" alt="atx-h1"></p>
<p>可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上<code>#</code>，而行尾的<code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）</p>
<pre><code># This is H1 #
## This is H2 ##
### This is H3 ###
#### This is H4 ####
##### This is H5 #####
###### This is H6 ######
</code></pre><p>效果:<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fatx-h2.PNG" alt="atx-h2"></p>
<h4 id="u5F15_u7528"><a href="#u5F15_u7528" class="headerlink" title="引用"></a>引用</h4><p>Markdown 标记区块引用是使用类似 email 中用<code>&gt;</code>的引用方式，如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown文件中建立一个区块引用<br>1) Markdown区块看起来像是你自己先断好行，然后在每行的最前面加上<code>&gt;</code>：</p>
<pre><code>&gt; This is Paragraph 1 Line 1,
&gt; This is Paragraph 1 Line 2,
&gt;
&gt; This is Paragraph 2 Line 1,
&gt; This is Paragraph 2 Line 2,
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fquto-1.PNG" alt="quot-1"> </p>
<p>2) Markdown也允许你偷懒只在整个段落的第一行最前面加上<code>&gt;</code>：</p>
<pre><code>&gt; This is Paragraph 1 Line 1,
This is Paragraph 1 Line 2,

&gt; This is Paragraph 2 Line 1,
This is Paragraph 2 Line 2,
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fquto-2.PNG" alt="quot-2"> </p>
<p>3) Markdown区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的<code>&gt;</code>:</p>
<pre><code>&gt; This is Paragrah 1 Line 1 Depth 1
&gt;&gt;This is Paragraph 1 Line 2 Depth 2
&gt; This is Pargaraph 1 Line 3 Depth 2
&gt; 
&gt; This is Paragrah 2 Line 1 Depth 1
&gt;&gt;This is Paragraph 2 Line 2 Depth 2
&gt; This is Pargaraph 2 Line 3 Depth 2
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fquto-3.PNG" alt="quot-3"> </p>
<p>4) Markdown引用的区块内也可以使用其他的Markdown语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; ## This is A title
&gt; 1. This is List 1
&gt; 2. This is List 2
&gt; `cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;`
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fquto-4.PNG" alt="quot-4"> </p>
<h4 id="u5217_u8868"><a href="#u5217_u8868" class="headerlink" title="列表"></a>列表</h4><p>Markdown支持有序和无序列表<br>1) 无序列表使用<code>*</code>、<code>+</code>、<code>-</code>作为列表标记</p>
<pre><code>- China
- Japan
- Korea
</code></pre><p>效果:<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Funlist-1.PNG" alt="unlist-1"><br>等同于：</p>
<pre><code>* China
* Japan
* Korea
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Funlist-1.PNG" alt="unlist-1"><br>也等同于：</p>
<pre><code>+ China
+ Japan
+ Korea
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Funlist-1.PNG" alt="unlist-1"></p>
<p>2) 有序列表使用数字接着一个英文句点：</p>
<pre><code>1. China
2. Japan
3. Korea
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flist-1.PNG" alt="list-1"></p>
<p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的HTML结果</p>
<p>1) 如果列表项目间用空行分开，在输出HTML时Markdown就会将项目内容用<code>&lt;p&gt;</code>标签包起来，举例来说: </p>
<pre><code>- China
- Japan
- Korea
</code></pre><p>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;China&lt;/li&gt;
&lt;li&gt;Japan&lt;/li&gt;
&lt;li&gt;Korea&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>但是这个如果有空行：</p>
<pre><code>- China

- Japan

- Korea
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Funlist-2.PNG" alt="unlist-2"><br>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;China&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Japan&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Korea&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>2) 列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符：</p>
<pre><code>1.  This is p1
    This is p1 and 4 space or 1 tab draw back
2.  This is p2
    This is p2 and 4 space or 1 tab draw back
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flist-2.PNG" alt="list-2"></p>
<p>3) 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</p>
<pre><code>1.  This is p1 code
        Hello World 1
2.  This is p2
        Hello World 2
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flist-3.PNG" alt="list-3"></p>
<p>4) 如果在行首出现数字句点空白，要避免这样的状况与有序列表格式冲突，你可以在句点前面加上反斜杠转义：</p>
<pre><code>1988\. This is a great year
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flist-4.PNG" alt="list-4"></p>
<h4 id="u4EE3_u7801_u533A_u5757"><a href="#u4EE3_u7801_u533A_u5757" class="headerlink" title="代码区块"></a>代码区块</h4><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来</p>
<p>1) 要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>This is a paragragh
// !此处加空行
    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fcode-1.PNG" alt="code-1"><br>Markdown 会转换成：</p>
<pre><code>&lt;p&gt; This is a paragraph&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here is a Expample of Python:
// !此处加空行
    def showhello:
        print(&quot;Hello World&quot;)
        print(&quot;How are you&quot;)
This is a normal paragraph
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fcode-2.PNG" alt="code-2"></p>
<blockquote>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
</blockquote>
<p>2) 在代码区块里面，<code>&amp;</code> 、<code>&lt;</code> 和 <code>&gt;</code>会自动转成 HTML 实体<code>&amp;amp</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
  &amp;copy; Markdown Corporation
&lt;/div&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; Markdown Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>3) 代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件</p>
<h4 id="u5206_u9694_u7EBF"><a href="#u5206_u9694_u7EBF" class="headerlink" title="分隔线"></a>分隔线</h4><p>你可以在一行中用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>***
- * * *
----
_ _ _ _
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fdiv.PNG" alt="div"></p>
<h3 id="Markdown_u533A_u6BB5_u5143_u7D20"><a href="#Markdown_u533A_u6BB5_u5143_u7D20" class="headerlink" title="Markdown区段元素"></a>Markdown区段元素</h3><hr>
<h4 id="u94FE_u63A5"><a href="#u94FE_u63A5" class="headerlink" title="链接"></a>链接</h4><h5 id="u6587_u5B57_u94FE_u63A5"><a href="#u6587_u5B57_u94FE_u63A5" class="headerlink" title="文字链接"></a>文字链接</h5><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式<br>不管是哪一种，链接文字都是用 [方括号] 来标记</p>
<p>1) 要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [My Blog](http://www.franktly.com/ &quot;frank&quot;) inline link.
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flinktxt-1.PNG" alt="linktxt-1"></p>
<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [About](/about/) page for details.
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flinktxt-2.PNG" alt="linktxt-2"></p>
<p>2) 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [My Blog][id] reference link
[id]: http://www.franktly.com/ &quot;frank&quot;
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flinktxt-3.PNG" alt="linktxt-3"></p>
<blockquote>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<strong>不区分</strong>大小写</p>
</blockquote>
<p><strong>隐式链接标记</strong>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号<br>链接内容定义的形式为：</p>
<pre><code>[My Blog][]
[My Blog]: http://www.franktly.com &quot;frank&quot;
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Flinktxt-4.PNG" alt="linktxt-4"></p>
<blockquote>
<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
</blockquote>
<p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<h5 id="u56FE_u7247_u94FE_u63A5"><a href="#u56FE_u7247_u94FE_u63A5" class="headerlink" title="图片链接"></a>图片链接</h5><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>
<p>1) 行内式的图片语法看起来像是：</p>
<pre><code>![Alt text](/path/to/img.jpg)
![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre><blockquote>
<ul>
<li>一个惊叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
</blockquote>
<p>2) 参考式的图片语法则长得像这样：</p>
<pre><code>![Alt text][id]
[id]: /path/to/img.jpg &quot;Optional title&quot;
</code></pre><h4 id="u659C_u4F53_u4E0E_u52A0_u5F3A"><a href="#u659C_u4F53_u4E0E_u52A0_u5F3A" class="headerlink" title="斜体与加强"></a>斜体与加强</h4><p>Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围表示斜体，用两个 * 或 _ 包起来的话，则会被转成 <code>&lt;strong&gt;</code>表示变粗加强，例如:</p>
<pre><code>*Single Strong*
**Double Strong**
_Single Strong_
__Double Strong__
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fstrong.PNG" alt="strong"></p>
<h4 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h4><p>1) 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：</p>
<pre><code>Program Begin With `main()` function
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fcodeinner-1.PNG" alt="codeinner-1"><br>会被转换成这样：</p>
<pre><code>&lt;p&gt;&lt;code&gt;Program Begin With `main()` function&lt;/code&gt;&lt;/p&gt;
</code></pre><p>2) 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code>``This is a Literal Backtick ` Here``
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fcodeinner-2.PNG" alt="codeinner-2"></p>
<h3 id="u5176_u4ED6"><a href="#u5176_u4ED6" class="headerlink" title="其他"></a>其他</h3><h4 id="u53CD_u659C_u6760"><a href="#u53CD_u659C_u6760" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号进行转义，真实的表示该符号，而不进行标签替换处理</p>
<pre><code>\* This is incluced By (\*) \*
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fconvert.PNG" alt="convert"></p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
-   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
*   加号
+   减号
.   英文句点
!   惊叹号
</code></pre><h4 id="u81EA_u52A8_u94FE_u63A5"><a href="#u81EA_u52A8_u94FE_u63A5" class="headerlink" title="自动链接"></a>自动链接</h4><p>Markdown支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://www.franktly.com&gt;
</code></pre><p>效果：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fautolink.PNG" alt="autolink"><br>被转化为：</p>
<pre><code>&lt;a href=&quot;http://www.franktly.com&quot;&gt;http://www.franktly.com&lt;/a&gt;
</code></pre><p>邮址的自动链接也很类似</p>
<h2 id="Markdown__u514D_u8D39_u7F16_u8F91_u5668"><a href="#Markdown__u514D_u8D39_u7F16_u8F91_u5668" class="headerlink" title="Markdown 免费编辑器"></a>Markdown 免费编辑器</h2><hr>
<p>Windows：</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></li>
<li><a href="http://markpad.fluid.impa.br/" target="_blank" rel="external">MarkPad</a></li>
<li><a href="https://atom.io/" target="_blank" rel="external">GitHub Atom</a></li>
</ul>
<p>Linux:</p>
<ul>
<li><a href="http://www.oschina.net/p/retext" target="_blank" rel="external">ReText</a></li>
</ul>
<p>Mac:</p>
<ul>
<li><a href="http://25.io/mou/" target="_blank" rel="external">Mou</a></li>
</ul>
<p>网页在线：</p>
<ul>
<li><a href="https://markable.in/" target="_blank" rel="external">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">Dillinger.io</a></li>
<li><a href="http://mahua.jser.me/" target="_blank" rel="external">MaHua</a></li>
</ul>
<p>高级：Sublime Text 3 + MarkdownPre + MarkdownEditing</p>
<ul>
<li>Sublime Text 3</li>
</ul>
<h2 id="Markdown_u9879_u76EE_u4E3B_u9875"><a href="#Markdown_u9879_u76EE_u4E3B_u9875" class="headerlink" title="Markdown项目主页"></a>Markdown项目主页</h2><p><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Markdown Project</a></p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.markdown.cn/" target="_blank" rel="external">http://www.markdown.cn</a><br><a href="http://wowubuntu.com/markdown/index.html" target="_blank" rel="external">http://wowubuntu.com/markdown</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Markdown 是一个从文本到HTML的转换工具，通过简单的易读易写的文本格式生成结构化的HTML文档，是一种用来写作的轻量级<strong>标记语言</strong>，它使得我们能够专心于码字，而用<strong>标记</strong>语法来代替常见的排版格式，Markdown可以支持导出HTML格式的网页形式，也可以很方便的导出PDF格式</p>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://www.franktly.com/tags/markdown/"/>
    
      <category term="标记语言" scheme="http://www.franktly.com/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
      <category term="Markdown" scheme="http://www.franktly.com/categories/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客(3)]]></title>
    <link href="http://www.franktly.com/2016/01/10/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-3/"/>
    <id>http://www.franktly.com/2016/01/10/使用Hexo搭建个人博客-3/</id>
    <published>2016-01-09T16:00:00.000Z</published>
    <updated>2016-01-22T13:49:32.003Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇简单介绍了Hexo搭建的静态博客部署到GitHub服务器上，并关联了自己申请的域名，Hexo默认的主题是landscape,如果想选用其他的主题，可以在GitHub上搜索hexo themes,GitHub上Hexo主题Star比较多的有下面几个：</p>
<ul>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT</a></li>
<li><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">Casper</a></li>
<li><a href="https://github.com/daleanthony/uno" target="_blank" rel="external">Uno</a></li>
<li><a href="https://github.com/orderedlist/modernist" target="_blank" rel="external">Modernist</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">Yilia</a></li>
<li><a href="https://github.com/A-limon/pacman" target="_blank" rel="external">Pacman</a></li>
<li>…</li>
</ul>
<p>本篇以Star最多的（也是本人使用的）Next主题为例，简要的介绍Next主题在Hexo中的使用方法</p>
<a id="more"></a>
<h2 id="NexT_u7B80_u4ECB"><a href="#NexT_u7B80_u4ECB" class="headerlink" title="NexT简介"></a>NexT简介</h2><hr>
<p>NexT是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">iissnan</a>设计的一款简单又不失优雅的主题,正如NexT的开发宗旨：<br><strong> NexT is built for easily use with elegant appearance. First things first, always keep things simple.</strong></p>
<h2 id="u5E94_u7528Next"><a href="#u5E94_u7528Next" class="headerlink" title="应用Next"></a>应用Next</h2><hr>
<h3 id="u4E0B_u8F7DNexT_u4E3B_u9898"><a href="#u4E0B_u8F7DNexT_u4E3B_u9898" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h3><p>在Hexo博客的目录打开Shell终端，输入下面命令即可：</p>
<pre><code>$ cd your_hexo_dir
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><h3 id="u542F_u7528NexT_u4E3B_u9898"><a href="#u542F_u7528NexT_u4E3B_u9898" class="headerlink" title="启用NexT主题"></a>启用NexT主题</h3><p>打开Hexo博客站点配置文件，把theme 字段的值改为next</p>
<h3 id="u9A8C_u8BC1_u662F_u5426_u542F_u7528"><a href="#u9A8C_u8BC1_u662F_u5426_u542F_u7528" class="headerlink" title="验证是否启用"></a>验证是否启用</h3><p>打开Shell终端，输入：</p>
<pre><code>$ hexo server --debug
</code></pre><p>并访问<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>即可查看主题是否启用</p>
<h3 id="Next_u914D_u7F6E"><a href="#Next_u914D_u7F6E" class="headerlink" title="Next配置"></a>Next配置</h3><p>NexT的官方使用手册上有比较详细的配置使用教程，见<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT使用指南</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇简单介绍了Hexo搭建的静态博客部署到GitHub服务器上，并关联了自己申请的域名，Hexo默认的主题是landscape,如果想选用其他的主题，可以在GitHub上搜索hexo themes,GitHub上Hexo主题Star比较多的有下面几个：</p>
<ul>
<li><a href="http://theme-next.iissnan.com/">NexT</a></li>
<li><a href="http://theme-next.iissnan.com/">Casper</a></li>
<li><a href="https://github.com/daleanthony/uno">Uno</a></li>
<li><a href="https://github.com/orderedlist/modernist">Modernist</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia">Yilia</a></li>
<li><a href="https://github.com/A-limon/pacman">Pacman</a></li>
<li>…</li>
</ul>
<p>本篇以Star最多的（也是本人使用的）Next主题为例，简要的介绍Next主题在Hexo中的使用方法</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://www.franktly.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://www.franktly.com/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://www.franktly.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://www.franktly.com/tags/Next/"/>
    
      <category term="Node.js" scheme="http://www.franktly.com/tags/Node-js/"/>
    
      <category term="博客" scheme="http://www.franktly.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客搭建" scheme="http://www.franktly.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客(2)]]></title>
    <link href="http://www.franktly.com/2016/01/09/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/"/>
    <id>http://www.franktly.com/2016/01/09/使用Hexo搭建个人博客-2/</id>
    <published>2016-01-08T16:00:00.000Z</published>
    <updated>2016-01-22T13:48:58.630Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇介绍了使用Hexo在本地搭建的过程，本篇将本地搭建的博客网站部署到服务器去，常见的服务器有:</p>
<ul>
<li><a href="https://github.com/" target="_blank" rel="external">GitHub</a></li>
<li><a href="https://www.heroku.com/" target="_blank" rel="external">Heroku</a></li>
<li>…</li>
</ul>
<p>本文选用使用比较多的GitHub作为目标服务器</p>
<a id="more"></a>
<h2 id="GitHub_u7B80_u4ECB"><a href="#GitHub_u7B80_u4ECB" class="headerlink" title="GitHub简介"></a>GitHub简介</h2><hr>
<p><a href="https://github.com/" target="_blank" rel="external">GitHub</a>是Git工具的远程库，托管各种Git库，并提供Web界面。GitHub为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并，GitHub是软件开发人员的Facebook</p>
<h2 id="GitHub_u6CE8_u518C"><a href="#GitHub_u6CE8_u518C" class="headerlink" title="GitHub注册"></a>GitHub注册</h2><hr>
<blockquote>
<p>已有账户的忽略此步</p>
</blockquote>
<h3 id="u6CE8_u518CGitHub_u8D26_u53F7"><a href="#u6CE8_u518CGitHub_u8D26_u53F7" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><h3 id="u5EFA_u7ACBGitHub_Pages"><a href="#u5EFA_u7ACBGitHub_Pages" class="headerlink" title="建立GitHub Pages"></a>建立GitHub Pages</h3><p>对于<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages</a>分两种：</p>
<ul>
<li>用户&amp;组织页：根据GitHub用户名建立的<code>username.github.io</code>的repository,如笔者的仓库名为<code>franktly.github.io</code>,此时网页使用的是该仓库的master分支</li>
<li>项目页: 比前者稍微麻烦些，需要在新的或已有的repository上新建一个gh-pages分支，具体方法见<a href="https://pages.github.com/" target="_blank" rel="external">GitHub Pages 官网</a></li>
</ul>
<p>这次我们选择第一种<strong>用户&amp;组织页</strong>类型的GitHub Pages</p>
<h3 id="u8BBE_u7F6EGitHub_SSH_Key"><a href="#u8BBE_u7F6EGitHub_SSH_Key" class="headerlink" title="设置GitHub SSH Key"></a>设置GitHub SSH Key</h3><h4 id="u672C_u5730_u8BBE_u7F6Egit_u90AE_u7BB1_u3001_u7528_u6237_u540D_u548C_u5BC6_u7801"><a href="#u672C_u5730_u8BBE_u7F6Egit_u90AE_u7BB1_u3001_u7528_u6237_u540D_u548C_u5BC6_u7801" class="headerlink" title="本地设置git邮箱、用户名和密码"></a>本地设置git邮箱、用户名和密码</h4><pre><code>git config --global user.email &quot;your_email_addr&quot;
git config --global user.name  &quot;user_name&quot;
</code></pre><h4 id="u672C_u5730_u521B_u5EFASSH_Key"><a href="#u672C_u5730_u521B_u5EFASSH_Key" class="headerlink" title="本地创建SSH Key"></a>本地创建SSH Key</h4><pre><code>ssh-keygen -t rsa -C &quot;your_email@your_email.com&quot;
</code></pre><blockquote>
<p>首先打开用户根目录（用户根目录一般为为C:\Users\username）查看是否已经有了SSH Key的文件夹<code>.ssh</code>,若有了先备份下，</p>
</blockquote>
<h4 id="u6DFB_u52A0_u751F_u6210_u7684SSH_Key_u5230GitHub_u8D26_u6237"><a href="#u6DFB_u52A0_u751F_u6210_u7684SSH_Key_u5230GitHub_u8D26_u6237" class="headerlink" title="添加生成的SSH Key到GitHub账户"></a>添加生成的SSH Key到GitHub账户</h4><p>打开在当前用户的根目录下生成的<code>.ssh</code>文件里面的ssh.pub（ssh 公钥）,拷贝其内容到[Account setting -&gt; SSH Keys -&gt; Add SSH Key]</p>
<h4 id="u9A8C_u8BC1_u4E0BSSH_u662F_u5426_u8BBE_u7F6E_u6210_u529F"><a href="#u9A8C_u8BC1_u4E0BSSH_u662F_u5426_u8BBE_u7F6E_u6210_u529F" class="headerlink" title="验证下SSH是否设置成功"></a>验证下SSH是否设置成功</h4><pre><code>ssh -T git@github.com
</code></pre><p>第一次提示不能连接，直接输入yes即可</p>
<p><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FSSH-Key.PNG" alt="SSH_SET"></p>
<h2 id="GitHub_u90E8_u7F72"><a href="#GitHub_u90E8_u7F72" class="headerlink" title="GitHub部署"></a>GitHub部署</h2><hr>
<p>建立GitHub Pages之后，即可以将本地搭建的Hexo网站部署到GitHub上去</p>
<h3 id="u4FEE_u6539_u7AD9_u70B9_config-yml_u914D_u7F6E_u6587_u4EF6"><a href="#u4FEE_u6539_u7AD9_u70B9_config-yml_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="修改站点_config.yml配置文件"></a>修改站点_config.yml配置文件</h3><p>如下面所示：类型配置为git，仓库地址为建立的GitHub Pages仓库地址，分支为master</p>
<pre><code>deploy:
type: git
repo: https://github.com/username/username.github.io.git
branch: master
</code></pre><h3 id="u6267_u884C_u90E8_u7F72_u547D_u4EE4"><a href="#u6267_u884C_u90E8_u7F72_u547D_u4EE4" class="headerlink" title="执行部署命令"></a>执行部署命令</h3><pre><code>$ hexo deploy
</code></pre><blockquote>
<p>可以使用<code>-g，--generate</code>可选参数部署之前预先生成静态文件</p>
</blockquote>
<p>在GitHub上部署完成之后，以后别人也可以通过<a href="http://username.github.io网站访问你的个人博客网站了" target="_blank" rel="external">http://username.github.io网站访问你的个人博客网站了</a></p>
<h2 id="u57DF_u540D_u7ED1_u5B9A"><a href="#u57DF_u540D_u7ED1_u5B9A" class="headerlink" title="域名绑定"></a>域名绑定</h2><hr>
<h3 id="Godaddy_u57DF_u540D_u7533_u8BF7"><a href="#Godaddy_u57DF_u540D_u7533_u8BF7" class="headerlink" title="Godaddy域名申请"></a>Godaddy域名申请</h3><p>如果想使用自己申请的域名来访问GitHub上部署的个人博客，可以先到<a href="https://www.godaddy.com/" target="_blank" rel="external">Godaddy</a>上申请域名,笔者申请的域名为<a href="http://www.franktly.com">http://www.franktly.com</a></p>
<p>Godaddy的域名申请一般分为：</p>
<ol>
<li>Search Domain： 查找自己想要申请的域名，若未被别人申请才行</li>
<li>Select Extensions: 选择域名的扩展名，有.com、.net等等可以选择</li>
<li>Continue To Chart: 选择提供的相应的服务去付款，支持支付宝支付</li>
</ol>
<h3 id="Godaddy_u57DF_u540D_u8BBE_u7F6E"><a href="#Godaddy_u57DF_u540D_u8BBE_u7F6E" class="headerlink" title="Godaddy域名设置"></a>Godaddy域名设置</h3><p>申请成功后，需要设置Godaddy的域名，将申请到的域名关联到username.github.io网址上,具体步骤如下：<br>1) 打开个人Godday主页查看购买的Products:   </p>
<p><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FGoDaddy%20Products.PNG" alt="DomainSet1"></p>
<p>2) 选择管理DNS，在DNS ZONE FILE中选择Add Record：</p>
<p><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FDomain_Set1.PNG" alt="DomainSet2"></p>
<p>3) 在ZONE RECORD中选择CNAME文件类型，HOST为www或www.yourdomain,POINTS TO为github地址：</p>
<p><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FDomain_Set2.PNG" alt="DomainSet3"></p>
<p>4) 设置成功后，会在CNAME记录上显示新加的记录：</p>
<p><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FDomain_Set3.PNG" alt="DomainSet4"></p>
<h3 id="GitHub_u57DF_u540D_u8BBE_u7F6E"><a href="#GitHub_u57DF_u540D_u8BBE_u7F6E" class="headerlink" title="GitHub域名设置"></a>GitHub域名设置</h3><p>在GitHub端也相应的设置下域名，只需在本地博客的根目录下source文件夹下增加一个CNAME文件，文件内容为你申请的域名地址，如本人的是：<code>www.franktly.com</code></p>
<blockquote>
<p>本地根目录下的source文件夹下的增加CNAME文件后，需要重新执行下<code>hexo deploy</code>命令将CNAME文件部署到GitHub服务器才能生效，成功后，一般需要等十几分钟左右才能通过新申请的域名访问你的博客<br>放到博客根目录的source文件夹下面比直接通过Git客户端将本地CNAME文件push到GitHub上好些，这样可以避免每次<code>hexo deploy</code>后，hexo自动将 CNAME文件删除掉</p>
</blockquote>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><hr>
<p>本篇主要介绍了将本地Hexo搭建的个人博客网站部署到GitHub服务器上的方法，并且简要的介绍了在Godaddy上域名的申请方法和设置，至此，就可以使用域名在网络上访问自己的博客了，如果觉得博客的主题不是自己喜欢的还可以更改Hexo的默认主题，下篇将会简介Hexo中怎么使用Next主题来使Blog更好看</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇介绍了使用Hexo在本地搭建的过程，本篇将本地搭建的博客网站部署到服务器去，常见的服务器有:</p>
<ul>
<li><a href="https://github.com/">GitHub</a></li>
<li><a href="https://www.heroku.com/">Heroku</a></li>
<li>…</li>
</ul>
<p>本文选用使用比较多的GitHub作为目标服务器</p>]]>
    
    </summary>
    
      <category term="Git" scheme="http://www.franktly.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://www.franktly.com/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://www.franktly.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://www.franktly.com/tags/Next/"/>
    
      <category term="Node.js" scheme="http://www.franktly.com/tags/Node-js/"/>
    
      <category term="博客" scheme="http://www.franktly.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客搭建" scheme="http://www.franktly.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Hexo搭建个人博客(1)]]></title>
    <link href="http://www.franktly.com/2016/01/09/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-1/"/>
    <id>http://www.franktly.com/2016/01/09/使用Hexo搭建个人博客-1/</id>
    <published>2016-01-08T16:00:00.000Z</published>
    <updated>2016-01-22T13:49:10.731Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>写个人Blog大部分情况下是在使用现有的网站提供的博客系统，使用比较多的有sina博客、网易博客、CSDN等，如果想DIY个人的博客，可以选择静态网站的方式，使用的比较多的静态博客框架有:</p>
<ul>
<li><a href="http://jekyll.bootcss.com/" target="_blank" rel="external">Jekyll</a>:<br>Jekyll是一种基于Ruby开发的、适用于博客的静态网站生成引擎。使用一个模板目录作为网站布局的基础框架，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。即只要安装Jekyll的规范和结构，不需写html，便可生成网站</li>
<li><a href="http://octopress.org/" target="_blank" rel="external">Octopress</a>:<br>Octopress是一款基于Ruby开发的静态化、本地化的博客系统。其最大的优势就是静态化，不依赖脚本程序，没有MysqL等数据库，因此它可在一些性能差的服务器或者虚拟空间上运行，同等条件下打开页面的速度会比较快 </li>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>:<br>Hexo是一款基于node.js开发的博客程序，拥有简单的服务器，可用作简单的动态博客使用。也有生成器，生成的静态文件可以一键部署到Github Pages上，也可以部署到任意静态文件服务器上。它相当简约，并且可使用Markdown来编写文章<br>考虑到简单易用，生成效率问题，选用Hexo作为搭建个人博客的框架</li>
</ul>
<a id="more"></a>
<h2 id="Hexo_u7B80_u4ECB"><a href="#Hexo_u7B80_u4ECB" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><hr>
<p>Hexo是一个快速、简单且高效的博客框架,使用Markown(或其他渲染引擎)解析文章，可以高效的利用各种主题插件生成自定义的静态页面，使用Hexo时候，一般是在本地编辑文章，转化为生成HTML文件，然后上传到部署的服务器上</p>
<h2 id="Hexo_u5B89_u88C5"><a href="#Hexo_u5B89_u88C5" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><hr>
<h3 id="u5B89_u88C5Hexo_u524D_u9700_u8981_u7684_u51C6_u5907"><a href="#u5B89_u88C5Hexo_u524D_u9700_u8981_u7684_u51C6_u5907" class="headerlink" title="安装Hexo前需要的准备"></a>安装Hexo前需要的准备</h3><ul>
<li>Node.js:<br>[Node.js下载地址]（<a href="https://nodejs.org/en/）" target="_blank" rel="external">https://nodejs.org/en/）</a><br>笔者安装的是Window版本的node-v5.3.0-x64.msi，安装完成后，在cmd输入<code>node -v</code>可以查看安装的版本和是否正确</li>
<li>Git：<br>[git下载地址]（<a href="http://git-scm.com/download/）" target="_blank" rel="external">http://git-scm.com/download/）</a><br>笔者安装的是Windows版本的git version 1.9.5.msysgit.0,安装完成后，<code>git --version</code>可以查看安装的版本和是否正确</li>
</ul>
<h3 id="u5B89_u88C5Hexo"><a href="#u5B89_u88C5Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>使用npm（npm是node.js的模块管理和发布工具,安装node的时候会自动安装此工具）安装Hexo，shell中输入下面命令：</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>安装完成后，shell中输入<code>hexo -v</code>或<code>hexo version</code>查看安装的版本</p>
<blockquote>
<p><code>-g</code>: 表示全局安装，未带此参数表示本地安装</p>
<ul>
<li>全局安装：模块将被安装到<strong>全局目录</strong>中，全局目录可以通过<code>npm config set prefix &quot;目录路径&quot;</code>来设置，通过<code>npm config get prefix</code> 来获取</li>
<li>本地安装：模块将被安装到<strong>当前命令行所在目录中</strong><br>一般采用全局安装方式统一安装到一个目录中去，方便管理、结构清晰、可以重复利用</li>
</ul>
</blockquote>
<h2 id="Hexo_u672C_u5730_u5EFA_u7AD9"><a href="#Hexo_u672C_u5730_u5EFA_u7AD9" class="headerlink" title="Hexo本地建站"></a>Hexo本地建站</h2><hr>
<h3 id="u521D_u59CB_u5316Blog_u7F51_u7AD9_u6846_u67B6"><a href="#u521D_u59CB_u5316Blog_u7F51_u7AD9_u6846_u67B6" class="headerlink" title="初始化Blog网站框架"></a>初始化Blog网站框架</h3><p>在本地电脑上建立一个Blog目录，并在shell中进行下面命令，初始化框架:</p>
<pre><code>$ hexo init &lt;your blog folder&gt;
$ cd folder
$ npm install
</code></pre><blockquote>
<p>或者直接进入Blog目录中，执行<code>hexo init</code>和<code>npm install</code></p>
</blockquote>
<h3 id="u4FEE_u6539Blog_u7F51_u7AD9_u914D_u7F6E"><a href="#u4FEE_u6539Blog_u7F51_u7AD9_u914D_u7F6E" class="headerlink" title="修改Blog网站配置"></a>修改Blog网站配置</h3><p>初始化完成后，该Blog目录就会出现下面几个文件夹：</p>
<pre><code>|—— _config.yml
|—— package.json
|—— scanffolds
|—— source
|    |—— _posts
|—— themes
</code></pre><blockquote>
<ul>
<li>_config.yml:<br>整个站点的<strong>配置</strong>信息：可以配置网站的title、author、language、目录、文章、日期、分页、扩展（主题名称、部署）信息</li>
<li>package.json: 应用程序信息</li>
<li>scanffolds: 模板文件夹,创建新文章时,Hexo会根据此建立文件</li>
<li>source: 资源文件夹,存放用户资源</li>
<li>themes: 主题文件夹，Hexo会根据此来生成静态页面，默认是官方的<em>landscape</em>主题</li>
</ul>
</blockquote>
<h3 id="u5199Blog_u6587_u7AE0"><a href="#u5199Blog_u6587_u7AE0" class="headerlink" title="写Blog文章"></a>写Blog文章</h3><p>执行下面的命令创建一篇新的文章:</p>
<pre><code>$ hexo new [layout] &lt;title&gt;
</code></pre><p>建立的文章后，在/source/_post里会出现该title的文章，之后的文章均保持在此目录</p>
<blockquote>
<p>可选参数：文章布局layout，默认是post,可以修改_config.yml中的default_layout来修改默认布局<br>文章的默认布局有3种： post、page、draft，分别对应不同的路径：</p>
</blockquote>
<table>
<thead>
<tr>
<th>Layout</th>
<th>Path       </th>
</tr>
</thead>
<tbody>
<tr>
<td> post</td>
<td>source/_posts  </td>
</tr>
<tr>
<td> page</td>
<td>source         </td>
</tr>
<tr>
<td> draft</td>
<td>source/_drafts </td>
</tr>
</tbody>
</table>
<blockquote>
<p>将草稿发布,执行下面publish命令， 将草稿移动到source/_post文件夹下：<br><code>$ hexo publish [layout] &lt;title&gt;</code><br>草稿默认不会显示在页面中，执行时候加上–draft参数或render_drafts参数设置为true来预览草稿</p>
</blockquote>
<h3 id="u751F_u6210_u7F51_u7AD9"><a href="#u751F_u6210_u7F51_u7AD9" class="headerlink" title="生成网站"></a>生成网站</h3><p>写完文章后，在cmd中执行下面命令生成静态文件，生成网站：</p>
<pre><code>$ hexo generate
</code></pre><p>生成网站后，会在Blog的根目录下生成一个pulic临时文件，存放生成的网站结果，可以通过<code>hexo clean</code>命令清除生成结果，然后再执行<code>hexo generate</code>重新生成</p>
<h3 id="u542F_u52A8Hexo_u670D_u52A1_u5668"><a href="#u542F_u52A8Hexo_u670D_u52A1_u5668" class="headerlink" title="启动Hexo服务器"></a>启动Hexo服务器</h3><p><strong>Hexo3.0之后的版本把服务器独立成了单独的模块，必须先安装hexo-sever才能使用</strong>:</p>
<pre><code>$ npm install hexo-server --save
</code></pre><blockquote>
<p><code>--save</code>:安装的同时将信息写入package.json中项目路径中如果有package.json文件时，使用<code>npm install</code>方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了</p>
</blockquote>
<p>安装hexo-server后，执行下面命令启动服务器,启动服务器之后，Hexo会自动监视文件变动并自动更新，无需重启服务器：</p>
<pre><code>$ hexo server
</code></pre><blockquote>
<p>如果想更改服务器的端口(默认是4000)，或启动时遇到EADDRINUSE 错误可以加-p选项指定其他端口:<br><code>$ hexo server -p 3000</code><br>服务器默认运行在0.0.0.0，可以覆盖默认的IP:<br><code>$ hexo server -i 192.168.0.1</code></p>
</blockquote>
<p>启动服务之后，本地的Blog网站系统搭建完成，可以在输入以下网址查看Blog的搭建效果：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 或 <a href="http://127.0.0.1:4000" target="_blank" rel="external">http://127.0.0.1:4000</a></p>
<h3 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h3><hr>
<p>这样一个本地的Blog网站建立完成，每次需要写Blog时候，只需要<code>hexo new</code> (hexo n for short)一篇文章，再使用markdown编辑文章，然后<code>hexo generarte</code>(hexo g for short)即可，但是这样Blog只能在本地的机器上访问，要想让别人也可以通过网址访问，需要将Blog deploy部署到服务器上，具体方法见下篇</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><hr>
<p>写个人Blog大部分情况下是在使用现有的网站提供的博客系统，使用比较多的有sina博客、网易博客、CSDN等，如果想DIY个人的博客，可以选择静态网站的方式，使用的比较多的静态博客框架有:</p>
<ul>
<li><a href="http://jekyll.bootcss.com/">Jekyll</a>:<br>Jekyll是一种基于Ruby开发的、适用于博客的静态网站生成引擎。使用一个模板目录作为网站布局的基础框架，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。即只要安装Jekyll的规范和结构，不需写html，便可生成网站</li>
<li><a href="http://octopress.org/">Octopress</a>:<br>Octopress是一款基于Ruby开发的静态化、本地化的博客系统。其最大的优势就是静态化，不依赖脚本程序，没有MysqL等数据库，因此它可在一些性能差的服务器或者虚拟空间上运行，同等条件下打开页面的速度会比较快 </li>
<li><a href="https://hexo.io/">Hexo</a>:<br>Hexo是一款基于node.js开发的博客程序，拥有简单的服务器，可用作简单的动态博客使用。也有生成器，生成的静态文件可以一键部署到Github Pages上，也可以部署到任意静态文件服务器上。它相当简约，并且可使用Markdown来编写文章<br>考虑到简单易用，生成效率问题，选用Hexo作为搭建个人博客的框架</li>
</ul>]]>
    
    </summary>
    
      <category term="Git" scheme="http://www.franktly.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://www.franktly.com/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://www.franktly.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://www.franktly.com/tags/Next/"/>
    
      <category term="Node.js" scheme="http://www.franktly.com/tags/Node-js/"/>
    
      <category term="博客" scheme="http://www.franktly.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="博客搭建" scheme="http://www.franktly.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
