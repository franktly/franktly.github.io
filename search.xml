<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++对象模型-1</title>
    <url>/2021/06/03/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在C++中经常出现的问题就是求某个对象的大小，包括各种场景如空类，含虚函数的类，不含虚函数的类等等，与之相关的就是C++最重要的特性多态的实现方式——虚函数的内部实现机制。这些问题都涉及到C++的对象模型内存布局，下面就从计算对象空间大小问题引出对象内存的基本布局和对象模型的分类。并在接下来的各篇文章中依次介绍各个继承体系下对象内存布局情况大小，如未特殊说明这些实例均是在G++9.4.0, Gcc9.4.0, Ubuntu20.04, 64bit机器环境下测试结果</p>
<span id="more"></span>

<h2 id="关于计算C-对象空间大小"><a href="#关于计算C-对象空间大小" class="headerlink" title="关于计算C++对象空间大小"></a>关于计算C++对象空间大小</h2><hr>
<h3 id="一个空类的对象大小"><a href="#一个空类的对象大小" class="headerlink" title="一个空类的对象大小"></a>一个空类的对象大小</h3><hr>
<p>如下面空类，求该类大小</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">EmptyClass</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmptyClassTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EmptyClass e;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Empty class size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(e) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>Empty class size is: 1
</code></pre>
<p>一个类什么都没有，怎么还有一个Byte的空间呢？因为空类需要一个占位符，当类实例化对象时候，不同的对象有不同的地址从而区分不同的对象，如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">EmptyClass</span> ee[<span class="number">3</span>];</span><br><span class="line"><span class="attribute">std</span>::cout &lt;&lt; <span class="string">&quot;ee[0]:&quot;</span> &lt;&lt; &amp;ee[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; ee[1]:&quot;</span> &lt;&lt; &amp;ee[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; ee[2]:&quot;</span> &lt;&lt; &amp;ee[<span class="number">2</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>ee[0]:0x7ffe6f7127b5 ee[1]:0x7ffe6f7127b6 ee[2]:0x7ffe6f7127b7
</code></pre>
<h3 id="一个正常类的对象大小"><a href="#一个正常类的对象大小" class="headerlink" title="一个正常类的对象大小"></a>一个正常类的对象大小</h3><hr>
<p>求如下类对象的大小：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">__attribute__</span> ((<span class="symbol">packed, <span class="symbol">aligned</span></span>(<span class="symbol">1</span>))) <span class="symbol">FullClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FullClass()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Func1(<span class="built_in">void</span>) <span class="comment">// 普通成员函数</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    static <span class="built_in">void</span> Func2(<span class="built_in">void</span>) <span class="comment">// 静态成员函数</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    virtual <span class="built_in">void</span> Func3(<span class="built_in">void</span>) <span class="comment">// 虚成员函数</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _var1;  <span class="comment">// 普通成员变量</span></span><br><span class="line">    static <span class="built_in">int</span> _var2; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullClassTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FullClass f;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Full class size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>    Full class size is: 12
</code></pre>
<p>可以看到对象的大小为12，通过Gcc查看内存布局的<code>-fdump-lang-class</code>选项命令：</p>
<pre><code>    g++ -fdump-lang-class insideCpp.cpp
</code></pre>
<blockquote>
<p><code>-fdump-lang-class</code>命令查看Gcc内存布局的使用方式： <code>g++ -fdump-lang-class [filename]</code>, 输出为<code>.class</code>后缀的文件，里面包含该文件内所有类的内存布局信息<br><code>-fdump-record-layouts</code>命令查看Clang内存布局的使用方式： <code>clang -cc1 -fdump-record-layouts [filename]</code><br><code>cl</code>命令查看MSVC内存布局的使用方式： <code>cl [filename] -d1reportSingleClassLayout[classname]</code></p>
</blockquote>
<p>可以看到<code>FullClass</code>的Gcc下的内存布局为：</p>
<pre><code>Vtable for FullClass
FullClass::_ZTV9FullClass: 3 entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; _ZTI9FullClass)
16    (int (*)(...))FullClass::Func3

Class FullClass
   size=12 align=1
   base size=12 base align=1
FullClass (0x0x7f114ac677e0) 0
    vptr=((&amp; FullClass::_ZTV9FullClass) + 16)
</code></pre>
<blockquote>
<p>即只有一个虚函数表的指针变量vfptr(指针类型(64位)占8 Bytes)和一个普通的成员变量_var1(int占4 Bytes)，其余的函数和变量不在对象的内存布局范围内<br>使用<code>__attribute__ ((packed, aligned(1)))</code>Gcc属性强制让其1字节对齐而不是默认的8字节对齐，从而结果为12 Bytes<br>静态数据成员、静态成员函数和普通成员函数均不占对象内存空间</p>
</blockquote>
<h3 id="考虑字节对齐"><a href="#考虑字节对齐" class="headerlink" title="考虑字节对齐"></a>考虑字节对齐</h3><hr>
<p>在上述<code>FullClass</code>类中去掉<code>__attribute__ ((packed, aligned(1)))</code>属性，使用默认的字节对齐方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FullClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FullClass</span>()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Func1</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 普通成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Func3</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 虚成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _var1;  <span class="comment">// 普通成员变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _var2; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次查看该类对象的大小：</p>
<pre><code>Full class size is: 16
</code></pre>
<p>此时查看对象大小不是<code>8 + 4 = 12</code>，而是<code>8 + 8 = 16</code>，因为默认有8字节对齐(64位按照最大指针大小对齐，数据宽度64位，使总线的运输效率最大化)处理，增加了<code>padding</code>，通过Gcc <code>-fdump-lang-class</code>选项命令的结果：</p>
<pre><code>Vtable for FullClass
FullClass::_ZTV9FullClass: 3 entries
0     (int (*)(...))0
8     (int (*)(...))(&amp; _ZTI9FullClass)
16    (int (*)(...))FullClass::Func3

Class FullClass
   size=16 align=8
   base size=12 base align=8
FullClass (0x0x7f0a23e1f7e0) 0
    vptr=((&amp; FullClass::_ZTV9FullClass) + 16)
</code></pre>
<blockquote>
<p>由于最大字节宽度的变量为vfptr虚表指针为8 Bytes所以align为8，虚表大小加上成员变量总共8+4&#x3D;16字节，通过8Bytes align最终大小为16 Bytes</p>
</blockquote>
<h3 id="对象大小总结"><a href="#对象大小总结" class="headerlink" title="对象大小总结"></a>对象大小总结</h3><hr>
<p>从上面的例子可以看出影响一个类对象的内存大小主要包括以下几个方面：</p>
<ol>
<li><strong>其非静态数据成员的总和大小</strong></li>
<li><strong>由于字节对齐而填补的空间大小</strong></li>
<li><strong>为了支持virtual而由内部产生的额外空间(包括虚函数表指针vfptr和虚拟继承表指针vbptr)</strong></li>
</ol>
<h2 id="对象模型种类"><a href="#对象模型种类" class="headerlink" title="对象模型种类"></a>对象模型种类</h2><hr>
<p>在C++中由两种类数据成员：static、nostatic；三种类成员函数：static、nostatic、virtual</p>
<blockquote>
<p>由于static不能修饰virtual，因为static属于类的而不是某个对象的，不存在this指针，而虚函数实现机制虚函数表需要this指针。所以此处的nostatic成员函数是指普通成员函数</p>
</blockquote>
<p>对于类中各种成员的布局，有以下三种模式：</p>
<h3 id="简单对象模型"><a href="#简单对象模型" class="headerlink" title="简单对象模型"></a>简单对象模型</h3><hr>
<p>对象由一系列的slots组成，每个slot指向一个成员，成员按照声明的次序依次被指定一个slot,每个数据成员和成员函数都有自己的slot(包括静态的或非静态的)<br>对于<code>FullClass</code>类，若用简单对象模型，则如下图所示：</p>
<p><img src="http://www.taolingyang.com/2021/06/03/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-1/simple_object_model.png" alt="simple_object_model"></p>
<blockquote>
<p>简单对象模型中只存放各个成员的指针，可以解决“不同类型成员有不同大小的存储空间问题”，所以大小是指针大小与成员个数相乘，各个成员可以通过slot索引来寻址</p>
</blockquote>
<h3 id="表格驱动模型-双表格模型"><a href="#表格驱动模型-双表格模型" class="headerlink" title="表格驱动模型(双表格模型)"></a>表格驱动模型(双表格模型)</h3><hr>
<p>表格驱动模型中只存放两个表指针：成员数据表和成员函数表，成员函数表内各个slot指向一个函数地址，成员数据表内各个slot存放具体成员变量数据<br>对于<code>FullClass</code>类，若用表格驱动模型，则如下图所示：</p>
<p><img src="http://www.taolingyang.com/2021/06/03/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-1/table_driven_object.png" alt="table_driven_model"></p>
<h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><hr>
<p>C++对象模型对上面两种模型在时间和空间上做了平衡和优化，对象模型内只存放虚函数表指针和具体的成员变量数据(和虚基类指针，若存在的话)，静态成员和普通成员函数在对象模型之外<br>对于<code>FullClass</code>类，若用C++模型，则如下图所示：</p>
<p><img src="http://www.taolingyang.com/2021/06/03/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-1/cpp_object.png" alt="cplusplus_object_model"></p>
<h3 id="三种对象模型总结"><a href="#三种对象模型总结" class="headerlink" title="三种对象模型总结"></a>三种对象模型总结</h3><hr>
<table>
<thead>
<tr>
<th align="center">对象模型</th>
<th align="center">计算大小</th>
<th align="center">存储空间大小</th>
<th align="center">数据成员存取效率</th>
<th align="center">是否包含静态成员或普通成员函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">简单对象模型</td>
<td align="center">指针大小与所有成员个数相乘，较大</td>
<td align="center">较大</td>
<td align="center">数据成员两级寻址</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">表格驱动模型</td>
<td align="center">2个表指针大小，较小</td>
<td align="center">较小</td>
<td align="center">数据成员两级寻址</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">C++对象模型</td>
<td align="center">虚表指针(加上虚基表指针，若有)大小与真实数据成员大小之和，适中</td>
<td align="center">适中</td>
<td align="center">数据成员一级寻址</td>
<td align="center">无</td>
</tr>
</tbody></table>
<blockquote>
<p>从表格中可以看出C++对象模型优点在于空间和存取时间的综合效率上，且为了实现多态在虚函数表的<strong>第一个位置上面</strong>增加了RTTI运行时类型决定信息</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>本篇主要介绍了C++类对象大小的计算，并引出了对象模型内部的基本内存布局和三种对象模型，下一篇将继续介绍在各种继承情况下，继承类的内存布局变化情况</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Object Model</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型-2</title>
    <url>/2021/06/13/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>前一篇主要介绍了C++对象的内部基本布局和三种对象模型，没有考虑到继承的情况。在各种继承情况下，对象的内存布局又有什么变化呢？接下来将分三篇从普通单继承，普通多继承，虚拟单继承，虚拟多继承，菱形普通继承，菱形虚拟继承等几种继承方式下分别探究下C++对象模型的特点</p>
<span id="more"></span>

<h2 id="普通继承"><a href="#普通继承" class="headerlink" title="普通继承"></a>普通继承</h2><hr>
<h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><hr>
<h4 id="简单实现代码"><a href="#简单实现代码" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base 类： First Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> var = <span class="number">10</span>) : _base_var(var) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunBase</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Class RunBase()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _base_var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc查看内存布局"><a href="#Gcc查看内存布局" class="headerlink" title="Gcc查看内存布局"></a>Gcc查看内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Base</span><br><span class="line">Base::_ZTV4Base: <span class="number">4</span> entries</span><br><span class="line"><span class="number">0</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">8     (int (*)</span>(...))(&amp; _ZTI4Base)</span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))Base::Run</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))Base::RunBase</span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> Base</span><br><span class="line">   size=<span class="number">16</span> align=<span class="number">8</span></span><br><span class="line">   base size=<span class="number">12</span> base align=<span class="number">8</span></span><br><span class="line">Base (<span class="number">0</span>x0x7f223aac30c0) <span class="number">0</span></span><br><span class="line">    vptr=((&amp; Base::_ZTV4Base) + <span class="number">16</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到基类的内存空间排序顺序为虚函数表在第一个位置，这样做是为了保证高效的获取虚函数地址(不需要偏移)，提高效率，然后是成员变量，成员变量按声明顺序依次排列</p>
</blockquote>
<h4 id="内存布局的代码验证"><a href="#内存布局的代码验证" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*pFunc)</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// 函数指针定义，后续使用到的函数指针均为此</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BaseTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin base object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(b) &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;b &lt;&lt; std::endl; <span class="comment">// </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;b &lt;&lt; std::endl; <span class="comment">//vfptr 在对象第1个位置 最外层(long*)是把第一个位置的值转换为long地址类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(b) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// b对象类型</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot; object vfptr[-1] type info name is: &quot; &lt;&lt; ((type_info*)((long*)(*(long*)&amp;b) - 1))-&gt;name() &lt;&lt; std::endl;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;b)&lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;b));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;b) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;b) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;b + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;b + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第2个位置 </span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  base object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&amp;b</code>为对象的地址；<br><code>*(long*)&amp;b</code>为对象内存第一个位置的值，即是虚函数表地址，因此需要强转为<code>long</code>型指针类型，因为表项也为指针类型(表项为函数地址指针类型，而指针视为<code>long</code>类型)<br><code>*((long*)(*(long*)&amp;b) + n)</code>为虚函数表第<code>n</code>(<code>n</code>从0开始)个表项的值(即虚函数地址值)，需要强转为<code>pFunc</code>类型<br><code>*((long*)&amp;b + m)</code>为对象内存第<code>m</code>个位置的值,此处<code>m = 1</code>为变量<code>_base_var</code>的数据本身值</p>
</blockquote>
<p>2.运行结果：</p>
<figure class="highlight nim"><table><tr><td class="code"><pre><span class="line">---------begin base <span class="keyword">object</span> inner memory layout test-------</span><br><span class="line"> <span class="keyword">object</span> size <span class="keyword">is</span>: <span class="number">16</span></span><br><span class="line"> <span class="keyword">object</span> <span class="keyword">addr</span> <span class="keyword">is</span>: <span class="number">0x7ffd9a7680e0</span></span><br><span class="line"> <span class="keyword">object</span> vfptr value <span class="keyword">is</span>: <span class="number">0x559bc73a9ce0</span></span><br><span class="line"> typeid(b) <span class="keyword">is</span>: <span class="number">4</span>Base</span><br><span class="line"> <span class="keyword">object</span> vfptr[<span class="number">0</span>] <span class="keyword">func</span> <span class="keyword">ptr</span>  <span class="keyword">is</span>: <span class="number">0x559bc73a611a</span></span><br><span class="line"> <span class="keyword">object</span> vfptr[<span class="number">0</span>] <span class="keyword">func</span> invoke res: <span class="type">Base</span> <span class="type">Class</span> <span class="type">Run</span>()</span><br><span class="line"> <span class="keyword">object</span> vfptr[<span class="number">1</span>] <span class="keyword">func</span> <span class="keyword">ptr</span>  <span class="keyword">is</span>: <span class="number">0x559bc73a6156</span></span><br><span class="line"> <span class="keyword">object</span> vfptr[<span class="number">1</span>] <span class="keyword">func</span> invoke res: <span class="type">Base</span> <span class="type">Class</span> <span class="type">RunBase</span>()</span><br><span class="line"> <span class="keyword">object</span> _base_var <span class="keyword">addr</span> <span class="keyword">is</span>: <span class="number">0x7ffd9a7680e8</span></span><br><span class="line"> <span class="keyword">object</span> _base_var value <span class="keyword">is</span>: <span class="number">10</span></span><br><span class="line">---------<span class="keyword">end</span>  base <span class="keyword">object</span> inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/06/13/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-2/base_layout.png" alt="base"></p>
<h3 id="普通单继承的子类"><a href="#普通单继承的子类" class="headerlink" title="普通单继承的子类"></a>普通单继承的子类</h3><hr>
<h4 id="简单实现代码-1"><a href="#简单实现代码-1" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Single Common Derive： Second Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive_Sin_Com</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive_Sin_Com</span>(<span class="type">int</span> var = <span class="number">20</span>) : <span class="built_in">Base</span>(var), _derive_sin_com_var(var) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base::Run()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Sin_Com Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunDerive_Sin_Com</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// new virtual function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Sin_Com Class RunDerive_Sin_Com()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _derive_sin_com_var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc查看内存布局-1"><a href="#Gcc查看内存布局-1" class="headerlink" title="Gcc查看内存布局"></a>Gcc查看内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Derive_Sin_Com</span><br><span class="line">Derive_Sin_Com::_ZTV14Derive_Sin_Com: <span class="number">5</span> entries</span><br><span class="line"><span class="number">0</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">8     (int (*)</span>(...))(&amp; _ZTI14Derive_Sin_Com)</span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))Derive_Sin_Com::Run</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))Base::RunBase</span><br><span class="line"><span class="number">32</span>    (int <span class="comment">(*)(...))Derive_Sin_Com::RunDerive_Sin_Com</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Class Derive_Sin_Com</span></span><br><span class="line"><span class="comment">   size=16 align=8</span></span><br><span class="line"><span class="comment">   base size=16 base align=8</span></span><br><span class="line"><span class="comment">Derive_Sin_Com (0x0x7f223ab202d8) 0</span></span><br><span class="line"><span class="comment">    vptr=((&amp; Derive_Sin_Com::_ZTV14Derive_Sin_Com) + 16)</span></span><br><span class="line"><span class="comment">  Base (0x0x7f223ab13480) 0</span></span><br><span class="line"><span class="comment">      primary-for Derive_Sin_Com (0x0x7f223ab202d8)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到普通单继承的子类的内存空间特点是<strong>基类的内存布局+子类的成员变量</strong>，基类的内存布局包括基类的虚函数表和基类的成员变量。子类的虚函数在继承而来的基类的虚函数表基础上进行替换(override)，新增(子类新的虚函数)，保持操作(没有override)</p>
</blockquote>
<h4 id="内存布局的代码验证-1"><a href="#内存布局的代码验证-1" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleCommonDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive_Sin_Com d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin single common derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  vfptr地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunDerive_Sin_Com = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>));</span><br><span class="line">    (*pRunDerive_Sin_Com)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">0</span>) &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_sin_com_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//_derive_sin_com_var 在对象第3个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_sin_com_var value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; std::endl; </span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  single common derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">---------begin single common derive object inner memory layout test-------</span><br><span class="line"> object size is: 16</span><br><span class="line"> object addr is: 0x7ffd9db3df50</span><br><span class="line"> object vfptr value is: 0x5606ab76b728</span><br><span class="line"> typeid(d) is: 14Derive_Sin_Com</span><br><span class="line"> object vfptr[0] func ptr  is: 0x5606ab7671c8</span><br><span class="line"> object vfptr[0] func<span class="built_in"> invoke </span>res: Derive_Sin_Com Class Run()</span><br><span class="line"> object vfptr[1] func ptr  is: 0x5606ab766d62</span><br><span class="line"> object vfptr[1] func<span class="built_in"> invoke </span>res: Base Class RunBase()</span><br><span class="line"> object vfptr[2] func ptr  is: 0x5606ab767204</span><br><span class="line"> object vfptr[2] func<span class="built_in"> invoke </span>res: Derive_Sin_Com Class RunDerive_Sin_Com()</span><br><span class="line"> object _base_var addr is: 0x7ffd9db3df58</span><br><span class="line"> object _base_var value is: 20</span><br><span class="line"> object _derive_sin_com_var addr is: 0x7ffd9db3df5c</span><br><span class="line"> object _derive_sin_com_var value is: 20</span><br><span class="line">---------end  single common derive  object inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/06/13/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-2/sin_com_layout.png" alt="single common derive"></p>
<h3 id="普通多继承的子类"><a href="#普通多继承的子类" class="headerlink" title="普通多继承的子类"></a>普通多继承的子类</h3><hr>
<h4 id="简单实现代码-2"><a href="#简单实现代码-2" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base2 类 : First Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">int</span> var = <span class="number">10</span>) : _base2_var(var) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base2 Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunBase2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base2 Class RunBase2()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _base2_var;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multi Common Derive: Second Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive_Mul_Com</span> : <span class="keyword">public</span> Base, <span class="keyword">public</span> Base2 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive_Mul_Com</span>(<span class="type">int</span> var = <span class="number">30</span>) : <span class="built_in">Base</span>(var), <span class="built_in">Base2</span>(var), _derive_mul_com_var(var) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base::Run() and Base2::Run()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Mul_Com Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunBase</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base::RunBase()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Mul_Com Class RunBase()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunDerive_Mul_Com</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// new virtual function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Mul_Com Class RunDerive_Mul_Com()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _derive_mul_com_var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc查看内存布局-2"><a href="#Gcc查看内存布局-2" class="headerlink" title="Gcc查看内存布局"></a>Gcc查看内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Derive_Mul_Com</span><br><span class="line">Derive_Mul_Com::_ZTV14Derive_Mul_Com: <span class="number">9</span> entries</span><br><span class="line"><span class="number">0</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">8     (int (*)</span>(...))(&amp; _ZTI14Derive_Mul_Com)</span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))Derive_Mul_Com::Run</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))Derive_Mul_Com::RunBase</span><br><span class="line"><span class="number">32</span>    (int <span class="comment">(*)(...))Derive_Mul_Com::RunDerive_Mul_Com</span></span><br><span class="line"><span class="comment">40    (int (*)</span>(...))-<span class="number">16</span></span><br><span class="line"><span class="number">48</span>    (int <span class="comment">(*)(...))(&amp; _ZTI14Derive_Mul_Com)</span></span><br><span class="line"><span class="comment">56    (int (*)</span>(...))Derive_Mul_Com::_ZThn16_N14Derive_Mul_Com3RunEv</span><br><span class="line"><span class="number">64</span>    (int <span class="comment">(*)(...))Base2::RunBase2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Class Derive_Mul_Com</span></span><br><span class="line"><span class="comment">   size=32 align=8</span></span><br><span class="line"><span class="comment">   base size=32 base align=8</span></span><br><span class="line"><span class="comment">Derive_Mul_Com (0x0x7f223af5caf0) 0</span></span><br><span class="line"><span class="comment">    vptr=((&amp; Derive_Mul_Com::_ZTV14Derive_Mul_Com) + 16)</span></span><br><span class="line"><span class="comment">  Base (0x0x7f223ab790c0) 0</span></span><br><span class="line"><span class="comment">      primary-for Derive_Mul_Com (0x0x7f223af5caf0)</span></span><br><span class="line"><span class="comment">  Base2 (0x0x7f223ab79120) 16</span></span><br><span class="line"><span class="comment">      vptr=((&amp; Derive_Mul_Com::_ZTV14Derive_Mul_Com) + 56)</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到普通多继承的子类的内存空间特点是<strong>基类的内存布局(按照继承的顺序依次布局基类)+子类的成员变量</strong>，基类的内存布局包括基类的虚函数表和基类的成员变量。子类的虚函数在继承而来的<strong>第一个继承的基类</strong>的虚函数表基础上进行替换(override)，新增(子类新的虚函数)，保持操作(没有override)</p>
</blockquote>
<h4 id="内存布局的代码验证-2"><a href="#内存布局的代码验证-2" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MultiCommonDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive_Mul_Com d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin multi common derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ base obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  base vfptr地址 在对象第1个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunDerive_Mul_Com = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>));</span><br><span class="line">    (*pRunDerive_Mul_Com)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ base obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ base2 obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base2 vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">//  base2 vfptr址 在对象第3个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base2 vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//  base2 vfptr值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base2 vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base2 vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun2 = (pFunc)(*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)));</span><br><span class="line">    (*pRun2)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base2 vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base2 vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase2 = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase2)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base2_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">3</span> &lt;&lt; std::endl; <span class="comment">//_base2_var 在对象第4个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base2_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ base2 obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_mul_com_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//_derive_mul_com_var 在对象第5个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_mul_com_var value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  multi common derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">---------begin multi common derive object inner memory layout test-------</span><br><span class="line"> object size is: 32</span><br><span class="line"> object addr is: 0x7ffdcf415720</span><br><span class="line"> typeid(d) is: 14Derive_Mul_Com</span><br><span class="line">------ base obj begin -----</span><br><span class="line"> object base vfptr value is: 0x558b051786e0</span><br><span class="line"> object base vfptr[0] func ptr  is: 0x558b051742a4</span><br><span class="line"> object base vfptr[0] func<span class="built_in"> invoke </span>res: Derive_Mul_Com Class Run()</span><br><span class="line"> object base vfptr[1] func ptr  is: 0x558b051742ea</span><br><span class="line"> object base vfptr[1] func<span class="built_in"> invoke </span>res: Derive_Mul_Com Class RunBase()</span><br><span class="line"> object base vfptr[2] func ptr  is: 0x558b05174326</span><br><span class="line"> object base vfptr[2] func<span class="built_in"> invoke </span>res: Derive_Mul_Com Class RunDerive_Mul_Com()</span><br><span class="line"> object _base_var addr is: 0x7ffdcf415728</span><br><span class="line"> object _base_var value is: 30</span><br><span class="line">------ base obj end -----</span><br><span class="line">------ base2 obj begin -----</span><br><span class="line"> object base2 vfptr addr is: 0x7ffdcf415730</span><br><span class="line"> object base2 vfptr value is: 0x558b05178708</span><br><span class="line"> object base2 vfptr[0] func ptr  is: 0x558b051742df</span><br><span class="line"> object base2 vfptr[0] func<span class="built_in"> invoke </span>res: Derive_Mul_Com Class Run()</span><br><span class="line"> object base2 vfptr[1] func ptr  is: 0x558b05173e04</span><br><span class="line"> object base2 vfptr[1] func<span class="built_in"> invoke </span>res: Base2 Class RunBase2()</span><br><span class="line"> object _base2_var addr is: 0x7ffdcf415738</span><br><span class="line"> object _base2_var value is: 30</span><br><span class="line">------ base2 obj end -----</span><br><span class="line"> object _derive_mul_com_var addr is: 0x7ffdcf41573c</span><br><span class="line"> object _derive_mul_com_var value is: 30</span><br><span class="line">---------end  multi common derive  object inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/06/13/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-2/mul_com_layout.png" alt="multi common derive"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>本篇主要介绍了C++类在普通继承下的子类对象内存特点，可以看出，子类对象中的虚函数均是在继承而来的基类虚函数表中进行操作的，不会创建自己的虚函数表，子类的自己内存部分只是增加了自己的成员变量部分。对于多重情况下，子类会继承每一个基类的虚函数表，这就意味着子类在多重继承下会存在多张虚表</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Object Model</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型-3</title>
    <url>/2021/06/25/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>前一篇主要介绍了C++对象在普通单继承和普通多继承体系下的对象模型，没有考虑到虚继承的情况。接下来将从虚拟单继承，虚拟多继承（包括一部分虚继承和全部虚继承）等几种继承方式下分别探究下C++对象模型的特点，如未特别说明，所有虚拟继承体系下的基类实现代码与前一篇是一致的</p>
<span id="more"></span>

<h2 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h2><hr>
<h3 id="单虚拟继承的子类"><a href="#单虚拟继承的子类" class="headerlink" title="单虚拟继承的子类"></a>单虚拟继承的子类</h3><hr>
<h4 id="简单实现代码"><a href="#简单实现代码" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Single Virtual Derive: Second Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive_Sin_Vir</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive_Sin_Vir</span>(<span class="type">int</span> var = <span class="number">40</span>) : <span class="built_in">Base</span>(var), _derive_sin_vir_var(var) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base::Run()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Sin_Vir Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunDerive_Sin_Vir</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// new virtual function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Sin_Vir Class RunDerive_Sin_Vir()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _derive_sin_vir_var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc命令的内存布局"><a href="#Gcc命令的内存布局" class="headerlink" title="Gcc命令的内存布局"></a>Gcc命令的内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Derive_Sin_Vir</span><br><span class="line">Derive_Sin_Vir::_ZTV14Derive_Sin_Vir: <span class="number">11</span> entries</span><br><span class="line"><span class="number">0</span>     <span class="number">16</span></span><br><span class="line"><span class="number">8</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">16    (int (*)</span>(...))(&amp; _ZTI14Derive_Sin_Vir)</span><br><span class="line"><span class="number">24</span>    (int <span class="comment">(*)(...))Derive_Sin_Vir::Run</span></span><br><span class="line"><span class="comment">32    (int (*)</span>(...))Derive_Sin_Vir::RunDerive_Sin_Vir</span><br><span class="line"><span class="number">40</span>    <span class="number">0</span></span><br><span class="line"><span class="number">48</span>    <span class="number">18446744073709551600</span></span><br><span class="line"><span class="number">56</span>    (int <span class="comment">(*)(...))-16</span></span><br><span class="line"><span class="comment">64    (int (*)</span>(...))(&amp; _ZTI14Derive_Sin_Vir)</span><br><span class="line"><span class="number">72</span>    (int <span class="comment">(*)(...))Derive_Sin_Vir::_ZTv0_n24_N14Derive_Sin_Vir3RunEv</span></span><br><span class="line"><span class="comment">80    (int (*)</span>(...))Base::RunBase</span><br><span class="line"></span><br><span class="line">VTT <span class="keyword">for</span> Derive_Sin_Vir</span><br><span class="line">Derive_Sin_Vir::_ZTT14Derive_Sin_Vir: <span class="number">2</span> entries</span><br><span class="line"><span class="number">0</span>     ((&amp; Derive_Sin_Vir::_ZTV14Derive_Sin_Vir) + <span class="number">24</span>)</span><br><span class="line"><span class="number">8</span>     ((&amp; Derive_Sin_Vir::_ZTV14Derive_Sin_Vir) + <span class="number">72</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> Derive_Sin_Vir</span><br><span class="line">   size=<span class="number">32</span> align=<span class="number">8</span></span><br><span class="line">   base size=<span class="number">12</span> base align=<span class="number">8</span></span><br><span class="line">Derive_Sin_Vir (<span class="number">0</span>x0x7fb40baf95b0) <span class="number">0</span></span><br><span class="line">    vptridx=<span class="number">0</span> vptr=((&amp; Derive_Sin_Vir::_ZTV14Derive_Sin_Vir) + <span class="number">24</span>)</span><br><span class="line">  Base (<span class="number">0</span>x0x7fb40baf0780) <span class="number">16</span> <span class="keyword">virtual</span></span><br><span class="line">      vptridx=<span class="number">8</span> vbaseoffset=-<span class="number">24</span> vptr=((&amp; Derive_Sin_Vir::_ZTV14Derive_Sin_Vir) + <span class="number">72</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到单虚拟继承的子类的内存空间特点是<strong>新建的子类虚表内存布局+虚基类的内存布局</strong>。子类自己的内存布局包括自己生成的虚函数表，里面包含虚函数列表和虚表以及虚基表偏移和子类的成员变量；虚基类的内存布局包括基类的虚函数表和基类的成员变量。子类的新增的虚函数或重写对的虚函数是在自己生成的虚函数表中的；而虚基类的未重写虚函数则是在继承而来的基类的虚基表中。</p>
</blockquote>
<h4 id="内存布局的代码验证"><a href="#内存布局的代码验证" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SingleVirtualDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive_Sin_Vir d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin single virtual derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  derive vfptr地址 在对象第1个位置</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>)) &lt;&lt; std::endl; <span class="comment">//vfptr[1]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunDerive_Sin_Vir = (pFunc)((<span class="type">long</span>*)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>)));</span><br><span class="line">    (*pRunDerive_Sin_Vir)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] vptr  offset value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>)) &lt;&lt; std::endl; <span class="comment">//  vfptr[2]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[3] vbase offset value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">3</span>)) &lt;&lt; std::endl; <span class="comment">//  vfptr[3]</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_sin_vir_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_derive_sin_vir_var 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_sin_vir_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">//vfptr-base 在对象第3个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[0] func ptr  is: &quot;</span> &lt;&lt;  (<span class="type">long</span>*)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">0</span>)) &lt;&lt; std::endl;<span class="comment">// vfptr-base[0]</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; object vfptr-base[0] func invoke res: &quot;;</span></span><br><span class="line">    <span class="comment">// pFunc pRunGenInner = (pFunc)(*((long*)(*((long*)&amp;d + 2)) + 0));</span></span><br><span class="line">    <span class="comment">// (*pRunGenInner)(); //调用vfptr-base[0](函数地址值)指向的函数,内部生成函数无法运行</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[1] func ptr  is: &quot;</span> &lt;&lt;  (<span class="type">long</span>*)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>)) &lt;&lt; std::endl; <span class="comment">//vfptr-base[1]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase    = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase)(); <span class="comment">//调用vfptr-base[1](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">3</span> &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第4个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  single virtual  derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">-------<span class="attr">--begin</span> single virtual derive <span class="selector-tag">object</span> inner memory layout test-------</span><br><span class="line"> <span class="selector-tag">object</span> size is: <span class="number">32</span></span><br><span class="line"> <span class="selector-tag">object</span> addr is: <span class="number">0</span>x7ffe2ac9df60</span><br><span class="line"> <span class="built_in">typeid</span>(d) is: <span class="number">14</span>Derive_Sin_Vir</span><br><span class="line"> <span class="selector-tag">object</span> vfptr value is: <span class="number">0</span>x5580dd6a9878</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[0]</span> func ptr  is: <span class="number">0</span>x5580dd6a4e96</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[0]</span> func invoke res: Derive_Sin_Vir Class <span class="built_in">Run</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[1]</span> addr is: <span class="number">0</span>x5580dd6a4ede</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[1]</span> func invoke res: Derive_Sin_Vir Class <span class="built_in">RunDerive_Sin_Vir</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[2]</span> vptr  offset value is: <span class="number">0</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[3]</span> vbase offset value is: -<span class="number">16</span></span><br><span class="line"> <span class="selector-tag">object</span> _derive_sin_vir_var addr is: <span class="number">0</span>x7ffe2ac9df68</span><br><span class="line"> <span class="selector-tag">object</span> _derive_sin_vir_var value is: <span class="number">40</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base addr is: <span class="number">0</span>x7ffe2ac9df70</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base value is: <span class="number">0</span>x5580dd6a98a8</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[0]</span> func ptr  is: <span class="number">0</span>x5580dd6a4ed1</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[1]</span> func ptr  is: <span class="number">0</span>x5580dd6a4d62</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[1]</span> func invoke res: Base Class <span class="built_in">RunBase</span>()</span><br><span class="line"> <span class="selector-tag">object</span> _base_var addr is: <span class="number">0</span>x7ffe2ac9df78</span><br><span class="line"> <span class="selector-tag">object</span> _base_var value is: <span class="number">40</span></span><br><span class="line">-------<span class="attr">--end</span>  single virtual  derive  <span class="selector-tag">object</span> inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/06/25/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-3/sin_vir_layout.png" alt="single virtual derive"></p>
<h3 id="多虚拟继承的子类-Half"><a href="#多虚拟继承的子类-Half" class="headerlink" title="多虚拟继承的子类(Half)"></a>多虚拟继承的子类(Half)</h3><hr>
<h4 id="简单实现代码-1"><a href="#简单实现代码-1" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Multi Half Virtual Derive: Second Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive_Half_Mul_Vir</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base,  <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive_Half_Mul_Vir</span>(<span class="type">int</span> var = <span class="number">50</span>) : <span class="built_in">Base</span>(var), <span class="built_in">Base2</span>(var), _derive_half_mul_vir_var(var) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base::Run()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Half_Mul_Vir Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunBase2</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base2::RunBase2()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Half_Mul_Vir Class RunBase2()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunDerive_Half_Mul_Vir</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// new virtual function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Half_Mul_Vir Class RunDerive_Half_Mul_Vir()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _derive_half_mul_vir_var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc命令的内存布局-1"><a href="#Gcc命令的内存布局-1" class="headerlink" title="Gcc命令的内存布局"></a>Gcc命令的内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Derive_Half_Mul_Vir</span><br><span class="line">Derive_Half_Mul_Vir::_ZTV19Derive_Half_Mul_Vir: <span class="number">12</span> entries</span><br><span class="line"><span class="number">0</span>     <span class="number">16</span></span><br><span class="line"><span class="number">8</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">16    (int (*)</span>(...))(&amp; _ZTI19Derive_Half_Mul_Vir)</span><br><span class="line"><span class="number">24</span>    (int <span class="comment">(*)(...))Derive_Half_Mul_Vir::Run</span></span><br><span class="line"><span class="comment">32    (int (*)</span>(...))Derive_Half_Mul_Vir::RunBase2</span><br><span class="line"><span class="number">40</span>    (int <span class="comment">(*)(...))Derive_Half_Mul_Vir::RunDerive_Half_Mul_Vir</span></span><br><span class="line"><span class="comment">48    0</span></span><br><span class="line"><span class="comment">56    18446744073709551600</span></span><br><span class="line"><span class="comment">64    (int (*)</span>(...))-<span class="number">16</span></span><br><span class="line"><span class="number">72</span>    (int <span class="comment">(*)(...))(&amp; _ZTI19Derive_Half_Mul_Vir)</span></span><br><span class="line"><span class="comment">80    (int (*)</span>(...))Derive_Half_Mul_Vir::_ZTv0_n24_N19Derive_Half_Mul_Vir3RunEv</span><br><span class="line"><span class="number">88</span>    (int <span class="comment">(*)(...))Base::RunBase</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">VTT for Derive_Half_Mul_Vir</span></span><br><span class="line"><span class="comment">Derive_Half_Mul_Vir::_ZTT19Derive_Half_Mul_Vir: 2 entries</span></span><br><span class="line"><span class="comment">0     ((&amp; Derive_Half_Mul_Vir::_ZTV19Derive_Half_Mul_Vir) + 24)</span></span><br><span class="line"><span class="comment">8     ((&amp; Derive_Half_Mul_Vir::_ZTV19Derive_Half_Mul_Vir) + 80)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Class Derive_Half_Mul_Vir</span></span><br><span class="line"><span class="comment">   size=32 align=8</span></span><br><span class="line"><span class="comment">   base size=16 base align=8</span></span><br><span class="line"><span class="comment">Derive_Half_Mul_Vir (0x0x7fb40bf40af0) 0</span></span><br><span class="line"><span class="comment">    vptridx=0 vptr=((&amp; Derive_Half_Mul_Vir::_ZTV19Derive_Half_Mul_Vir) + 24)</span></span><br><span class="line"><span class="comment">  Base (0x0x7fb40bb61360) 16 virtual</span></span><br><span class="line"><span class="comment">      vptridx=8 vbaseoffset=-24 vptr=((&amp; Derive_Half_Mul_Vir::_ZTV19Derive_Half_Mul_Vir) + 80)</span></span><br><span class="line"><span class="comment">  Base2 (0x0x7fb40bb613c0) 0</span></span><br><span class="line"><span class="comment">      primary-for Derive_Half_Mul_Vir (0x0x7fb40bf40af0)</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到多虚拟继承的子类(Half)的内存空间特点是<strong>普通继承基类内存布局+子类自己的内存布局+虚基类的内存布局</strong>。普通继承基类的内存布局包括普通继承而来的基类虚函数表和普通继承基类的成员变量；子类自己内存布局包括继承而来的普通基类的虚函数表和子类的成员变量。子类的虚函数则是在<strong>普通继承而来的基类</strong>的虚函数表基础上进行新增、替换(override)、保持操作(没有override)，虚基类的内存布局包括虚基类表和虚基类成员变量。</p>
</blockquote>
<h4 id="内存布局的代码验证-1"><a href="#内存布局的代码验证-1" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HalfMultiVirtualDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive_Half_Mul_Vir d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin half multi virtual derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  derive(base2) vfptr地址 在对象第1个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase2 = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase2)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunDerive_Half_Mul_Vir = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>));</span><br><span class="line">    (*pRunDerive_Half_Mul_Vir)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[3] vptr  offset is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[3]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[4] vbase offset is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[4]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base2_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_base2_var 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base2_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_half_mul_vir_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//_derive_half_mul_vir_var 在对象第3个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_half_mul_vir_var value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">//  derive vfptr-base 地址 在对象第4个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[0] func ptr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl; <span class="comment">//  vbptr-base[0]</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; object vfptr-base[0] func invoke res: &quot;;</span></span><br><span class="line">    <span class="comment">// pFunc pRun = (pFunc)(*((long*)*((long*)&amp;d + 2)));</span></span><br><span class="line">    <span class="comment">// (*pRun)(); //调用vfptr-base[0](函数地址值)指向的函数,内部生成的函数无法调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[1] func ptr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// vbptr-base[1]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase = (pFunc)(*((<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase)(); <span class="comment">//调用vfptr-base[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">3</span> &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第5个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  half multi virtual  derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">-------<span class="attr">--begin</span> half multi virtual derive <span class="selector-tag">object</span> inner memory layout test-------</span><br><span class="line"> <span class="selector-tag">object</span> size is: <span class="number">32</span></span><br><span class="line"> <span class="selector-tag">object</span> addr is: <span class="number">0</span>x7ffdac1071e0</span><br><span class="line"> <span class="built_in">typeid</span>(d) is: <span class="number">19</span>Derive_Half_Mul_Vir</span><br><span class="line"> <span class="selector-tag">object</span> vfptr value is: <span class="number">0</span>x5595ce96e808</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[0]</span> func ptr  is: <span class="number">0</span>x5595ce969f80</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[0]</span> func invoke res: Derive_Half_Mul_Vir Class <span class="built_in">Run</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[1]</span> func ptr  is: <span class="number">0</span>x5595ce969fc8</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[1]</span> func invoke res: Derive_Half_Mul_Vir Class <span class="built_in">RunBase2</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[2]</span> func ptr  is: <span class="number">0</span>x5595ce96a004</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[2]</span> func invoke res: Derive_Half_Mul_Vir Class <span class="built_in">RunDerive_Half_Mul_Vir</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[3]</span> vptr  offset is: <span class="number">0</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[4]</span> vbase offset is: -<span class="number">16</span></span><br><span class="line"> <span class="selector-tag">object</span> _base2_var addr is: <span class="number">0</span>x7ffdac1071e8</span><br><span class="line"> <span class="selector-tag">object</span> _base2_var value is: <span class="number">50</span></span><br><span class="line"> <span class="selector-tag">object</span> _derive_half_mul_vir_var addr is: <span class="number">0</span>x7ffdac1071ec</span><br><span class="line"> <span class="selector-tag">object</span> _derive_half_mul_vir_var value is: <span class="number">50</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base addr is: <span class="number">0</span>x7ffdac1071f0</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base value is: <span class="number">0</span>x5595ce96e840</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[0]</span> func ptr is: <span class="number">0</span>x5595ce969fbb</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[1]</span> func ptr is: <span class="number">0</span>x5595ce969d62</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[1]</span> func invoke res: Base Class <span class="built_in">RunBase</span>()</span><br><span class="line"> <span class="selector-tag">object</span> _base_var addr is: <span class="number">0</span>x7ffdac1071f8</span><br><span class="line"> <span class="selector-tag">object</span> _base_var value is: <span class="number">50</span></span><br><span class="line">-------<span class="attr">--end</span>  half multi virtual  derive  <span class="selector-tag">object</span> inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/06/25/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-3/half_mul_vir_layout.png" alt="half multi virtual derive"></p>
<h3 id="多虚拟继承的子类-Both"><a href="#多虚拟继承的子类-Both" class="headerlink" title="多虚拟继承的子类(Both)"></a>多虚拟继承的子类(Both)</h3><hr>
<h4 id="简单实现代码-2"><a href="#简单实现代码-2" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Multi Both Virtual Derive: Second Inheritance Level</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive_Both_Mul_Vir</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base, <span class="keyword">virtual</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive_Both_Mul_Vir</span>(<span class="type">int</span> var = <span class="number">50</span>) : <span class="built_in">Base</span>(var), <span class="built_in">Base2</span>(var), _derive_both_mul_vir_var(var) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base::Run()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Both_Mul_Vir Class Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunBase2</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// override Base2::RunBase2()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Both_Mul_Vir Class RunBase2()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunDerive_Both_Mul_Vir</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// new virtual function</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive_Both_Mul_Vir Class RunDerive_Both_Mul_Vir()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _derive_both_mul_vir_var;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc命令的内存布局-2"><a href="#Gcc命令的内存布局-2" class="headerlink" title="Gcc命令的内存布局"></a>Gcc命令的内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Derive_Both_Mul_Vir</span><br><span class="line">Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir: <span class="number">19</span> entries</span><br><span class="line"><span class="number">0</span>     <span class="number">32</span></span><br><span class="line"><span class="number">8</span>     <span class="number">16</span></span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))(&amp; _ZTI19Derive_Both_Mul_Vir)</span><br><span class="line"><span class="number">32</span>    (int <span class="comment">(*)(...))Derive_Both_Mul_Vir::Run</span></span><br><span class="line"><span class="comment">40    (int (*)</span>(...))Derive_Both_Mul_Vir::RunBase2</span><br><span class="line"><span class="number">48</span>    (int <span class="comment">(*)(...))Derive_Both_Mul_Vir::RunDerive_Both_Mul_Vir</span></span><br><span class="line"><span class="comment">56    0</span></span><br><span class="line"><span class="comment">64    18446744073709551600</span></span><br><span class="line"><span class="comment">72    (int (*)</span>(...))-<span class="number">16</span></span><br><span class="line"><span class="number">80</span>    (int <span class="comment">(*)(...))(&amp; _ZTI19Derive_Both_Mul_Vir)</span></span><br><span class="line"><span class="comment">88    (int (*)</span>(...))Derive_Both_Mul_Vir::_ZTv0_n24_N19Derive_Both_Mul_Vir3RunEv</span><br><span class="line"><span class="number">96</span>    (int <span class="comment">(*)(...))Base::RunBase</span></span><br><span class="line"><span class="comment">104   18446744073709551584</span></span><br><span class="line"><span class="comment">112   18446744073709551584</span></span><br><span class="line"><span class="comment">120   (int (*)</span>(...))-<span class="number">32</span></span><br><span class="line"><span class="number">128</span>   (int <span class="comment">(*)(...))(&amp; _ZTI19Derive_Both_Mul_Vir)</span></span><br><span class="line"><span class="comment">136   (int (*)</span>(...))Derive_Both_Mul_Vir::_ZTv0_n24_N19Derive_Both_Mul_Vir3RunEv</span><br><span class="line"><span class="number">144</span>   (int <span class="comment">(*)(...))Derive_Both_Mul_Vir::_ZTv0_n32_N19Derive_Both_Mul_Vir8RunBase2Ev</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">VTT for Derive_Both_Mul_Vir</span></span><br><span class="line"><span class="comment">Derive_Both_Mul_Vir::_ZTT19Derive_Both_Mul_Vir: 3 entries</span></span><br><span class="line"><span class="comment">0     ((&amp; Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir) + 32)</span></span><br><span class="line"><span class="comment">8     ((&amp; Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir) + 88)</span></span><br><span class="line"><span class="comment">16    ((&amp; Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir) + 136)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Class Derive_Both_Mul_Vir</span></span><br><span class="line"><span class="comment">   size=48 align=8</span></span><br><span class="line"><span class="comment">   base size=12 base align=8</span></span><br><span class="line"><span class="comment">Derive_Both_Mul_Vir (0x0x7fb40bf40b60) 0</span></span><br><span class="line"><span class="comment">    vptridx=0 vptr=((&amp; Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir) + 32)</span></span><br><span class="line"><span class="comment">  Base (0x0x7fb40bb61de0) 16 virtual</span></span><br><span class="line"><span class="comment">      vptridx=8 vbaseoffset=-24 vptr=((&amp; Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir) + 88)</span></span><br><span class="line"><span class="comment">  Base2 (0x0x7fb40bb61e40) 32 virtual</span></span><br><span class="line"><span class="comment">      vptridx=16 vbaseoffset=-32 vptr=((&amp; Derive_Both_Mul_Vir::_ZTV19Derive_Both_Mul_Vir) + 136)</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到多虚拟继承的子类(Both)的内存空间特点是**子类自己的内存布局+虚基类的内存布局+虚基类2的内存布局+…**。子类自己的内存布局包括自己生成的虚函数表和子类的成员变量；虚基类的内存布局包括基类的虚函数表和基类的成员变量。子类的新增或重写的虚函数是在自己生成的虚函数表中的；而虚基类中未被重写的虚函数则是在继承而来的相应基类的虚函数表中。</p>
</blockquote>
<h4 id="内存布局的代码验证-2"><a href="#内存布局的代码验证-2" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BothMultiVirtualDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive_Both_Mul_Vir d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin both multi virtual derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  derive vfptr地址 在对象第1个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase2 = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase2)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunDeriveBothMulVir = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>));</span><br><span class="line">    (*pRunDeriveBothMulVir)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[3] vptr  offset is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[3]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr[4] vbase offset is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[4]的值 </span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_both_mul_vir_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_derive_both_mul_vir_var 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _derive_both_mul_vir_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">//  derive vfptr-base 地址 在对象第3个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[0] func ptr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl; <span class="comment">//  vfptr-base[0]</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; object vfptr-base[0] func invoke res: &quot;;</span></span><br><span class="line">    <span class="comment">// pFunc pRun = (pFunc)(*(long*)(*((long*)&amp;d + 2)));</span></span><br><span class="line">    <span class="comment">// (*pRun)(); //调用vfptr[0](函数地址值)指向的函数,自动生成的函数无法调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[1] func ptr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr-base[1]</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunBase = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>));</span><br><span class="line">    (*pRunBase)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">3</span> &lt;&lt; std::endl; <span class="comment">//_base_var 在对象第4个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base2 addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">4</span> &lt;&lt; std::endl; <span class="comment">//  derive vfptr-base 地址 在对象第5个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base2 value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>)) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base2[0] func ptr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>)) &lt;&lt; std::endl; <span class="comment">//  vfptr-base2[0]</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; object vfptr-base2[0] func invoke res: &quot;;</span></span><br><span class="line">    <span class="comment">// pFunc pRunGen1 = (pFunc)(*(long*)(*((long*)&amp;d + 4)));</span></span><br><span class="line">    <span class="comment">// (*pRun)(); //调用vfptr[0](函数地址值)指向的函数,自动生成的函数无法调用</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object vfptr-base2[1] func ptr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>)) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr-base2[1]</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; object vfptr-base2[1] func invoke res: &quot;;</span></span><br><span class="line">    <span class="comment">// pFunc pRunGeGen2 = (pFunc)(*((long*)(*((long*)&amp;d + 4)) + 1));</span></span><br><span class="line">    <span class="comment">// (*pRunGen2)(); Gen2调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base2_var addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">5</span> &lt;&lt; std::endl; <span class="comment">//_base2_var 在对象第6个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _base2_var value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  both multi virtual  derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">-------<span class="attr">--begin</span> both multi virtual derive <span class="selector-tag">object</span> inner memory layout test-------</span><br><span class="line"> <span class="selector-tag">object</span> size is: <span class="number">48</span></span><br><span class="line"> <span class="selector-tag">object</span> addr is: <span class="number">0</span>x7ffdf308a520</span><br><span class="line"> <span class="built_in">typeid</span>(d) is: <span class="number">19</span>Derive_Both_Mul_Vir</span><br><span class="line"> <span class="selector-tag">object</span> vfptr addr is: <span class="number">0</span>x55dbd6a85760</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[0]</span> func ptr  is: <span class="number">0</span>x55dbd6a810bc</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[0]</span> func invoke res: Derive_Both_Mul_Vir Class <span class="built_in">Run</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[1]</span> func ptr  is: <span class="number">0</span>x55dbd6a81104</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[1]</span> func invoke res: Derive_Both_Mul_Vir Class <span class="built_in">RunBase2</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[2]</span> func ptr  is: <span class="number">0</span>x55dbd6a8114c</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[2]</span> func invoke res: Derive_Both_Mul_Vir Class <span class="built_in">RunDerive_Both_Mul_Vir</span>()</span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[3]</span> vptr  offset is: <span class="number">0</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr<span class="selector-attr">[4]</span> vbase offset is: -<span class="number">16</span></span><br><span class="line"> <span class="selector-tag">object</span> _derive_both_mul_vir_var addr is: <span class="number">0</span>x7ffdf308a528</span><br><span class="line"> <span class="selector-tag">object</span> _derive_both_mul_vir_var value is: <span class="number">50</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base addr is: <span class="number">0</span>x7ffdf308a530</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base value is: <span class="number">0</span>x55dbd6a85798</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[0]</span> func ptr is: <span class="number">0</span>x55dbd6a810f7</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[1]</span> func ptr is: <span class="number">0</span>x55dbd6a80d62</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base<span class="selector-attr">[1]</span> func invoke res: Base Class <span class="built_in">RunBase</span>()</span><br><span class="line"> <span class="selector-tag">object</span> _base_var addr is: <span class="number">0</span>x7ffdf308a538</span><br><span class="line"> <span class="selector-tag">object</span> _base_var value is: <span class="number">50</span></span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base2 addr is: <span class="number">0</span>x7ffdf308a540</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base2 value is: <span class="number">0</span>x55dbd6a857c8</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base2<span class="selector-attr">[0]</span> func ptr is: <span class="number">0</span>x55dbd6a810f7</span><br><span class="line"> <span class="selector-tag">object</span> vfptr-base2<span class="selector-attr">[1]</span> func ptr is: <span class="number">0</span>x55dbd6a8113f</span><br><span class="line"> <span class="selector-tag">object</span> _base2_var addr is: <span class="number">0</span>x7ffdf308a548</span><br><span class="line"> <span class="selector-tag">object</span> _base2_var value is: <span class="number">50</span></span><br><span class="line">-------<span class="attr">--end</span>  both multi virtual  derive  <span class="selector-tag">object</span> inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/06/25/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-3/both_mul_vir_layout.png" alt="both multi virtual derive"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>本篇主要介绍了C++类在虚拟继承下的子类对象内存特点，可以看出，子类新建的或普通继承而来的虚表中存放着子类的虚函数和表偏移值；对于纯虚继承，即所有基类均是虚拟继承（包括但不限于单虚拟继承）来说，子类对象中的新增的虚函数均是在自己生成的新虚函数表中进行操作的（若子类没有新增的虚函数或重写则不需要生成）。而对于不纯情况，子类会类似于前一篇描述的普通继承情况，使用普通继承而来的基类的虚函数表，而不会自己生成。可见，虚拟继承体系下通常情况下会存在多张虚函数表（子类普通继承而来的和某些情况下自己新生成的）。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Object Model</tag>
      </tags>
  </entry>
  <entry>
    <title>C++构造函数拷贝构造函数及赋值拷贝函数</title>
    <url>/2021/05/01/C++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E8%B5%8B%E5%80%BC%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在C++面试过程中，一个常考的题目就是<strong>实现一个类似于String类功能的字符串类</strong>，这道题目看似简单，其实如果一不小心就会踩到坑。完整的写出包括普通构造函数、拷贝构造函数及赋值拷贝函数的字符串类其实也不简单，但是能看出一个C++码字者的基本功。本篇就简单实现这个字符串类功能，并延伸对C++构造、拷贝构造和赋值拷贝函数的一些总结</p>
<span id="more"></span>

<h2 id="一道实现String类的C-面试题"><a href="#一道实现String类的C-面试题" class="headerlink" title="一道实现String类的C++面试题"></a>一道实现String类的C++面试题</h2><hr>
<p>题目大致为：<br>实现一个自定义的字符串类，类似于String类，包括一般构造函数、拷贝构造函数及赋值拷贝函数</p>
<h3 id="标准代码实现"><a href="#标准代码实现" class="headerlink" title="标准代码实现"></a>标准代码实现</h3><hr>
<p>标准实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">myString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == str)</span><br><span class="line">        &#123;</span><br><span class="line">            _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            _str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>]; <span class="comment">// strlen不包括\0 需要+1</span></span><br><span class="line">            <span class="built_in">strcpy</span>(_str, str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">myString</span>(<span class="type">const</span> myString &amp;other) <span class="comment">// 必须为引用，否则会编译失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == other._str)</span><br><span class="line">        &#123;</span><br><span class="line">            _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">            _str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other._str) + <span class="number">1</span>]; <span class="comment">// strlen不包括\0 需要+1</span></span><br><span class="line">            <span class="built_in">strcpy</span>(_str, other._str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作符重载</span></span><br><span class="line">    myString&amp; <span class="keyword">operator</span> = (<span class="type">const</span> myString &amp;other) <span class="comment">// 返回引用，便于链式表达</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// stardard solution:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// firstly: check self assignment</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// secondly: delete origin memory</span></span><br><span class="line">        <span class="keyword">delete</span> _str;</span><br><span class="line">        _str = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thirdly: new memory and  copy other&#x27;s _str var to new memory</span></span><br><span class="line">        _str = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other._str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(_str, other._str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//forth: return this pointer</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myString</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != _str)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(_str);</span><br><span class="line">            _str = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// for test to observe</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; _str &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *_str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面有几个坑容易踩到：</p>
<ol>
<li>分配内存时候要 <strong>考虑传入<code>char*</code>指针参数参数为空情况</strong>且分配内存时候注意<code>strlen</code>函数的长度不包括<code>\0</code></li>
<li>对于构造函数、拷贝构造函数及赋值构造函数，由于我们一般不会改变入参指针或引用值，<strong>最好前面加<code>const</code>关键字限制</strong></li>
<li>对于拷贝构造函数 <strong>一定要传递引用类型</strong>，不然会出错，因为如果不传引用传值的话，对于参数为传值类型的函数，会执行一次参数的拷贝会调用本身的拷贝构造函数，因为实际函数体使用的是实参的副本，而同时，该函数本身又是拷贝构造函数，导致无限的递归下去，函数的堆栈空间溢出</li>
<li>对于赋值拷贝函数 <strong>最好传递引用类型</strong>，虽然不会像拷贝构造函数那样无限递归，但是有函数参数对象的拷贝动作，空间和时间效率上都有所下降，同时 <strong>应该返回对象的引用</strong>，便于赋值拷贝运算符<code>=</code>的链式表达</li>
<li>对于赋值拷贝函数，还需要 <strong>考虑自赋值的情况</strong></li>
</ol>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><hr>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">    myString str1;        <span class="regexp">//</span> 一般的默认NULL参数的构造函数</span><br><span class="line">    myString str2(<span class="string">&quot;tly&quot;</span>); <span class="regexp">//</span> 一般的自定义传参的构造函数</span><br><span class="line">    myString str3(str2);  <span class="regexp">//</span> 一般的拷贝构造函数</span><br><span class="line">    myString str4, str5;</span><br><span class="line">    str3 = str3;         <span class="regexp">//</span> 自赋值的赋值拷贝函数</span><br><span class="line">    str5 = str4 = str3; <span class="regexp">//</span>  赋值拷贝函数的链式表达</span><br><span class="line"></span><br><span class="line">    str1.print();</span><br><span class="line">    str2.print();</span><br><span class="line">    str3.print();</span><br><span class="line">    str4.print();   </span><br><span class="line">    str5.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><hr>
<pre><code>    此行为空输出 
    tly
    tly
    tly
    tly   
</code></pre>
<blockquote>
<p>可以看出三个函数均能正常的工作且支持自赋值和赋值的链式表达</p>
</blockquote>
<h3 id="改进1：赋值拷贝函数增加代码的健壮性"><a href="#改进1：赋值拷贝函数增加代码的健壮性" class="headerlink" title="改进1：赋值拷贝函数增加代码的健壮性"></a>改进1：赋值拷贝函数增加代码的健壮性</h3><hr>
<p>对于拷贝构造函数，标准的实现下分为以下几步：</p>
<ol>
<li>检查自赋值</li>
<li>释放成员指针变量指向的旧的内存空间</li>
<li>申请函数参数传入的对象大小的内存空间给成员指针变量并拷贝</li>
<li>返回<code>*this</code></li>
</ol>
<p>对于标准实现，考虑到代码的健壮性，里面有动态分配内存的情况，万一申请内存失败了咋整？如果考虑此种情况的话，实现的顺序需要稍作调整了，代码如下实现：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作符重载</span></span><br><span class="line">    myString&amp; operator = (const myString &amp;other) <span class="comment">// 返回引用，便于链式表达</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// solution 2: consider safety</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// firstly: check self assignment</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == &amp;other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// secondly: new memory</span></span><br><span class="line">        char *<span class="keyword">new</span><span class="type">Buffer</span> = NULL;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Buffer</span> = <span class="keyword">new</span><span class="type"></span>(std:<span class="type"></span>:nothrow) char[strlen(other._str) + <span class="number">1</span>]; <span class="comment">// no throw bad_alloc</span></span><br><span class="line">        <span class="keyword">if</span> (NULL == <span class="keyword">new</span><span class="type">Buffer</span>) <span class="comment">// 分配失败处理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thirdly: copy to new buffer and then delete origin memory and assign to _str</span></span><br><span class="line">        strcpy(<span class="keyword">new</span><span class="type">Buffer</span>, other._str);</span><br><span class="line">        delete _str;</span><br><span class="line">        _str = <span class="keyword">new</span><span class="type">Buffer</span>; <span class="comment">// first copy to new buffer then assign to _str; on the contrary will failed!!!</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//forth: return this pointer</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此处为了简化不使用<code>try-catch</code>捕捉<code>bad_alloc</code>异常，在<code>new</code>的时候使用了<code>std::nothrow</code>参数以方便分别失败时候的<code>NULL</code>判断<br>为了保证对象的完整性，先申请新指针成员指向的内存，因为申请失败后可以直接返回原对象(指针成员被释放之前对象是完整的)，否则再释放对象的指针成员指向的内存</p>
</blockquote>
<h3 id="改进2：赋值拷贝函数使用临时对象交换内存空间实现"><a href="#改进2：赋值拷贝函数使用临时对象交换内存空间实现" class="headerlink" title="改进2：赋值拷贝函数使用临时对象交换内存空间实现"></a>改进2：赋值拷贝函数使用临时对象交换内存空间实现</h3><hr>
<p>对于赋值拷贝函数，标准做法有释放和申请动态内存的操作，一种比较巧妙的方法是通过交换指针成员的指向来实现，这样可以避免手动的操作内存，代码实现如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 操作符重载</span><br><span class="line">    myString&amp; operator = (const myString &amp;other) <span class="regexp">//</span> 返回引用，便于链式表达</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">//</span> solution <span class="number">3</span>: swap _st<span class="string">r&#x27;s pointing memory space</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        if (this != &amp;other)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            // firstly: construct a tmp object by copy construction</span></span><br><span class="line"><span class="string">            myString strTemp(other); </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            // secondly: swap _str pointer&#x27;</span>s pointing memory space with strTemp object</span><br><span class="line">            char *p = NULL;</span><br><span class="line">            p = strTemp._str;</span><br><span class="line">            strTemp._str = _str;</span><br><span class="line">            _str = p;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="regexp">//</span> thirdly:  strTemp<span class="string">&#x27;s memory space(point to _str&#x27;</span>s origin memory space) free automatically and return this pointer</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此方法主要使用了拷贝构造函数和临时局部对象在函数返回会自动释放内存的原理实现的(由于指针指向的内存交换了，实际上释放的是指针成员原来指向的内存空间)</p>
</blockquote>
<h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><table>
<thead>
<tr>
<th align="center">函数类型</th>
<th align="center">是否有新对象产生</th>
<th align="center">是否有深拷贝浅拷贝问题</th>
<th align="center">参数是否必须为引用</th>
<th align="center">执行时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">普通构造函数</td>
<td align="center">有</td>
<td align="center">无，直接构造无拷贝过程</td>
<td align="center">不必</td>
<td align="center">new或直接定义</td>
</tr>
<tr>
<td align="center">拷贝构造函数</td>
<td align="center">有</td>
<td align="center">有</td>
<td align="center">必须</td>
<td align="center">直接定义调用或函数入参对象传值或返回临时对象</td>
</tr>
<tr>
<td align="center">赋值拷贝函数</td>
<td align="center">无，只是对象内成员变量拷贝</td>
<td align="center">有</td>
<td align="center">最好是</td>
<td align="center">直接调用</td>
</tr>
</tbody></table>
<blockquote>
<p>1.这三个函数如果任意一个用户没有实现的时候，编译器在 <strong>需要的时候</strong>都会自动生成一个相应的函数，但是对于拷贝构造和赋值拷贝函数都是浅拷贝，如果涉及到操作指针成员最好 <strong>自己重写两个函数</strong>，否则在对象析构时候会对指针成员指向内存释放两次，如果被拷贝的指针成员以前指向的内存不为空还会出现内存泄漏问题<br>2.这三个函数都可以存在多个，即可以参数不同可以重载多个</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++对象模型-4</title>
    <url>/2021/07/02/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>前两篇主要介绍了C++对象在一级继承体系下的对象模型，接下来将考虑二级继承体系下常用的菱形继承对象模型的影响和变化，主要包括普通菱形继承和虚拟菱形继承</p>
<span id="more"></span>

<h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><hr>
<h3 id="普通菱形继承类"><a href="#普通菱形继承类" class="headerlink" title="普通菱形继承类"></a>普通菱形继承类</h3><hr>
<h4 id="公共基类简单实现代码"><a href="#公共基类简单实现代码" class="headerlink" title="公共基类简单实现代码"></a>公共基类简单实现代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> var = <span class="number">10</span>): _b(var)&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RunB</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B RunB()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h4 id="普通菱形继承类简单实现代码"><a href="#普通菱形继承类简单实现代码" class="headerlink" title="普通菱形继承类简单实现代码"></a>普通菱形继承类简单实现代码</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> D1 : public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">D1(<span class="params">int</span> <span class="params">var</span> = 20)</span>: <span class="constructor">B(<span class="params">var</span>)</span>,<span class="constructor">_d1(<span class="params">var</span>)</span> &#123;&#125;;</span><br><span class="line">    ~<span class="constructor">D1()</span> &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(<span class="params">void</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D1 Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RunD1(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D1 RunD1()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _d1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D2 : public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">D2(<span class="params">int</span> <span class="params">var</span> = 20)</span> : <span class="constructor">B(<span class="params">var</span>)</span>, <span class="constructor">_d2(<span class="params">var</span>)</span> &#123;&#125;;</span><br><span class="line">    ~<span class="constructor">D2()</span> &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D2 Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RunD2(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D2 RunD2()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhombus : public D1, public D2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Rhombus(<span class="params">int</span> <span class="params">var</span> = 30)</span> : <span class="constructor">D1(<span class="params">var</span>)</span>, <span class="constructor">D2(<span class="params">var</span>)</span>, <span class="constructor">_rhombus(<span class="params">var</span>)</span> &#123;&#125;;</span><br><span class="line">    ~<span class="constructor">Rhombus()</span> &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rhombus Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RunRhombus(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rhombus RunRhombus()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _rhombus;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc命令的内存布局"><a href="#Gcc命令的内存布局" class="headerlink" title="Gcc命令的内存布局"></a>Gcc命令的内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Rhombus</span><br><span class="line">Rhombus::_ZTV7Rhombus: <span class="number">11</span> entries</span><br><span class="line"><span class="number">0</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">8     (int (*)</span>(...))(&amp; _ZTI7Rhombus)</span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))Rhombus::Run</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))B::RunB</span><br><span class="line"><span class="number">32</span>    (int <span class="comment">(*)(...))D1::RunD1</span></span><br><span class="line"><span class="comment">40    (int (*)</span>(...))Rhombus::RunRhombus</span><br><span class="line"><span class="number">48</span>    (int <span class="comment">(*)(...))-16</span></span><br><span class="line"><span class="comment">56    (int (*)</span>(...))(&amp; _ZTI7Rhombus)</span><br><span class="line"><span class="number">64</span>    (int <span class="comment">(*)(...))Rhombus::_ZThn16_N7Rhombus3RunEv</span></span><br><span class="line"><span class="comment">72    (int (*)</span>(...))B::RunB</span><br><span class="line"><span class="number">80</span>    (int <span class="comment">(*)(...))D2::RunD2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Class Rhombus</span></span><br><span class="line"><span class="comment">   size=40 align=8</span></span><br><span class="line"><span class="comment">   base size=36 base align=8</span></span><br><span class="line"><span class="comment">Rhombus (0x0x7fb760cebaf0) 0</span></span><br><span class="line"><span class="comment">    vptr=((&amp; Rhombus::_ZTV7Rhombus) + 16)</span></span><br><span class="line"><span class="comment">  D1 (0x0x7fb760844c98) 0</span></span><br><span class="line"><span class="comment">      primary-for Rhombus (0x0x7fb760cebaf0)</span></span><br><span class="line"><span class="comment">    B (0x0x7fb76088d2a0) 0</span></span><br><span class="line"><span class="comment">        primary-for D1 (0x0x7fb760844c98)</span></span><br><span class="line"><span class="comment">  D2 (0x0x7fb760844d00) 16</span></span><br><span class="line"><span class="comment">      vptr=((&amp; Rhombus::_ZTV7Rhombus) + 64)</span></span><br><span class="line"><span class="comment">    B (0x0x7fb76088d300) 16</span></span><br><span class="line"><span class="comment">        primary-for D2 (0x0x7fb760844d00)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到普通菱形继承类的内存空间特点是<strong>基类Di的内存布局(按照继承的顺序依次布局基类)+子类的成员变量</strong>，基类Di的内存布局包括公共基类B的内存布局和基类Di的成员变量。子类的虚函数在继承而来的<strong>第一个继承的Di基类</strong>的虚函数表基础上进行替换（override），新增子类（新的虚函数），保持操作（没有override）。可以看到普通菱形继承内存中存在多份公共基类B的结构，这样存在二义性的问题，如对于Rhombus类调用Run方法，由于两个子类D1，D2都重写了，且都继承来了，不知道调用哪个子类的方法</p>
</blockquote>
<h4 id="内存布局的代码验证"><a href="#内存布局的代码验证" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RhombusCommonDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rhombus d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin rhombus common derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d1 obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  d1 vfptr地址 在对象第1个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunB = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>));</span><br><span class="line">    (*pRunB)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunD1 = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>));</span><br><span class="line">    (*pRunD1)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[3] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[3]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[3] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunRhombus = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">3</span>));</span><br><span class="line">    (*pRunRhombus)(); <span class="comment">//调用vfptr[3](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _b addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//_b 在对象第2个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _b value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d1 addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//_d1 在对象第3个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d1 value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) + <span class="number">1</span>)&lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d1 obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d2 obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//  d2 vfptr地址 在对象第4个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun2 = (pFunc)(*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)));</span><br><span class="line">    (*pRun2)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunB2 = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>));</span><br><span class="line">    (*pRunB2)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunD2 = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">2</span>));</span><br><span class="line">    (*pRunD2)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _b addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">3</span> &lt;&lt; std::endl; <span class="comment">//_b 在对象第5个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _b value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d2 addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//_base2_var 在对象第6个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d2 value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) + <span class="number">1</span>)&lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d2 obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _rhombus addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">4</span> &lt;&lt; std::endl; <span class="comment">//_rhombus 在对象第7个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _rhombus value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  rhombus common derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">---------begin rhombus common derive object inner memory layout test-------</span><br><span class="line"> object size is: 40</span><br><span class="line"> object addr is: 0x7fff8b599920</span><br><span class="line"> typeid(d) is: 7Rhombus</span><br><span class="line">------ d1 obj begin -----</span><br><span class="line"> object d1 vfptr addr is: 0x563b8f869a88</span><br><span class="line"> object d1 vfptr[0] func ptr  is: 0x563b8f86489c</span><br><span class="line"> object d1 vfptr[0] func<span class="built_in"> invoke </span>res: Rhombus Run()</span><br><span class="line"> object d1 vfptr[1] func ptr  is: 0x563b8f8645e4</span><br><span class="line"> object d1 vfptr[1] func<span class="built_in"> invoke </span>res: B RunB()</span><br><span class="line"> object d1 vfptr[2] func ptr  is: 0x563b8f8646ca</span><br><span class="line"> object d1 vfptr[2] func<span class="built_in"> invoke </span>res: D1 RunD1()</span><br><span class="line"> object d1 vfptr[3] func ptr  is: 0x563b8f8648e2</span><br><span class="line"> object d1 vfptr[3] func<span class="built_in"> invoke </span>res: Rhombus RunRhombus()</span><br><span class="line"> object _b addr is: 0x7fff8b599928</span><br><span class="line"> object _b value is: 30</span><br><span class="line"> object _d1 addr is: 0x7fff8b59992c</span><br><span class="line"> object _d1 value is: 30</span><br><span class="line">------ d1 obj end -----</span><br><span class="line">------ d2 obj begin -----</span><br><span class="line"> object d2 vfptr addr is: 0x563b8f869ab8</span><br><span class="line"> object d2 vfptr[0] func ptr  is: 0x563b8f8648d7</span><br><span class="line"> object d2 vfptr[0] func<span class="built_in"> invoke </span>res: Rhombus Run()</span><br><span class="line"> object d2 vfptr[1] func ptr  is: 0x563b8f8645e4</span><br><span class="line"> object d2 vfptr[1] func<span class="built_in"> invoke </span>res: B RunB()</span><br><span class="line"> object d2 vfptr[2] func ptr  is: 0x563b8f8647b0</span><br><span class="line"> object d2 vfptr[2] func<span class="built_in"> invoke </span>res: D2 RunD2()</span><br><span class="line"> object _b addr is: 0x7fff8b599938</span><br><span class="line"> object _b value is: 30</span><br><span class="line"> object _d2 addr is: 0x7fff8b59993c</span><br><span class="line"> object _d2 value is: 30</span><br><span class="line">------ d2 obj end -----</span><br><span class="line"> object _rhombus addr is: 0x7fff8b599940</span><br><span class="line"> object _rhombus value is: 30</span><br><span class="line">---------end  rhombus common derive  object inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/07/02/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-4/rhombus_com_layout.png" alt="rhombus common derive"></p>
<h3 id="虚拟菱形继承类"><a href="#虚拟菱形继承类" class="headerlink" title="虚拟菱形继承类"></a>虚拟菱形继承类</h3><hr>
<h4 id="简单实现代码"><a href="#简单实现代码" class="headerlink" title="简单实现代码"></a>简单实现代码</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> D1_Virtual : <span class="keyword">virtual</span> public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">D1_Virtual(<span class="params">int</span> <span class="params">var</span> = 20)</span> : <span class="constructor">B(<span class="params">var</span>)</span>, <span class="constructor">_d1_virtual(<span class="params">var</span>)</span> &#123;&#125;;</span><br><span class="line">    ~<span class="constructor">D1_Virtual()</span> &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D1_Virtual Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RunD1_Virtual(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D1_Virtual RunD1_Virtual()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _d1_virtual;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> D2_Virtual : <span class="keyword">virtual</span> public B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">D2_Virtual(<span class="params">int</span> <span class="params">var</span> = 20)</span> : <span class="constructor">B(<span class="params">var</span>)</span>, <span class="constructor">_d2_virtual(<span class="params">var</span>)</span> &#123;&#125;;</span><br><span class="line">    ~<span class="constructor">D2_Virtual()</span> &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D2_Virtual Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RunD2_Virtual(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;D2_Virtual RunD2_Virtual()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _d2_virtual;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhombus_Virtual : public D1_Virtual, public D2_Virtual</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Rhombus_Virtual(<span class="params">int</span> <span class="params">var</span> = 30)</span> : <span class="constructor">D1_Virtual(<span class="params">var</span>)</span>, <span class="constructor">D2_Virtual(<span class="params">var</span>)</span>, <span class="constructor">_rhombus_virtual(<span class="params">var</span>)</span> &#123;&#125;;</span><br><span class="line">    ~<span class="constructor">Rhombus_Virtual()</span> &#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rhombus_Virtual Run()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RunRhombus_Virtual(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rhombus_Virtual RunRhombus_Virtual()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> _rhombus_virtual;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Gcc命令的内存布局-1"><a href="#Gcc命令的内存布局-1" class="headerlink" title="Gcc命令的内存布局"></a>Gcc命令的内存布局</h4><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">Vtable <span class="keyword">for</span> Rhombus_Virtual</span><br><span class="line">Rhombus_Virtual::_ZTV15Rhombus_Virtual: <span class="number">17</span> entries</span><br><span class="line"><span class="number">0</span>     <span class="number">32</span></span><br><span class="line"><span class="number">8</span>     (int <span class="comment">(*)(...))0</span></span><br><span class="line"><span class="comment">16    (int (*)</span>(...))(&amp; _ZTI15Rhombus_Virtual)</span><br><span class="line"><span class="number">24</span>    (int <span class="comment">(*)(...))Rhombus_Virtual::Run</span></span><br><span class="line"><span class="comment">32    (int (*)</span>(...))D1_Virtual::RunD1_Virtual</span><br><span class="line"><span class="number">40</span>    (int <span class="comment">(*)(...))Rhombus_Virtual::RunRhombus_Virtual</span></span><br><span class="line"><span class="comment">48    16</span></span><br><span class="line"><span class="comment">56    (int (*)</span>(...))-<span class="number">16</span></span><br><span class="line"><span class="number">64</span>    (int <span class="comment">(*)(...))(&amp; _ZTI15Rhombus_Virtual)</span></span><br><span class="line"><span class="comment">72    (int (*)</span>(...))Rhombus_Virtual::_ZThn16_N15Rhombus_Virtual3RunEv</span><br><span class="line"><span class="number">80</span>    (int <span class="comment">(*)(...))D2_Virtual::RunD2_Virtual</span></span><br><span class="line"><span class="comment">88    0</span></span><br><span class="line"><span class="comment">96    18446744073709551584</span></span><br><span class="line"><span class="comment">104   (int (*)</span>(...))-<span class="number">32</span></span><br><span class="line"><span class="number">112</span>   (int <span class="comment">(*)(...))(&amp; _ZTI15Rhombus_Virtual)</span></span><br><span class="line"><span class="comment">120   (int (*)</span>(...))Rhombus_Virtual::_ZTv0_n24_N15Rhombus_Virtual3RunEv</span><br><span class="line"><span class="number">128</span>   (int <span class="comment">(*)(...))B::RunB</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Construction vtable for D1_Virtual (0x0x7fb7608afdd0 instance) in Rhombus_Virtual</span></span><br><span class="line"><span class="comment">Rhombus_Virtual::_ZTC15Rhombus_Virtual0_10D1_Virtual: 11 entries</span></span><br><span class="line"><span class="comment">0     32</span></span><br><span class="line"><span class="comment">8     (int (*)</span>(...))<span class="number">0</span></span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))(&amp; _ZTI10D1_Virtual)</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))D1_Virtual::Run</span><br><span class="line"><span class="number">32</span>    (int <span class="comment">(*)(...))D1_Virtual::RunD1_Virtual</span></span><br><span class="line"><span class="comment">40    0</span></span><br><span class="line"><span class="comment">48    18446744073709551584</span></span><br><span class="line"><span class="comment">56    (int (*)</span>(...))-<span class="number">32</span></span><br><span class="line"><span class="number">64</span>    (int <span class="comment">(*)(...))(&amp; _ZTI10D1_Virtual)</span></span><br><span class="line"><span class="comment">72    (int (*)</span>(...))D1_Virtual::_ZTv0_n24_N10D1_Virtual3RunEv</span><br><span class="line"><span class="number">80</span>    (int <span class="comment">(*)(...))B::RunB</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Construction vtable for D2_Virtual (0x0x7fb7608aff70 instance) in Rhombus_Virtual</span></span><br><span class="line"><span class="comment">Rhombus_Virtual::_ZTC15Rhombus_Virtual16_10D2_Virtual: 11 entries</span></span><br><span class="line"><span class="comment">0     16</span></span><br><span class="line"><span class="comment">8     (int (*)</span>(...))<span class="number">0</span></span><br><span class="line"><span class="number">16</span>    (int <span class="comment">(*)(...))(&amp; _ZTI10D2_Virtual)</span></span><br><span class="line"><span class="comment">24    (int (*)</span>(...))D2_Virtual::Run</span><br><span class="line"><span class="number">32</span>    (int <span class="comment">(*)(...))D2_Virtual::RunD2_Virtual</span></span><br><span class="line"><span class="comment">40    0</span></span><br><span class="line"><span class="comment">48    18446744073709551600</span></span><br><span class="line"><span class="comment">56    (int (*)</span>(...))-<span class="number">16</span></span><br><span class="line"><span class="number">64</span>    (int <span class="comment">(*)(...))(&amp; _ZTI10D2_Virtual)</span></span><br><span class="line"><span class="comment">72    (int (*)</span>(...))D2_Virtual::_ZTv0_n24_N10D2_Virtual3RunEv</span><br><span class="line"><span class="number">80</span>    (int <span class="comment">(*)(...))B::RunB</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">VTT for Rhombus_Virtual</span></span><br><span class="line"><span class="comment">Rhombus_Virtual::_ZTT15Rhombus_Virtual: 7 entries</span></span><br><span class="line"><span class="comment">0     ((&amp; Rhombus_Virtual::_ZTV15Rhombus_Virtual) + 24)</span></span><br><span class="line"><span class="comment">8     ((&amp; Rhombus_Virtual::_ZTC15Rhombus_Virtual0_10D1_Virtual) + 24)</span></span><br><span class="line"><span class="comment">16    ((&amp; Rhombus_Virtual::_ZTC15Rhombus_Virtual0_10D1_Virtual) + 72)</span></span><br><span class="line"><span class="comment">24    ((&amp; Rhombus_Virtual::_ZTC15Rhombus_Virtual16_10D2_Virtual) + 24)</span></span><br><span class="line"><span class="comment">32    ((&amp; Rhombus_Virtual::_ZTC15Rhombus_Virtual16_10D2_Virtual) + 72)</span></span><br><span class="line"><span class="comment">40    ((&amp; Rhombus_Virtual::_ZTV15Rhombus_Virtual) + 120)</span></span><br><span class="line"><span class="comment">48    ((&amp; Rhombus_Virtual::_ZTV15Rhombus_Virtual) + 72)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Class Rhombus_Virtual</span></span><br><span class="line"><span class="comment">   size=48 align=8</span></span><br><span class="line"><span class="comment">   base size=32 base align=8</span></span><br><span class="line"><span class="comment">Rhombus_Virtual (0x0x7fb760cebb60) 0</span></span><br><span class="line"><span class="comment">    vptridx=0 vptr=((&amp; Rhombus_Virtual::_ZTV15Rhombus_Virtual) + 24)</span></span><br><span class="line"><span class="comment">  D1_Virtual (0x0x7fb7608afdd0) 0</span></span><br><span class="line"><span class="comment">      primary-for Rhombus_Virtual (0x0x7fb760cebb60)</span></span><br><span class="line"><span class="comment">      subvttidx=8</span></span><br><span class="line"><span class="comment">    B (0x0x7fb7609461e0) 32 virtual</span></span><br><span class="line"><span class="comment">        vptridx=40 vbaseoffset=-24 vptr=((&amp; Rhombus_Virtual::_ZTV15Rhombus_Virtual) + 120)</span></span><br><span class="line"><span class="comment">  D2_Virtual (0x0x7fb7608aff70) 16</span></span><br><span class="line"><span class="comment">      subvttidx=24 vptridx=48 vptr=((&amp; Rhombus_Virtual::_ZTV15Rhombus_Virtual) + 72)</span></span><br><span class="line"><span class="comment">    B (0x0x7fb7609461e0) alternative-path</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到虚拟菱形继承类的内存空间特点是<strong>基类Di的内存布局(按照继承的顺序依次布局基类)+子类的成员变量+共同虚基类B的内存布局</strong>，基类Di的内存布局包括基类Di的虚函数表和虚基表和基类Di的成员变量。子类的虚函数在继承而来的<strong>第一个继承的Di基类</strong>的虚函数表基础上进行新增子类操作（新的虚函数）。可以看到虚拟菱形继承内存中只存在一份公共基类B的结构，这样可以解决二义性问题</p>
</blockquote>
<h4 id="内存布局的代码验证-1"><a href="#内存布局的代码验证-1" class="headerlink" title="内存布局的代码验证"></a>内存布局的代码验证</h4><p>1.测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RhombusVirtualDeriveTest</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rhombus_Virtual d;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------begin rhombus virtual derive object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object size is: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object addr is: &quot;</span> &lt;&lt; &amp;d &lt;&lt; std::endl; <span class="comment">// d指针转换为long指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; typeid(d) is: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; std::endl;  <span class="comment">// d对象类型</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d1 obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; <span class="comment">//  d1 vfptr地址 在对象第1个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)&amp;d &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun = (pFunc)(*(<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d));</span><br><span class="line">    (*pRun)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunD1 = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">1</span>));</span><br><span class="line">    (*pRunD1)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[2] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1 vfptr[2] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunRhombus = (pFunc)(*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">2</span>));</span><br><span class="line">    (*pRunRhombus)(); <span class="comment">//调用vfptr[2](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1  vptr offset is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[3]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d1  vbase offset is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*(<span class="type">long</span>*)&amp;d) + <span class="number">4</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[4]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d1_virtual addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">1</span> &lt;&lt; std::endl; <span class="comment">//  _d1_virtual 地址 在对象第2个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d1_virtual value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d1 obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d2 obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">2</span> &lt;&lt; std::endl; <span class="comment">//  d2 vfptr地址 在对象第3个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>) &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[0] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRun2 = (pFunc)(*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)));</span><br><span class="line">    (*pRun2)(); <span class="comment">//调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[1]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunD2 = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">1</span>));</span><br><span class="line">    (*pRunD2)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vptr offset  is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[2]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object d2 vbase offset  is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">2</span>)) + <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[3]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d2_virtual addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">3</span> &lt;&lt; std::endl; <span class="comment">//_d2 在对象第4个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _d2_virtual value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _rhombus_virtual addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//  _rhombus_virtual 地址 在对象第5个位置</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _rhombus_virtual value is: &quot;</span> &lt;&lt; *((<span class="type">int</span>*)((<span class="type">long</span>*)&amp;d + <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ d2 obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ base obj begin -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">4</span> &lt;&lt; std::endl; <span class="comment">//  base vfptr地址 在对象第6个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr value is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[0] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*(<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>)) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot; object base vfptr[0] func invoke res: &quot;;</span></span><br><span class="line">    <span class="comment">// pFunc pRunGen = (pFunc)(*(long*)(*((long*)&amp;d + 4)));</span></span><br><span class="line">    <span class="comment">// (*pRunGen)(); //调用vfptr[0](函数地址值)指向的函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[1] func ptr  is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>)) + <span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">//vfptr[0]的值 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object base vfptr[1] func invoke res: &quot;</span>;</span><br><span class="line">    pFunc pRunB = (pFunc)(*((<span class="type">long</span>*)(*((<span class="type">long</span>*)&amp;d + <span class="number">4</span>)) + <span class="number">1</span>));</span><br><span class="line">    (*pRunB)(); <span class="comment">//调用vfptr[1](函数地址值)指向的函数</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _b addr is: &quot;</span> &lt;&lt; (<span class="type">long</span>*)&amp;d + <span class="number">5</span> &lt;&lt; std::endl; <span class="comment">//_b 在对象第7个位置 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; object _b value is: &quot;</span> &lt;&lt; (<span class="type">int</span>)*((<span class="type">long</span>*)&amp;d + <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;------ base obj end -----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------end  rhombus virtual derive  object inner memory layout test-------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.运行结果：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">---------begin rhombus virtual derive object inner memory layout test-------</span><br><span class="line"> object size is: 48</span><br><span class="line"> object addr is: 0x7fff5a2ecef0</span><br><span class="line"> typeid(d) is: 15Rhombus_Virtual</span><br><span class="line">------ d1 obj begin -----</span><br><span class="line"> object d1 vfptr addr is: 0x7fff5a2ecef0</span><br><span class="line"> object d1 vfptr value is: 0x55573fd45920</span><br><span class="line"> object d1 vfptr[0] func ptr  is: 0x55573fd40c6e</span><br><span class="line"> object d1 vfptr[0] func<span class="built_in"> invoke </span>res: Rhombus_Virtual Run()</span><br><span class="line"> object d1 vfptr[1] func ptr  is: 0x55573fd409fc</span><br><span class="line"> object d1 vfptr[1] func<span class="built_in"> invoke </span>res: D1_Virtual RunD1_Virtual()</span><br><span class="line"> object d1 vfptr[2] func ptr  is: 0x55573fd40cc0</span><br><span class="line"> object d1 vfptr[2] func<span class="built_in"> invoke </span>res: Rhombus_Virtual RunRhombus_Virtual()</span><br><span class="line"> object d1  vptr offset is: 16</span><br><span class="line"> object d1  vbase offset is: -16</span><br><span class="line"> object _d1_virtual addr is: 0x7fff5a2ecef8</span><br><span class="line"> object _d1_virtual value is: 30</span><br><span class="line">------ d1 obj end -----</span><br><span class="line">------ d2 obj begin -----</span><br><span class="line"> object d2 vfptr addr is: 0x7fff5a2ecf00</span><br><span class="line"> object d2 vfptr value is: 0x55573fd45950</span><br><span class="line"> object d2 vfptr[0] func ptr  is: 0x55573fd40cb6</span><br><span class="line"> object d2 vfptr[0] func<span class="built_in"> invoke </span>res: Rhombus_Virtual Run()</span><br><span class="line"> object d2 vfptr[1] func ptr  is: 0x55573fd40b16</span><br><span class="line"> object d2 vfptr[1] func<span class="built_in"> invoke </span>res: D2_Virtual RunD2_Virtual()</span><br><span class="line"> object d2 vptr offset  is: 0</span><br><span class="line"> object d2 vbase offset  is: -32</span><br><span class="line"> object _d2_virtual addr is: 0x7fff5a2ecf08</span><br><span class="line"> object _d2_virtual value is: 30</span><br><span class="line"> object _rhombus_virtual addr is: 0x7fff5a2ecf0c</span><br><span class="line"> object _rhombus_virtual value is: 30</span><br><span class="line">------ d2 obj end -----</span><br><span class="line">------ base obj begin -----</span><br><span class="line"> object base vfptr addr is: 0x7fff5a2ecf10</span><br><span class="line"> object base vfptr value is: 0x55573fd45980</span><br><span class="line"> object base vfptr[0] func ptr  is: 0x55573fd40ca9</span><br><span class="line"> object base vfptr[1] func ptr  is: 0x55573fd405e4</span><br><span class="line"> object base vfptr[1] func<span class="built_in"> invoke </span>res: B RunB()</span><br><span class="line"> object _b addr is: 0x7fff5a2ecf18</span><br><span class="line"> object _b value is: 10</span><br><span class="line">------ base obj end -----</span><br><span class="line">---------end  rhombus virtual derive  object inner memory layout test-------</span><br></pre></td></tr></table></figure>

<p>3.内存布局示意图：<br><img src="http://www.taolingyang.com/2021/07/02/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B-4/rhombus_vir_layout.png" alt="rhombus virtual derive"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>本篇主要介绍了C++类在菱形继承体系下类对象内存特点。可以看出，对于普通菱形继承继承，最终的子类对象中会存在共同基类的多份拷贝，当子类调用共同基类中的相同函数时会存在二义性问题，为了解决这个问题，最好是在第二层继承体系中使用虚拟继承，这样在最终的子类的内存中会仅有一个共同基类的拷贝，主要是因为最终子类的多个虚基表都指向同一个虚基类，对于虚函数表依然遵守前几篇介绍的基本原则，由于菱形继承肯定是多重继承，所以最终子类有多张虚函数表，对于虚拟情况下的菱形继承还存在多张虚基表</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Object Model</tag>
      </tags>
  </entry>
  <entry>
    <title>C++虚函数表归属</title>
    <url>/2021/07/14/C++%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BD%92%E5%B1%9E/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>之前讨论过C++对象模型里面涉及到虚函数表及虚函数表指针问题，C++类实例化对象时候，不同实例化对象有各自的虚函数表指针，但是指针指向的虚函数表对于不同的实例化对象是否都各自存一份还是属于类的呢?有必要验证下(如未特别说明均在G++9.4.0, Gcc9.4.0, Ubuntu20.04, 64bit机器环境下测试的)</p>
<span id="more"></span>

<h2 id="单个类实例化不同对象"><a href="#单个类实例化不同对象" class="headerlink" title="单个类实例化不同对象"></a>单个类实例化不同对象</h2><hr>
<p>如下面带有虚函数得<code>Base</code>类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i am base func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i am base func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实例化两个不同对象的测试：</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void vtableOwnerTest1(void)</span><br><span class="line">&#123;</span><br><span class="line">    Base b0, b1;</span><br><span class="line">    <span class="keyword">long</span> *p1, *p2, *p3, *p4, *p5, *p6;</span><br><span class="line">    p1 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b0;</span><br><span class="line">    p2 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b1;</span><br><span class="line">    p3 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b0;</span><br><span class="line">    p4 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b1;</span><br><span class="line">    p5 = (<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b0 + <span class="number">1</span>);</span><br><span class="line">    p6 = (<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b1 + <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b0 object addrs:&quot;</span> &lt;&lt; (<span class="keyword">long</span>*)&amp;b0 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 object addrs:&quot;</span> &lt;&lt; (<span class="keyword">long</span>*)&amp;b1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b0 vptr addrs:&quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 vptr addrs:&quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b0 func1 addrs:&quot;</span> &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 func1 addrs:&quot;</span> &lt;&lt; p4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b0 func2 addrs:&quot;</span> &lt;&lt; p5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b1 func2 addrs:&quot;</span> &lt;&lt; p6 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vtable belong to Class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;vtable belong to Object&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p3 == p4)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b0 &amp; b1 use the same func1 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b0 &amp; b1 use different func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p5 == p6)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b0 &amp; b1 use the same func2 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b0 &amp; b1 use different func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>b0 object addrs:0x7ffc33792f08
b1 object addrs:0x7ffc33792f10
b0 vptr addrs:0x557438cf8d48
b1 vptr addrs:0x557438cf8d48
b0 func1 addrs:0x557438cf6978
b1 func1 addrs:0x557438cf6978
b0 func2 addrs:0x557438cf69b4
b1 func2 addrs:0x557438cf69b4
vtable belong to Class
b0 &amp; b1 use the same func1 
b0 &amp; b1 use the same func2 
</code></pre>
<blockquote>
<p>可以看到对于同一类的对同实例化对象而言，虚函数表指针的值是一致的，即虚函数表是属于类的(每个对象均使用相同的虚函数<code>func1</code>及<code>func2</code>地址这个是必须保证的)但是每个对象都包含一个自己的虚函数表指针，关系类似于这样的：<br><img src="http://www.taolingyang.com/2021/07/14/C++%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BD%92%E5%B1%9E/vtable-base.png" alt="vtb_1"></p>
</blockquote>
<h2 id="继承类与基类分别实例化对象"><a href="#继承类与基类分别实例化对象" class="headerlink" title="继承类与基类分别实例化对象"></a>继承类与基类分别实例化对象</h2><hr>
<p>如下面的子类继承自上面的<code>Base</code>类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// derive only override func2</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i am derive func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承类与基类实例化分别实例化对象的测试：</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line">void vtableOwnerTest2(void)</span><br><span class="line">&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derive d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> *p1, *p2, *p3, *p4, *p5, *p6;</span><br><span class="line">    p1 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b;</span><br><span class="line">    p2 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;d;</span><br><span class="line">    p3 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b;</span><br><span class="line">    p4 = (<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;d;</span><br><span class="line">    p5 = (<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;b + <span class="number">1</span>);</span><br><span class="line">    p6 = (<span class="keyword">long</span>*)*((<span class="keyword">long</span>*)*(<span class="keyword">long</span>*)&amp;d + <span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b object addrs:&quot;</span> &lt;&lt; (<span class="keyword">long</span>*)&amp;b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;d object addrs:&quot;</span> &lt;&lt; (<span class="keyword">long</span>*)&amp;d &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b vptr addrs:&quot;</span> &lt;&lt; p1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;d vptr addrs:&quot;</span> &lt;&lt; p2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b func1 addrs:&quot;</span> &lt;&lt; p3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;d func1 addrs:&quot;</span> &lt;&lt; p4 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;b func2 addrs:&quot;</span> &lt;&lt; p5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;d func2 addrs:&quot;</span> &lt;&lt; p6 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive &amp; Base use the same vtable &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derive &amp; Base use different vtable &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p3 == p4)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b &amp; d use the same func1 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b &amp; d use different func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p5 == p6)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b &amp; d use the same func2 &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b &amp; d use different func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>b object addrs:0x7ffc33792f08
d object addrs:0x7ffc33792f10
b vptr addrs:0x557438cf8d48
d vptr addrs:0x557438cf8d28
b func1 addrs:0x557438cf6978
d func1 addrs:0x557438cf6978
b func2 addrs:0x557438cf69b4
d func2 addrs:0x557438cf69f0
Derive &amp; Base use different vtable 
b &amp; d use the same func1 
b &amp; d use different func2
</code></pre>
<blockquote>
<p>从运行结果可以看出子类虽然只是重写了父类的其中一个虚函数,但仍然使用自己的虚函数表,虚函数表里面的未重写的虚函数<code>func1</code>是从基类继承而来的,虚函数地址也保持一致;<br>重写之后的虚函数<code>func2</code>地址就变化了生成了新的函数，关系类似于这样的：<br><img src="http://www.taolingyang.com/2021/07/14/C++%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BD%92%E5%B1%9E/vtable-derive.png" alt="vtb_2"></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>从验证结果可以看出虚函数表是属于类的，每个对象会维护自己的指向虚函数表的虚函数表指针；继承情况下，父类会有自己的虚函数表，且父类会从基类继承虚函数，重写虚函数的话，虚函数地址会变化（生成新的函数）</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Object Model</tag>
      </tags>
  </entry>
  <entry>
    <title>Git工具总结</title>
    <url>/2017/01/23/Git%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><hr>
<p>Git 是一个免费的、分布式版本控制工具，或是一个强调了速度快的源代码管理工具</p>
<span id="more"></span>
<h3 id="集中式VS分布式"><a href="#集中式VS分布式" class="headerlink" title="集中式VS分布式"></a>集中式VS分布式</h3><h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><ol>
<li>概念：<br>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。<br>集中式代码管理的核心是服务器，所有开发者在开始新一天的工作之前必须从服务器获取代码，然后开发，最后解决冲突，提交。所有的版本信息都放在服务器上。如 果脱离了服务器，开发者基本上是不可以工作的。</li>
<li>特点：<ul>
<li>服务器压力太大，数据库容量暴增。</li>
<li>如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。</li>
<li>不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。</li>
</ul>
</li>
<li>集中式工作流程像是这样的：<br><img src="http://www.taolingyang.com/2017/01/23/Git%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/center.png" alt="svn-center"></li>
<li>代表：<br>SVN</li>
</ol>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><ol>
<li>概念：<br>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了<br>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</li>
<li>特点：<ul>
<li>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了</li>
<li>适合分布式开发，强调个体</li>
<li>公共服务器压力和数据量都不会太大。</li>
<li>速度快、灵活</li>
<li>任意两个开发者之间可以很容易的解决冲突。</li>
</ul>
</li>
<li>分布式工作流程像是这样的：<br><img src="http://www.taolingyang.com/2017/01/23/Git%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/decenter.png" alt="git-decenter"><br>分布式和集中式的最大区别在于开发者可以在本地提交。每个开发者机器上都有一个服务器的数据库</li>
<li>代表：<br>Git</li>
</ol>
<h3 id="Git工作区-amp-暂存区-amp-版本库"><a href="#Git工作区-amp-暂存区-amp-版本库" class="headerlink" title="Git工作区&amp;暂存区&amp;版本库"></a>Git工作区&amp;暂存区&amp;版本库</h3><p>Git分为三个区域：</p>
<ol>
<li>工作区(working directory): 本地电脑能看到的目录(即<code>git init</code>执行的文件目录)</li>
<li>暂存区(stage index):工作区一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库，里面的stage（或者叫index）称为暂存区</li>
<li>版本库(master): Git为我们自动创建的第一个分支master，以及指向master的一个指针叫<code>HEAD</code><br>区域的示意图如下：<br><img src="http://www.taolingyang.com/2017/01/23/Git%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/git-three-zones.jpg" alt="git-three-zones"></li>
</ol>
<blockquote>
<p><code>git add</code>命令将使工作区的目录树写到暂存区中，暂存区中的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中<br><code>git commit</code>命令使暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树<br><code>git checkout</code>或者<code>git checkout --&lt;filename&gt;</code>命令会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动；即工作区未<code>add</code>的修改被丢弃，暂存区不变<br><code>git reset HEAD</code>命令会使暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响；即暂存区未<code>commit</code>的修改被丢弃，工作区不变<br><code>git checkout HEAD</code>或者<code>git checkout HEAD &lt;filename&gt;</code>命令会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动；即版本库不变，工作区未<code>add</code>和暂存区未<code>commit</code>的修改被丢弃<br><code>git rm --cached &lt;filename&gt;</code>命令会直接从暂存区删除文件，工作区则不做出改变<br><code>git diff</code>比较的是工作区和暂存区的差别<br><code>git diff --cached</code>比较的是暂存区和版本库的差别<br><code>git diff HEAD</code>比较的是工作区和版本库的差别</p>
</blockquote>
<h2 id="Git常用操作"><a href="#Git常用操作" class="headerlink" title="Git常用操作"></a>Git常用操作</h2><hr>
<h3 id="本地仓库Repository管理"><a href="#本地仓库Repository管理" class="headerlink" title="本地仓库Repository管理"></a>本地仓库Repository管理</h3><h4 id="初始化Git仓库"><a href="#初始化Git仓库" class="headerlink" title="初始化Git仓库"></a>初始化Git仓库</h4><pre><code>git init
</code></pre>
<blockquote>
<p>仓库(repository)，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
</blockquote>
<blockquote>
<p>Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的</p>
</blockquote>
<h4 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h4><p>Step 1.  添加文件到暂存区(stage index)</p>
<pre><code>git add &lt;filename&gt;
</code></pre>
<blockquote>
<p>可反复多次使用，添加多个文件<br>每次修改，如果不add到暂存区，那就不会加入到commit中</p>
</blockquote>
<p>Step 2. 提交文件到Git仓库</p>
<pre><code>git commit [-m]
</code></pre>
<blockquote>
<p>可选参数-m 后面添加提交的说明信息</p>
</blockquote>
<h4 id="删除Git仓库中的文件"><a href="#删除Git仓库中的文件" class="headerlink" title="删除Git仓库中的文件"></a>删除Git仓库中的文件</h4><p>首先<code>git rm</code> ,然后 <code>git commit</code>：</p>
<pre><code>git rm &lt;filename&gt;
git commit [-m]
</code></pre>
<blockquote>
<p>如果本地误删了，版本库中还没有删除，可以通过<code>git checkout -- &lt;filename&gt;</code>还原仓库中版本到工作区</p>
</blockquote>
<h4 id="查看版本状态"><a href="#查看版本状态" class="headerlink" title="查看版本状态"></a>查看版本状态</h4><p>Git状态变迁如下图所示：<br><img src="http://www.taolingyang.com/2017/01/23/Git%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/git-status.png" alt="git-status"></p>
<p>以下命令可以让我们时刻掌握工作区的状态：</p>
<pre><code>git status
</code></pre>
<p>以下命令可以查看修改内容：</p>
<pre><code>git diff &lt;filename&gt;
</code></pre>
<blockquote>
<p>查看工作区和版本库里面最新版本的区别:<code>git diff HEAD -- &lt;filename&gt;</code></p>
</blockquote>
<h4 id="操作回退"><a href="#操作回退" class="headerlink" title="操作回退"></a>操作回退</h4><h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h5><p>版本回退指丢弃版本库的修改，从Git本地版本库中回退版本到本地工作区<br>在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个^比较容易数不过来，所以写成<code>HEAD~100</code><br>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向回退的目标版本：<br>回退版本命令</p>
<pre><code>git reset --hard &lt;commit_id&gt;
</code></pre>
<blockquote>
<p><code>--hard</code>参数将版本库，暂存区和工作区的内容全部重置为某个commit_id的状态<br><code>git reset</code>默认是<code>git reset --mixed &lt;commit_id&gt;</code>可以让版本库重置到某个commit状态，该commit之后的commit不会保留，并重置暂存区，但是不改变工作区。即这个时候，上次提交的内容在工作区中还会存在<br><code>git revert</code>比<code>git reset</code>更加温柔一点，回滚到某次commit且该commit之后的提交记录都会保留，并且会在此基础上新建一个提交。对于已经<code>git push</code>到服务器上的内容作回滚，推荐使用<code>git revert</code><br>回退到指定的版本，commit_id可以通过<code>git log</code>命令查看<br>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了<br>回退到上一个版本：<code>git reset --hard HEAD^</code><br>回退到上上一个版本：<code>git reset --hard HEAD^^</code></p>
</blockquote>
<pre><code>git log
</code></pre>
<blockquote>
<p>查看提交历史，包含提交时间，作者和commit_id，以便确定要回退到哪个版本</p>
</blockquote>
<pre><code>git reflog
</code></pre>
<blockquote>
<p>查看命令历史，包含commit_id,命令操作信息等，以便确定要回到未来的哪个版本</p>
</blockquote>
<h5 id="修改回退"><a href="#修改回退" class="headerlink" title="修改回退"></a>修改回退</h5><p>修改回退指丢弃工作区或暂存区的修改，从Git本地暂存区或工作区中回退修改到本地工作区</p>
<ol>
<li><p>工作区修改回退<br>如果想丢弃工作的修改可以输入：</p>
<pre><code>git checkout -- &lt;filename&gt; 
</code></pre>
<p><code>git checkout</code>其实是会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动，无论工作区是修改还是删除，都可以“一键还原”，操作后就回到和暂存区一模一样的状态，这里有两种情况：</p>
<ul>
<li>一种是filename自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态（即丢弃了工作区的修改）</li>
<li>一种是filename已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态(即暂存区的修改仍然存在，只是工作区的修改丢弃了)<br>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。<br><code>git checkout -- &lt;filename&gt;</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令</li>
</ul>
</li>
<li><p>暂存区修改回退<br>如果你的修改只是通过<code>git add</code>添加到了暂存区，还没有提交，想撤销掉暂存区的修改(unstage),可以输入：</p>
<pre><code>git reset HEAD &lt;filename&gt;
</code></pre>
<p>可以把暂存区的修改撤销掉（unstage），重新把修改放回工作区,操作后，暂存区是干净的(暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响)工作区有修改;如果再想进一步的丢弃工作区的修改可以参照上面<strong>工作区修改回退</strong><br><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本</p>
</li>
</ol>
<h5 id="常用的各种场景回退命令操作流程"><a href="#常用的各种场景回退命令操作流程" class="headerlink" title="常用的各种场景回退命令操作流程"></a>常用的各种场景回退命令操作流程</h5><ol>
<li><p>修改了工作区，丢弃工作区的修改：</p>
<pre><code>modify code in filename of working dir 
git checkout --filename
</code></pre>
</li>
<li><p>修改了工作区，并add到了暂存区了，丢弃暂存区的修改：</p>
<pre><code>modify code in filename of working dir 
git add
git reset HEAD filename
</code></pre>
<p>如果想进一步丢弃暂存区回退到工作区的修改：</p>
<pre><code>git checkout -- filenmae
</code></pre>
<p>至此，工作区与版本库中一样了</p>
</li>
<li><p>修改了工作区，并add到了暂存区了，又修改工作区，丢弃工作区的修改：</p>
<pre><code>modify code in filename of working dir 
git add
modify code in filename of workding dir again
git checkout -- filenmae
</code></pre>
<p>如果又想丢弃暂存区的修改，继续输入：</p>
<pre><code>git reset HEAD filename
</code></pre>
<p>如果继续想把暂存区回退到工作区的修改也丢弃掉，继续输入：</p>
<pre><code>git checkout -- filenmae
</code></pre>
<p>至此，工作区与版本库中一样了</p>
</li>
<li><p>修改了工作区，并commit到仓库，撤销掉仓库的指定commit:</p>
<pre><code>modify code in filename of working dir
git add
git commit
git log
git reset --hard commit_id
</code></pre>
<p>如果突然发现是误撤销，又想回到之前的状态：</p>
<pre><code>git reflog
git reset --hard commit_id
</code></pre>
</li>
</ol>
<h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。默认情况下，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支</p>
<h5 id="分支操作命令"><a href="#分支操作命令" class="headerlink" title="分支操作命令"></a>分支操作命令</h5><p>创建branchname分支，并切换到该分支：</p>
<pre><code>git checkout -b &lt;branchname&gt;
</code></pre>
<blockquote>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
</blockquote>
<pre><code>git branch &lt;branchname&gt;
git checkout &lt;branchname&gt;
</code></pre>
<blockquote>
<p><code>git branch &lt;branchname&gt;</code>：表示创建指定分支<br><code>git checkout &lt;branchname&gt;</code>：表示切换到指定分支</p>
</blockquote>
<p>查看当前分支：</p>
<pre><code>git branch
</code></pre>
<blockquote>
<p>该命令会列出所有分支，当前分支前面会标一个*号</p>
</blockquote>
<p>合并branchname分支：</p>
<pre><code>git merge &lt;branchname&gt;
</code></pre>
<blockquote>
<p><code>git merge</code>命令用于合并指定分支到当前分支(当前git的工作分支，即最后一次<code>git checkout &lt;branchname&gt;</code>)。合并后被合并的分支和当前分支就一样了<br>默认情况下，是进行“快进模式”的合并，也就是直接把master（当前分支）指向dev(被合并的分支)的当前提交，所以合并速度非常快<br>Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果要强制禁用FF模式，可以增加<code>--no-ff</code>参数，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息</p>
</blockquote>
<p>删除branchname分支：</p>
<pre><code>git branch -d &lt;branchname&gt;
</code></pre>
<blockquote>
<p><code>-D</code>参数强行删除分支</p>
</blockquote>
<p>保存当前工作现场：</p>
<pre><code>git stash
</code></pre>
<p>查看保存的工作现场：</p>
<pre><code>git stash list
</code></pre>
<p>恢复现场：</p>
<pre><code>git stash pop
</code></pre>
<blockquote>
<p>该命令会在恢复的同时把stash内容也删了，等同于下面两个命令：</p>
</blockquote>
<pre><code>git stash apply 恢复现场单并不删除stash内容
git stash drop 删除stash内容
</code></pre>
<blockquote>
<p>可以多次stash,先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：<br>    git stash apply stash@{stash_id}</p>
</blockquote>
<h5 id="常用的各种场景分支命令操作流程"><a href="#常用的各种场景分支命令操作流程" class="headerlink" title="常用的各种场景分支命令操作流程"></a>常用的各种场景分支命令操作流程</h5><ol>
<li><p>创建dev分支，修改提交代码后再合并到master分支：</p>
<pre><code>git branch dev
git checkout dev 
(or git checkout -b dev)
modifty code in dev branch
git add
git commit

git checkout master
git merge dev 
git branch -d dev
</code></pre>
</li>
<li><p>master分支和dev分支各自都分别有各自的代码修改和新的提交,并有冲突:</p>
<pre><code>git branch dev
git checkout dev 
(or git checkout -b dev)
modify code in dev branch
git add
git commit

git master
modify code in master branch 
git add
git commit

git merge dev (master modify is conflict with dev modify)
</code></pre>
<p>产生冲突后,手动解决后，再在当前master上提交,并删除dev分支即可：</p>
<pre><code>git add 
git commit
git branch -d dev   
</code></pre>
<blockquote>
<p>使用<code>git log --graph</code>可以看到分支合并图</p>
</blockquote>
</li>
<li><p>修改dev分支时候，需要修改master分支上的bug,先保存现场，再修改bug,最后恢复现场:</p>
<pre><code>git stash

git checkout master
git checkout -b bug
modify code in bug branch
git add
git commit

git checkout master
git merge bug
git branch -d bug

git checkout dev
git stash pop
</code></pre>
</li>
</ol>
<h4 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h4><p>发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照</p>
<h5 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h5><p>首先切换到需要打标签的分支上,输入下面命令即可：</p>
<pre><code>git tag [-a] &lt;tagname&gt; [-m] [commit_id]
</code></pre>
<blockquote>
<p><code>git tag &lt;tagname&gt;</code>命令默认标签是打在最新提交的commit上的,给历史提交打标签可以加上<code>commit_id</code>可选项，选择要打标签的commit id即可<br>还可以创建带有说明的标签，用<code>-a</code>可选参数指定标签名，<code>-m</code>可选参数指定说明文字<br>还可以通过<code>-s</code>可选参数用私钥签名一个标签<br>查看该分支下的所有标签：</p>
</blockquote>
<pre><code>git tag
</code></pre>
<p>查看标签信息：</p>
<pre><code>git show &lt;tagname&gt;
</code></pre>
<h5 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h5><p>创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除:</p>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre>
<h5 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h5><p>如果要把标签推送到远程可以用：</p>
<pre><code>git push origin &lt;tagname&gt;
</code></pre>
<p>也可以一次性推送所有的本地标签：</p>
<pre><code>git push origin --tags
</code></pre>
<p>如果要删除远程的标签，要分两步：<br>Step 1: 先从本地删除：</p>
<pre><code>git tag -d &lt;tagname&gt;
</code></pre>
<p>Step 2: 从远程删除：</p>
<pre><code>git push origin :refs/tags/&lt;tagname&gt;
</code></pre>
<h3 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h3><h4 id="关联本地仓库到远程仓库"><a href="#关联本地仓库到远程仓库" class="headerlink" title="关联本地仓库到远程仓库"></a>关联本地仓库到远程仓库</h4><ol>
<li><p>登陆GitHub,点击<code>Create a new repo</code>创建一个新的仓库,在本地仓库运行：</p>
<pre><code>git remote add origin git@server-name:path/repo-name.git
</code></pre>
<blockquote>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库</p>
</blockquote>
</li>
<li><p>推送本地库内容到新建的远程仓库<br>git push -u origin master</p>
<blockquote>
<p>由于远程库是空的，我们第一次推送master分支时，加上了<code>-u</code>参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令</p>
</blockquote>
</li>
<li><p>以后每次修改本地代码后，就可以将本地的master分支最新修改推送栋GitHub了：<br>git push origin master</p>
</li>
</ol>
<h4 id="从远程仓库克隆到本地仓库"><a href="#从远程仓库克隆到本地仓库" class="headerlink" title="从远程仓库克隆到本地仓库"></a>从远程仓库克隆到本地仓库</h4><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin，克隆命令：</p>
<pre><code>git clone &lt;github_addrs&gt;
</code></pre>
<blockquote>
<p>Git支持多种协议，默认的git:&#x2F;&#x2F;使用ssh，通过ssh支持的原生git协议速度最快,但也可以使用https等其他协议，使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令</p>
</blockquote>
<h4 id="从远程获取最新版本到本地"><a href="#从远程获取最新版本到本地" class="headerlink" title="从远程获取最新版本到本地"></a>从远程获取最新版本到本地</h4><pre><code>git fetch
</code></pre>
<blockquote>
<p>从远程获取最新版本到本地，不会自动merge</p>
</blockquote>
<pre><code>git pull
</code></pre>
<blockquote>
<p>从远程获取最新版本并merge到本地, 其命令相当于：</p>
</blockquote>
<pre><code>git fetch
git merge
</code></pre>
<h4 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h4><pre><code>git remote 
</code></pre>
<blockquote>
<p>想查看更详细的信息可以加上<code>-v</code>参数</p>
</blockquote>
<h4 id="使用远程仓库的一般流程"><a href="#使用远程仓库的一般流程" class="headerlink" title="使用远程仓库的一般流程"></a>使用远程仓库的一般流程</h4><ol>
<li>可以试图用<code>git push origin &lt;branchname&gt;</code>推送自己的修改</li>
<li>如果推送失败，则因为远程仓库分支比你的本地仓库更新，需要先用<code>git pull</code>试图合并<blockquote>
<p>如果<code>git pull</code>提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream &lt;branchname&gt; origin/&lt;branchname&gt;</code></p>
</blockquote>
</li>
<li>如果合并有冲突，则解决冲突，并在本地提交</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branchname&gt;</code>推送就能成功</li>
</ol>
<p>附:<br>比较齐全的Git命令图解:<br><img src="http://www.taolingyang.com/2017/01/23/Git%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/git-cheatsheet.jpeg" alt="git-cmd"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.liaoxuefeng.com/">liaoxuefeng</a><br><a href="http://selfcontroller.iteye.com/blog/1786644">git 缓存区的理解</a><br><a href="http://gitref.org/index.html">git reference</a><br><a href="https://git-scm.com/book/zh/v2">Pro Git book</a><br><a href="http://git.oschina.net/wzw/git-quick-start">git-quick-start</a><br><a href="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2Fgit-cheatsheet.pdf">git-cheatsheet</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本管理</tag>
        <tag>SVN</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-asset-image插件生成静态图片路径错误</title>
    <url>/2019/09/09/Hexo-asset-image%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>之前都在是Linux环境下搭建Hexo博客，用<code>Hexo new page [page name]</code> 来新建文章，执行该命令时候，会同时生成一个文章名称相同文件夹，该文件夹用来存放与此篇博客相关的资源文件，常用的如图片等，在博客里面引用图片使用的是相对路径，这样方便每篇博客文章和相应的图片资源一起分类管理。但是切换到Windows环境下搭建Hexo博客写文章，用同样的方式却无法加载出图片。</p>
<span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><hr>
<p>之前写的博客<a href="/2016/09/02/Hexo%E5%8D%9A%E5%AE%A2%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D/index.html">Hexo博客保存与恢复</a>文章中<strong>博客图片相对路径配置问题</strong>章节内总结了使用相对路径法存博客图片资源，分以下两步骤：<br>首先安装<code>Hexo-asset-image</code>插件：</p>
<pre><code>npm install hexo-asset-image --save
</code></pre>
<p>然后，修改站点配置文件_config.yml:</p>
<pre><code>post_asset_folder: true
</code></pre>
<p>此方法在Linux环境下工作正常，但是切换到Windows环境下写Hexo博客，出现如下无法加载出图片现象：<br><img src="http://www.taolingyang.com/2019/09/09/Hexo-asset-image%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/load-picture-error.png" alt="load-picture-error"></p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><hr>
<ol>
<li>在<code>Hexo s -g</code>本地生成部署或<code>Hexo d -g</code>服务器生成部署时候，都显示如下生成图片绝对路径的打印：<br><img src="http://www.taolingyang.com/2019/09/09/Hexo-asset-image%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/hexo-gen-abs-path.png" alt="hexo-gen-abs-path"></li>
</ol>
<p>2.打开浏览器开发者模式，调试发现生成的绝对路径错误：<br><img src="http://www.taolingyang.com/2019/09/09/Hexo-asset-image%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/web-debug1.png" alt="web-debug1"><br><img src="http://www.taolingyang.com/2019/09/09/Hexo-asset-image%E6%8F%92%E4%BB%B6%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E9%94%99%E8%AF%AF/web-debug2.png" alt="web-debug2"></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><hr>
<ol>
<li><p>打开<code>hexo-asset-image</code>文件源代码处：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> blog_root_dir</span><br><span class="line"><span class="keyword">cd</span> node_modules/hexo-asset-image/</span><br><span class="line"><span class="keyword">vim</span> <span class="built_in">index</span>.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>index.js</code>文件58行左右，修改如下，注释掉错误的两行，增加正确的绝对图片路径两行代码如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> $(this).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line"><span class="regexp">//</span> console.info&amp;&amp;console.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line"> $(this).attr(<span class="string">&#x27;src&#x27;</span>, data.permalink+ src);</span><br><span class="line"> console.info&amp;&amp;console.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+data.permalink+ src);</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><p><a href="https://github.com/xcodebuild/hexo-asset-image">xcodebuild-hexo-asset-image</a></p>
<p><a href="https://www.npmjs.com/package/hexo-asset-image-for-hexo5">hexo-asset-image-for-hexo5</a></p>
<p><a href="https://www.4k8k.xyz/article/qq_42009500/118788129">Hexo-asset-image踩坑</a></p>
<p><a href="https://hexo.io/docs/asset-folders.html">asset-folders</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客(1)</title>
    <url>/2016/01/05/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>写个人Blog大部分情况下是在使用现有的网站提供的博客系统，使用比较多的有sina博客、网易博客、CSDN等，如果想DIY个人的博客，可以选择静态网站的方式，使用的比较多的静态博客框架有:</p>
<ul>
<li><a href="http://jekyll.bootcss.com/">Jekyll</a>:<br>Jekyll是一种基于Ruby开发的、适用于博客的静态网站生成引擎。使用一个模板目录作为网站布局的基础框架，提供了模板、变量、插件等功能，最终生成一个完整的静态Web站点。即只要安装Jekyll的规范和结构，不需写html，便可生成网站</li>
<li><a href="http://octopress.org/">Octopress</a>:<br>Octopress是一款基于Ruby开发的静态化、本地化的博客系统。其最大的优势就是静态化，不依赖脚本程序，没有MysqL等数据库，因此它可在一些性能差的服务器或者虚拟空间上运行，同等条件下打开页面的速度会比较快 </li>
<li><a href="https://hexo.io/">Hexo</a>:<br>Hexo是一款基于node.js开发的博客程序，拥有简单的服务器，可用作简单的动态博客使用。也有生成器，生成的静态文件可以一键部署到Github Pages上，也可以部署到任意静态文件服务器上。它相当简约，并且可使用Markdown来编写文章<br>考虑到简单易用，生成效率问题，选用Hexo作为搭建个人博客的框架</li>
</ul>
<span id="more"></span>

<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><hr>
<p>Hexo是一个快速、简单且高效的博客框架,使用Markown(或其他渲染引擎)解析文章，可以高效的利用各种主题插件生成自定义的静态页面，使用Hexo时候，一般是在本地编辑文章，转化为生成HTML文件，然后上传到部署的服务器上</p>
<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><hr>
<h3 id="安装Hexo前需要的准备"><a href="#安装Hexo前需要的准备" class="headerlink" title="安装Hexo前需要的准备"></a>安装Hexo前需要的准备</h3><ul>
<li>Node.js:<br>[Node.js下载地址]（<a href="https://nodejs.org/en/%EF%BC%89">https://nodejs.org/en/）</a><br>笔者安装的是Window版本的node-v5.3.0-x64.msi，安装完成后，在cmd输入<code>node -v</code>可以查看安装的版本和是否正确</li>
<li>Git：<br>[git下载地址]（<a href="http://git-scm.com/download/%EF%BC%89">http://git-scm.com/download/）</a><br>笔者安装的是Windows版本的git version 1.9.5.msysgit.0,安装完成后，<code>git --version</code>可以查看安装的版本和是否正确</li>
</ul>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>使用npm（npm是node.js的模块管理和发布工具,安装node的时候会自动安装此工具）安装Hexo，shell中输入下面命令：</p>
<pre><code>$ npm install -g hexo-cli
</code></pre>
<p>安装完成后，shell中输入<code>hexo -v</code>或<code>hexo version</code>查看安装的版本</p>
<blockquote>
<p><code>-g</code>: 表示全局安装，未带此参数表示本地安装</p>
</blockquote>
<ul>
<li>全局安装：模块将被安装到<strong>全局目录</strong>中，全局目录可以通过<code>npm config set prefix &quot;目录路径&quot;</code>来设置，通过<code>npm config get prefix</code> 来获取</li>
<li>本地安装：模块将被安装到<strong>当前命令行所在目录中</strong><br>一般采用全局安装方式统一安装到一个目录中去，方便管理、结构清晰、可以重复利用</li>
</ul>
<h2 id="Hexo本地建站"><a href="#Hexo本地建站" class="headerlink" title="Hexo本地建站"></a>Hexo本地建站</h2><hr>
<h3 id="初始化Blog网站框架"><a href="#初始化Blog网站框架" class="headerlink" title="初始化Blog网站框架"></a>初始化Blog网站框架</h3><p>在本地电脑上建立一个Blog目录，并在shell中进行下面命令，初始化框架:</p>
<pre><code>$ hexo init &lt;your blog folder&gt;
$ cd folder
$ npm install
</code></pre>
<blockquote>
<p>或者直接进入Blog目录中，执行<code>hexo init</code>和<code>npm install</code></p>
</blockquote>
<h3 id="修改Blog网站配置"><a href="#修改Blog网站配置" class="headerlink" title="修改Blog网站配置"></a>修改Blog网站配置</h3><p>初始化完成后，该Blog目录就会出现下面几个文件夹：</p>
<pre><code>|—— _config.yml
|—— package.json
|—— scanffolds
|—— source
|    |—— _posts
|—— themes
</code></pre>
<blockquote>
<ul>
<li>_config.yml:<br>整个站点的<strong>配置</strong>信息：可以配置网站的title、author、language、目录、文章、日期、分页、扩展（主题名称、部署）信息</li>
</ul>
</blockquote>
<ul>
<li>package.json: 应用程序信息</li>
<li>scanffolds: 模板文件夹,创建新文章时,Hexo会根据此建立文件</li>
<li>source: 资源文件夹,存放用户资源</li>
<li>themes: 主题文件夹，Hexo会根据此来生成静态页面，默认是官方的<em>landscape</em>主题</li>
</ul>
<h3 id="写Blog文章"><a href="#写Blog文章" class="headerlink" title="写Blog文章"></a>写Blog文章</h3><p>执行下面的命令创建一篇新的文章:</p>
<pre><code>$ hexo new [layout] &lt;title&gt;
</code></pre>
<p>建立的文章后，在&#x2F;source&#x2F;_post里会出现该title的文章，之后的文章均保持在此目录</p>
<blockquote>
<p>可选参数：文章布局layout，默认是post,可以修改_config.yml中的default_layout来修改默认布局<br>文章的默认布局有3种： post、page、draft，分别对应不同的路径：</p>
</blockquote>
<table>
<thead>
<tr>
<th>Layout</th>
<th>Path</th>
</tr>
</thead>
<tbody><tr>
<td>post</td>
<td>source&#x2F;_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source&#x2F;_drafts</td>
</tr>
</tbody></table>
<blockquote>
<p>将草稿发布,执行下面publish命令， 将草稿移动到source&#x2F;_post文件夹下：<br><code>$ hexo publish [layout] &lt;title&gt;</code><br>草稿默认不会显示在页面中，执行时候加上–draft参数或render_drafts参数设置为true来预览草稿</p>
</blockquote>
<h3 id="生成网站"><a href="#生成网站" class="headerlink" title="生成网站"></a>生成网站</h3><p>写完文章后，在cmd中执行下面命令生成静态文件，生成网站：</p>
<pre><code>$ hexo generate
</code></pre>
<p>生成网站后，会在Blog的根目录下生成一个pulic临时文件，存放生成的网站结果，可以通过<code>hexo clean</code>命令清除生成结果，然后再执行<code>hexo generate</code>重新生成</p>
<h3 id="启动Hexo服务器"><a href="#启动Hexo服务器" class="headerlink" title="启动Hexo服务器"></a>启动Hexo服务器</h3><p><strong>Hexo3.0之后的版本把服务器独立成了单独的模块，必须先安装hexo-sever才能使用</strong>:</p>
<pre><code>$ npm install hexo-server --save
</code></pre>
<blockquote>
<p><code>--save</code>:安装的同时将信息写入package.json中项目路径中如果有package.json文件时，使用<code>npm install</code>方法就可以根据dependencies配置安装所有的依赖包，这样代码提交到github时，就不用提交node_modules这个文件夹了</p>
</blockquote>
<p>安装hexo-server后，执行下面命令启动服务器,启动服务器之后，Hexo会自动监视文件变动并自动更新，无需重启服务器：</p>
<pre><code>$ hexo server
</code></pre>
<blockquote>
<p>如果想更改服务器的端口(默认是4000)，或启动时遇到EADDRINUSE 错误可以加-p选项指定其他端口:<br><code>$ hexo server -p 3000</code><br>服务器默认运行在0.0.0.0，可以覆盖默认的IP:<br><code>$ hexo server -i 192.168.0.1</code></p>
</blockquote>
<p>启动服务之后，本地的Blog网站系统搭建完成，可以在输入以下网址查看Blog的搭建效果：<a href="http://localhost:4000/">http://localhost:4000</a> 或 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><hr>
<p>这样一个本地的Blog网站建立完成，每次需要写Blog时候，只需要<code>hexo new</code> (hexo n for short)一篇文章，再使用markdown编辑文章，然后<code>hexo generarte</code>(hexo g for short)即可，但是这样Blog只能在本地的机器上访问，要想让别人也可以通过网址访问，需要将Blog deploy部署到服务器上，具体方法见下篇</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客(2)</title>
    <url>/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇介绍了使用Hexo在本地搭建的过程，本篇将本地搭建的博客网站部署到服务器去，常见的服务器有:</p>
<ul>
<li><a href="https://github.com/">GitHub</a></li>
<li><a href="https://www.heroku.com/">Heroku</a></li>
<li>…</li>
</ul>
<p>本文选用使用比较多的GitHub作为目标服务器</p>
<span id="more"></span>

<h2 id="GitHub简介"><a href="#GitHub简介" class="headerlink" title="GitHub简介"></a>GitHub简介</h2><hr>
<p><a href="https://github.com/">GitHub</a>是Git工具的远程库，托管各种Git库，并提供Web界面。GitHub为一个项目贡献代码非常简单：首先点击项目站点的“fork”的按钮，然后将代码检出并将修改加入到刚才分出的代码库中，最后通过内建的“pull request”机制向项目负责人申请代码合并，GitHub是软件开发人员的Facebook</p>
<h2 id="GitHub注册"><a href="#GitHub注册" class="headerlink" title="GitHub注册"></a>GitHub注册</h2><hr>
<blockquote>
<p>已有账户的忽略此步</p>
</blockquote>
<h3 id="注册GitHub账号"><a href="#注册GitHub账号" class="headerlink" title="注册GitHub账号"></a>注册GitHub账号</h3><h3 id="建立GitHub-Pages"><a href="#建立GitHub-Pages" class="headerlink" title="建立GitHub Pages"></a>建立GitHub Pages</h3><p>对于<a href="https://pages.github.com/">GitHub Pages</a>分两种：</p>
<ul>
<li>用户&amp;组织页：根据GitHub用户名建立的<code>username.github.io</code>的repository,如笔者的仓库名为<code>franktly.github.io</code>,此时网页使用的是该仓库的master分支</li>
<li>项目页: 比前者稍微麻烦些，需要在新的或已有的repository上新建一个gh-pages分支，具体方法见<a href="https://pages.github.com/">GitHub Pages 官网</a></li>
</ul>
<p>这次我们选择第一种<strong>用户&amp;组织页</strong>类型的GitHub Pages</p>
<h3 id="设置GitHub-SSH-Key"><a href="#设置GitHub-SSH-Key" class="headerlink" title="设置GitHub SSH Key"></a>设置GitHub SSH Key</h3><h4 id="本地设置git邮箱、用户名和密码"><a href="#本地设置git邮箱、用户名和密码" class="headerlink" title="本地设置git邮箱、用户名和密码"></a>本地设置git邮箱、用户名和密码</h4><pre><code>git config --global user.email &quot;your_email_addr&quot;
git config --global user.name  &quot;user_name&quot;
</code></pre>
<h4 id="本地创建SSH-Key"><a href="#本地创建SSH-Key" class="headerlink" title="本地创建SSH Key"></a>本地创建SSH Key</h4><pre><code>ssh-keygen -t rsa -C &quot;your_email@your_email.com&quot;
</code></pre>
<blockquote>
<p>首先打开用户根目录（用户根目录一般为为C:\Users\username）查看是否已经有了SSH Key的文件夹<code>.ssh</code>,若有了先备份下，</p>
</blockquote>
<h4 id="添加生成的SSH-Key到GitHub账户"><a href="#添加生成的SSH-Key到GitHub账户" class="headerlink" title="添加生成的SSH Key到GitHub账户"></a>添加生成的SSH Key到GitHub账户</h4><p>打开在当前用户的根目录下生成的<code>.ssh</code>文件里面的ssh.pub（ssh 公钥）,拷贝其内容到[Account setting -&gt; SSH Keys -&gt; Add SSH Key]</p>
<h4 id="验证下SSH是否设置成功"><a href="#验证下SSH是否设置成功" class="headerlink" title="验证下SSH是否设置成功"></a>验证下SSH是否设置成功</h4><pre><code>ssh -T git@github.com
</code></pre>
<p>第一次提示不能连接，直接输入yes即可</p>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/SSH-Key.PNG" alt="SSH_SET"></p>
<h2 id="GitHub部署"><a href="#GitHub部署" class="headerlink" title="GitHub部署"></a>GitHub部署</h2><hr>
<p>建立GitHub Pages之后，即可以将本地搭建的Hexo网站部署到GitHub上去</p>
<h3 id="修改站点-config-yml配置文件"><a href="#修改站点-config-yml配置文件" class="headerlink" title="修改站点_config.yml配置文件"></a>修改站点_config.yml配置文件</h3><p>如下面所示：类型配置为git，仓库地址为建立的GitHub Pages仓库地址，分支为master</p>
<pre><code>deploy:
type: git
repo: https://github.com/username/username.github.io.git
branch: master
</code></pre>
<h3 id="执行部署命令"><a href="#执行部署命令" class="headerlink" title="执行部署命令"></a>执行部署命令</h3><pre><code>$ hexo deploy
</code></pre>
<blockquote>
<p>可以使用<code>-g，--generate</code>可选参数部署之前预先生成静态文件</p>
</blockquote>
<p>在GitHub上部署完成之后，以后别人也可以通过<a href="http://username.github.io网站访问你的个人博客网站了/">http://username.github.io网站访问你的个人博客网站了</a></p>
<h2 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h2><hr>
<h3 id="Godaddy域名申请"><a href="#Godaddy域名申请" class="headerlink" title="Godaddy域名申请"></a>Godaddy域名申请</h3><p>如果想使用自己申请的域名来访问GitHub上部署的个人博客，可以先到<a href="https://www.godaddy.com/">Godaddy</a>上申请域名,笔者申请的域名为<a href="http://www.taolingyang.com/">http://www.taolingyang.com</a></p>
<p>Godaddy的域名申请一般分为：</p>
<ol>
<li>Search Domain： 查找自己想要申请的域名，若未被别人申请才行</li>
<li>Select Extensions: 选择域名的扩展名，有.com、.net等等可以选择</li>
<li>Continue To Chart: 选择提供的相应的服务去付款，支持支付宝支付</li>
</ol>
<h3 id="Godaddy域名设置"><a href="#Godaddy域名设置" class="headerlink" title="Godaddy域名设置"></a>Godaddy域名设置</h3><p>申请成功后，需要设置Godaddy的域名，将申请到的域名关联到username.github.io网址上,具体步骤如下：</p>
<ol>
<li>打开个人Godday主页查看购买的Products:</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/godaddy1.png" alt="gd-product"></p>
<ol start="2">
<li>选择管理DNS，在DNS Records中选择Add:</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/godday2.png" alt="gd-add"></p>
<ol start="3">
<li>在新建的Record中增加A记录类型，主机记录类型为<code>@</code>:IP地址为GitHub Page Docs中的第5项列的A记录IP地址，四个地址全部依次添加,总共添加4条IP记录:</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/godaddy3.png" alt="gd-ip1"></p>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/godaddy4.png" alt="gd-ip2"></p>
<ol start="4">
<li>最后新建一条CNAME记录类型，主机记录类型为<code>www</code>,值为github pages地址,如username.github.io形式,TTL默认:</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/goddady6.png" alt="gd-cname"></p>
<h3 id="GitHub域名设置"><a href="#GitHub域名设置" class="headerlink" title="GitHub域名设置"></a>GitHub域名设置</h3><h4 id="GitHub-Page自定义域名添加"><a href="#GitHub-Page自定义域名添加" class="headerlink" title="GitHub Page自定义域名添加"></a>GitHub Page自定义域名添加</h4><p>在GitHub Page配置中的Custom domain中填入Godday申请的域名，如本人的为<code>www.taolingyang.com</code>:</p>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/godaddy5.png" alt="gd-domain"></p>
<blockquote>
<p>输入完成后GitHub Page会自动Check DNS，若Check Success说明设置成功</p>
</blockquote>
<h4 id="Hexo-CNAME文件添加"><a href="#Hexo-CNAME文件添加" class="headerlink" title="Hexo CNAME文件添加"></a>Hexo CNAME文件添加</h4><p>在GitHub端也相应的设置下域名，只需在本地博客的根目录下source文件夹下增加一个CNAME文件，文件内容为你申请的域名地址，如本人的是：<code>www.taolingyang.com</code>.</p>
<blockquote>
<p>本地根目录下的source文件夹下的增加CNAME文件后，需要重新执行下<code>hexo deploy</code>命令将CNAME文件部署到GitHub服务器才能生效，成功后，一般需要等十几分钟左右才能通过新申请的域名访问你的博客<br>放到博客根目录的source文件夹下面比直接通过Git客户端将本地CNAME文件push到GitHub上好些，这样可以避免每次<code>hexo deploy</code>后，hexo自动将 CNAME文件删除掉</p>
</blockquote>
<h2 id="DNSPod域名管理"><a href="#DNSPod域名管理" class="headerlink" title="DNSPod域名管理"></a>DNSPod域名管理</h2><hr>
<p>为了方便国内网络访问个人博客，可以通过腾讯平台的DNSPod进行DNS域名解析管理,主要分为以下几步:</p>
<ol>
<li>DNS 域名添加，打开<code>www.dnspod.cn</code>主页，登录个人账号，选择DNS- DNS管理-添加域名：</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/dnspod1.png" alt="dnspod mag"></p>
<ol start="2">
<li>DNS 域名解析服务器地址生成，DNSPod生成的服务器地址在右边的两项：</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/dnspod2.png" alt="dnspod addr"></p>
<ol start="3">
<li>同步DNSPod域名解析服务器到Godday，将上述生成的两项DNSPod服务器地址添加到Godaddy自定义域名服务器当中:</li>
</ol>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/dnspod3.png" alt="dnspod godaddy"></p>
<p>DNSPod域名设置完成后，Godaddy的域名设置被DNSPod托管：</p>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/dnspod4.png" alt="dnspod godaddy-records"></p>
<p><img src="http://www.taolingyang.com/2016/01/09/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-2/dnspod5.png" alt="dnspod display"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr>
<p>本篇主要介绍了将本地Hexo搭建的个人博客网站部署到GitHub服务器上的方法，并且简要的介绍了在Godaddy上域名的申请方法和设置和方便国内网络使用DNSPod进行域名地址解析，至此，就可以使用域名在网络上访问自己的博客了，如果觉得博客的主题不是自己喜欢的还可以更改Hexo的默认主题，下篇将会简介Hexo中怎么使用Next主题来使Blog更好看</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo搭建个人博客(3)</title>
    <url>/2016/01/10/Hexo%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-3/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇简单介绍了Hexo搭建的静态博客部署到GitHub服务器上，并关联了自己申请的域名，Hexo默认的主题是landscape,如果想选用其他的主题，可以在GitHub上搜索hexo themes,GitHub上Hexo主题Star比较多的有下面几个：</p>
<ul>
<li><a href="http://theme-next.iissnan.com/">NexT</a></li>
<li><a href="http://theme-next.iissnan.com/">Casper</a></li>
<li><a href="https://github.com/daleanthony/uno">Uno</a></li>
<li><a href="https://github.com/orderedlist/modernist">Modernist</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia">Yilia</a></li>
<li><a href="https://github.com/A-limon/pacman">Pacman</a></li>
<li>…</li>
</ul>
<p>本篇以Star最多的（也是本人使用的）Next主题为例，简要的介绍Next主题在Hexo中的使用方法</p>
<span id="more"></span>

<h2 id="NexT简介"><a href="#NexT简介" class="headerlink" title="NexT简介"></a>NexT简介</h2><hr>
<p>NexT是<a href="https://github.com/iissnan/hexo-theme-next">iissnan</a>设计的一款简单又不失优雅的主题,正如NexT的开发宗旨：<br>** NexT is built for easily use with elegant appearance. First things first, always keep things simple.**</p>
<h2 id="应用Next"><a href="#应用Next" class="headerlink" title="应用Next"></a>应用Next</h2><hr>
<h3 id="下载NexT主题"><a href="#下载NexT主题" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h3><p>在Hexo博客的目录打开Shell终端，输入下面命令即可：</p>
<pre><code>$ cd your_hexo_dir
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre>
<blockquote>
<p>Next主题仓库经过了几次变更，最新的仓库名称地址为: <a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a><br>Next主题升级方法:<a href="https://theme-next.js.org/docs/getting-started/upgrade">https://theme-next.js.org/docs/getting-started/upgrade</a></p>
</blockquote>
<h3 id="启用NexT主题"><a href="#启用NexT主题" class="headerlink" title="启用NexT主题"></a>启用NexT主题</h3><p>打开Hexo博客站点配置文件，把theme 字段的值改为next</p>
<h3 id="验证是否启用"><a href="#验证是否启用" class="headerlink" title="验证是否启用"></a>验证是否启用</h3><p>打开Shell终端，输入：</p>
<pre><code>$ hexo server --debug
</code></pre>
<p>并访问<a href="http://localhost:4000/">http://localhost:4000</a>即可查看主题是否启用</p>
<h3 id="Next配置"><a href="#Next配置" class="headerlink" title="Next配置"></a>Next配置</h3><p>NexT的官方使用手册上有比较详细的配置使用教程，见<a href="http://theme-next.iissnan.com/">NexT使用指南</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客保存与恢复</title>
    <url>/2016/09/02/Hexo%E5%8D%9A%E5%AE%A2%E4%BF%9D%E5%AD%98%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Hexo博客由于文章和博客网站的一些配置主要在本地，因此对于电脑系统重装或更换电脑情况下需要重新搭建比较麻烦，因此有必要将文章或一些博客配置进行相应的备份，同时记录一下一些关键点，方便后续迁移博客到其他系统和电脑上。</p>
<span id="more"></span>

<h2 id="博客文件备份"><a href="#博客文件备份" class="headerlink" title="博客文件备份"></a>博客文件备份</h2><hr>
<p>前面搭建Hexo博客的文章中使用GitHub托管了通过文章源码和一些Hexo站点配置文件，主题配置文件生成的静态网站，但是文章源码和这些站点本身的配置信息并没有被保存下来，而这却是恢复和迁移网站的主要文件，因此方便，可以在原本的博客仓库新加一个分支保存这些恢复和迁移的必要信息。</p>
<p>如原来生成的静态网址默认是保存在your_blog_name&#x2F;your_blog_name.github.io的master分支，可以在原有的基础上增加一个hexo分支保存网址原始数据,并将这个分支设置为默认分支，这样每次恢复和迁移文件时候只需要git clone即可获取迁移的文件了。</p>
<p>备份具体操作如下面步骤所示:</p>
<h3 id="本地克隆检出博客的仓库"><a href="#本地克隆检出博客的仓库" class="headerlink" title="本地克隆检出博客的仓库"></a>本地克隆检出博客的仓库</h3><pre><code>git clone https://github.com/your_blog_name/your_blog_name.github.io.git
</code></pre>
<h3 id="创建新的远程hexo分支"><a href="#创建新的远程hexo分支" class="headerlink" title="创建新的远程hexo分支"></a>创建新的远程hexo分支</h3><pre><code>git checkout -b  hexo
git push origin hexo:hexo
</code></pre>
<blockquote>
<p>git checkout -b hexo 本地新建分支hexo,并切换到该分支,等同于git branch hexo; git checkout hexo； git push origin hexo:hexo 提交本地新建分支hexo到远程服务器hexo分支(origin是默认远程主机名)；<br>git push origin :hexo或者 git push origin –delete hexo 删除远程分支hexo；<br>git branch 可以查看当前分支；<br>git branch -a 可以查看所有分支(包括远程分支)；</p>
</blockquote>
<h3 id="备份必要的源文件"><a href="#备份必要的源文件" class="headerlink" title="备份必要的源文件"></a>备份必要的源文件</h3><p>将Hexo目录下的<code>_post</code>文件夹(包含.md结尾的博客原文), 博客的站点配置文件<code>_config.yml</code> 和Next主题配置文件<code>_config.yml</code>通过新建的hexo分支提交即可,当然还可以备份自己觉得必要的一些文件如图片，其他文本文件</p>
<pre><code>git checkout  hexo  
back up your hexo src file
git add .
git commit -m . &quot;back up my hexo src file&quot;
git push origin hexo:hexo
git checkout -b hexo 切换到hexo分支;
</code></pre>
<h2 id="博客文件恢复"><a href="#博客文件恢复" class="headerlink" title="博客文件恢复"></a>博客文件恢复</h2><hr>
<p>博客文件备份后，对于重装系统或更换电脑了需要重新恢复博客搭建，包括以下一些步骤。</p>
<h3 id="安装必要的软件"><a href="#安装必要的软件" class="headerlink" title="安装必要的软件"></a>安装必要的软件</h3><p>安装Hexo博客必要的软件包括git, node.js, hexo, Next等安装及运行。</p>
<h4 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h4><pre><code>sudo apt-get update
sudo apt-get install git 
git config --global usr.name &quot;Your Name&quot;
git config --global usr.email &quot;youremail@domain.com&quot;
git config --list  // 查看配置信息
ssh-keygen -C  &quot;youremail@domain.com&quot; -t rsa  // 在~/.ssh下创建私钥和公钥,将公钥拷贝到github的博客仓库的Deploy Key中
</code></pre>
<h4 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h4><p>官网下载二进制文件解压，设置路径安装或源码安装。</p>
<h4 id="hexo安装和配置"><a href="#hexo安装和配置" class="headerlink" title="hexo安装和配置"></a>hexo安装和配置</h4><pre><code>sudo apt-get update
npm install -g hexo-cli
hexo init your_blog_folder
cd your_blog_folder
npm install
</code></pre>
<h4 id="Next安装和配置"><a href="#Next安装和配置" class="headerlink" title="Next安装和配置"></a>Next安装和配置</h4><pre><code>cd your_blog_folder
git clone https://github.com/next-theme/hexo-theme-next themes/next
</code></pre>
<blockquote>
<p>Next主题仓库经过了几次变更，最新的仓库名称地址为: <a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a><br>Next主题升级方法:<a href="https://theme-next.js.org/docs/getting-started/upgrade">https://theme-next.js.org/docs/getting-started/upgrade</a></p>
</blockquote>
<h3 id="恢复博客站点和Next主题配置文件"><a href="#恢复博客站点和Next主题配置文件" class="headerlink" title="恢复博客站点和Next主题配置文件"></a>恢复博客站点和Next主题配置文件</h3><p>将备份的博客站点和Next主题配置文件替换新的hexo博客和Next主题,将备份的_post文件夹替换新的文件夹。</p>
<blockquote>
<p>注意有时候hexo或Next版本升级后配置文件格式会有一些差异，注意替换前比较一下这些差异</p>
</blockquote>
<h3 id="一些额外修改配置"><a href="#一些额外修改配置" class="headerlink" title="一些额外修改配置"></a>一些额外修改配置</h3><h4 id="修复配置tags-categories-页面跳转问题"><a href="#修复配置tags-categories-页面跳转问题" class="headerlink" title="修复配置tags, categories,页面跳转问题"></a>修复配置tags, categories,页面跳转问题</h4><ol>
<li>新增加页面 <figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">page</span> tags/categories</span><br></pre></td></tr></table></figure></li>
<li>在新加的页面index.md里面增加以下行更改页面类型 <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>: <span class="string">&quot;tags&quot;</span> <span class="keyword">or</span> <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="修复local-search功能"><a href="#修复local-search功能" class="headerlink" title="修复local search功能"></a>修复local search功能</h4><ol>
<li>安装搜索插件 <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li>
<li>确保站点配置文件增加了以下配置 <figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">search:</span></span><br><span class="line"><span class="symbol">path:</span> search.xml</span><br><span class="line"><span class="symbol">field:</span> post</span><br><span class="line"><span class="symbol">format:</span> html</span><br><span class="line"><span class="symbol">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li>
<li>确保主题配置文件增加了以下配置 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Hexo-Deploy权限问题"><a href="#Hexo-Deploy权限问题" class="headerlink" title="Hexo Deploy权限问题"></a>Hexo Deploy权限问题</h4><ol>
<li>安装deploy git 插件 <figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li>
<li>确保站点配置文件进行了git类型配置 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repo:</span><br><span class="line">    <span class="selector-id">#github</span>:  https:<span class="comment">//github.com/franktly/franktly.github.io.git,master</span></span><br><span class="line">    github:  git@github<span class="selector-class">.com</span>:franktly/franktly<span class="selector-class">.github</span><span class="selector-class">.io</span><span class="selector-class">.git</span>,master</span><br><span class="line">    <span class="selector-id">#gitcafe</span>: https:<span class="comment">//git.coding.net/franktly/franktly.git,gitcafe-pages</span></span><br><span class="line">    gitcafe: git@git<span class="selector-class">.coding</span><span class="selector-class">.net</span>:franktly/franktly<span class="selector-class">.git</span>,gitcafe-pages</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>确保之前的ssh私钥和公钥已经生成和配置<br>若git协议不行可以试试https协议</p>
</blockquote>
<h4 id="博客图片相对路径配置问题"><a href="#博客图片相对路径配置问题" class="headerlink" title="博客图片相对路径配置问题"></a>博客图片相对路径配置问题</h4><p>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中, 即相对路径配置方法,实现该方法有两个步骤：<br>首先安装<code>Hexo-asset-image</code>插件：</p>
<pre><code>npm install hexo-asset-image --save
</code></pre>
<p>然后，修改站点配置文件_config.yml:</p>
<pre><code>post_asset_folder: true
</code></pre>
<p>安装成功插件，将_config.yml文件中的配置项post_asset_folder设为true后，执行命令<code>$ hexo new post_name</code>，在<code>source/_posts</code>中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p>
<pre><code>![image_desp](image.jpg)
</code></pre>
<h4 id="搜索SEO优化"><a href="#搜索SEO优化" class="headerlink" title="搜索SEO优化"></a>搜索SEO优化</h4><p>搜索SEO优化方法见让<a href="/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/index.html">Baidu和Google收录Hexo博客</a></p>
<h4 id="博客源文件和配置备份"><a href="#博客源文件和配置备份" class="headerlink" title="博客源文件和配置备份"></a>博客源文件和配置备份</h4><p>见个人Github主页博客仓库的<code>Hexo</code>分支<a href="https://github.com/franktly/franktly.github.io/tree/hexo">ReadMe</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>基本上通过以上几个步骤就可以在较短的时间内将Hexo博客迁移到一个新的系统环境上，这样不用每次重装系统或更换电脑都折腾配置和软件。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>让Baidu和Google收录Hexo博客</title>
    <url>/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>搭建自己的博客，然后写了几十篇文章，悲催的是发现用搜索引擎无法搜索到自己的博客网站。按照网上的方法和自己的摸索，下面以<code>Baidu</code>和<code>Google</code>搜索为例简单介绍了下怎么让搜索引擎搜到自己的博客网站（由于<code>hexo</code>博客是同时部署在<code>Github</code>和<code>Coding</code>上的，虽然百度搜索对外网<code>Github</code>有屏蔽，但仍然可以通过<code>Coding</code>搜索到）</p>
<span id="more"></span>


<hr>
<h1 id="验证网站"><a href="#验证网站" class="headerlink" title="验证网站"></a>验证网站</h1><hr>
<h2 id="Google搜索"><a href="#Google搜索" class="headerlink" title="Google搜索"></a><code>Google</code>搜索</h2><hr>
<p>1.登陆<a href="https://www.google.com/webmasters/tools/home" title="google search console">Google Search Console</a>，输入需要验证的网站域名，默认有两种方式选择网域类型：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/gsc1.png" alt="gsc-login"></p>
<p>2.<code>Search Console</code> DNS记录验证域名所有权:<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/gsc2.png" alt="gsc-verify"></p>
<p>3.在域名解析服务商即生成域名解析服务器的地方，而非域名提供商店上增加上一步选择的记录，本人选择的是<code>TXT</code>类型，DNSPod域名服务器：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/gsc3.png" alt="gsc-addrecord"></p>
<p>4.检查网站，请求加入Google编入索引：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/gsc4.png" alt="gsc-check"></p>
<h2 id="Baidu搜索"><a href="#Baidu搜索" class="headerlink" title="Baidu搜索"></a><code>Baidu</code>搜索</h2><hr>
<p>1.<a href="https://ziyuan.baidu.com/site/index">百度站长</a>的站点管理-添加网站，输入域名结果：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/bd1.png" alt="bd"></p>
<p>2.百度站长工具有三种方式进行站点验证，本人采用第三种<code>CNAME</code>方式：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/bd2.png" alt="bd"></p>
<p>3.登陆域名解析服务器（本人是<code>DNSPod</code>）增加一条<code>CNAME</code>记录：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/bd3.png" alt="bd"></p>
<h1 id="提交Sitemap"><a href="#提交Sitemap" class="headerlink" title="提交Sitemap"></a>提交<code>Sitemap</code></h1><hr>
<h2 id="生成Google和Baidu-Sitemap文件"><a href="#生成Google和Baidu-Sitemap文件" class="headerlink" title="生成Google和Baidu Sitemap文件"></a>生成<code>Google</code>和<code>Baidu</code> <code>Sitemap</code>文件</h2><hr>
<p><code>Sitemap</code>是一种文件，可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知<code>Google</code>和<code>Baidu</code>等搜索引擎，以便更加智能的抓取你的网站信息</p>
<h3 id="安装hexo-sitemap插件"><a href="#安装hexo-sitemap插件" class="headerlink" title="安装hexo sitemap插件"></a>安装<code>hexo sitemap</code>插件</h3><hr>
<p>命令行输入如下命令：</p>
<pre><code>npm install hexo-generator-sitemap // Google 
npm install hexo-generator-baidu-sitemap // Baidu
</code></pre>
<h3 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h3><hr>
<p>在<code>_config.yml</code>全局配置文件中增加如下文本：</p>
<pre><code># Extensions
Plugins: 
\- hexo-generator-sitemap
# 自动生成sitemap
sitemap:
  path: sitemap.xml
baidusitemap:
  path: baidusitemap.xml
</code></pre>
<p>然后重新<code>hexo g </code>博客即可以在博客的<code>public</code>文件夹下生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>文件：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/bd5.png" alt="bd"></p>
<h2 id="提交Sitemap文件"><a href="#提交Sitemap文件" class="headerlink" title="提交Sitemap文件"></a>提交<code>Sitemap</code>文件</h2><hr>
<h3 id="Google搜索-1"><a href="#Google搜索-1" class="headerlink" title="Google搜索"></a><code>Google</code>搜索</h3><hr>
<p>在站点地图中提交上一步生成的<code>sitemap.xml</code>文件：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/gsc5.png" alt="gcs-sitemap"></p>
<blockquote>
<p>千万要注意博客的标题中不用包含XML的实体字符如<code>&amp;</code>、<code>&lt;</code>、<code> &gt;</code>等等，否则提交之后，会提示解析错误：</p>
</blockquote>
<h3 id="Baidu搜索-1"><a href="#Baidu搜索-1" class="headerlink" title="Baidu搜索"></a><code>Baidu</code>搜索</h3><hr>
<p>百度支持三种自动提交方式：<br><strong>主动推送</strong>、<strong>自动推送</strong>和<strong>sitemap</strong>提交，三者的搜索发现的效率和难度依次递减</p>
<blockquote>
<p>如何选择链接提交方式<br>1 主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。<br>2 自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。<br>3 sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。<br>4 手动提交：一次性提交链接给百度，可以使用此种方式。</p>
</blockquote>
<h4 id="Baidu-Sitemap"><a href="#Baidu-Sitemap" class="headerlink" title="Baidu Sitemap"></a><code>Baidu Sitemap</code></h4><p>在站点地图的自动提交选项卡的<code>sitemap</code>部分中提交上一步生成的<code>sitemap.xml</code>文件的地址，点击提交即可：<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/bd4.png" alt="bd-sitemap"></p>
<h4 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h4><p>一般的Hexo主题如Next的主题配置文件<code>_config.yml</code>提供了baidu Push 功能字段，直接将该字段设置为<code>true</code>即可：</p>
<pre><code>baidu_push: true
</code></pre>
<p>若没有该字段，则把如下的<code>JS</code>代码放在网页页面中即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> bp = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> curProtocol = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">protocol</span>.<span class="title function_">split</span>(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (curProtocol === <span class="string">&#x27;https&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        bp.<span class="property">src</span> = <span class="string">&#x27;https://zz.bdstatic.com/linksubmit/push.js&#x27;</span>;        </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        bp.<span class="property">src</span> = <span class="string">&#x27;http://push.zhanzhang.baidu.com/push.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> s = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;script&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    s.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(bp, s);</span></span><br><span class="line"><span class="language-javascript">&#125;)();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>最好把上述代码放在hexo生成的每个页面的公共部分,本博客放在<code>blog\themes\next\layout\_layout.swig</code>的<code>&lt;body&gt;</code>标签的最后面</p>
</blockquote>
<h4 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h4><p>需要编写主动推送代码，<a href="http://zhanzhang.baidu.com/college/courseinfo?id=267&page=2#h2_article_title8"><strong>主动推送编写示例</strong></a></p>
<h1 id="添加robots-txt文件"><a href="#添加robots-txt文件" class="headerlink" title="添加robots.txt文件"></a>添加<code>robots.txt</code>文件</h1><hr>
<p>在博客<code>source</code>文件夹下增加robots.txt文件，内容如下所示：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line"><span class="symbol">Allow:</span> /</span><br><span class="line"><span class="symbol">Allow:</span> <span class="keyword">/categories/</span></span><br><span class="line"><span class="symbol">Allow:</span> <span class="keyword">/tags/</span></span><br><span class="line"><span class="symbol">Allow:</span> <span class="keyword">/archives/</span></span><br><span class="line"><span class="symbol">Allow:</span> <span class="keyword">/about/</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/vendors/</span></span><br><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/js/</span></span><br><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/css/</span></span><br><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/fonts/</span></span><br><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/vendors/</span></span><br><span class="line"><span class="symbol">Disallow:</span> <span class="keyword">/fancybox/</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">Sitemap:</span> http:<span class="comment">//your_domain_name/sitemap.xml</span></span><br><span class="line"><span class="symbol">Sitemap:</span> http:<span class="comment">//your_domain_name/baidusitemap.xml</span></span><br></pre></td></tr></table></figure>

<h1 id="等待处理"><a href="#等待处理" class="headerlink" title="等待处理"></a>等待处理</h1><hr>
<p>过几天之后，Google和Baidu就会处理你提交的站点，再次输入网址或相关关键字，就可以搜索到自己的博客了<br><img src="http://www.taolingyang.com/2016/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%90%9C%E7%B4%A2%E4%BC%98%E5%8C%96/google.png" alt="search"></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>exit和_exit函数区别</title>
    <url>/2016/06/11/Linux-exit%E5%92%8C_exit%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><code>exit</code>和<code>_exit</code>都是Linux下的退出函数，exit作用是：直接使进程停止运行，清除其使用的内存空间，并销毁其在内核中的各种数据结构；而exit是_exit函数的进一步封装，执行了其他的清理工作，然后才调用_exit函数，在与输入输出或fork等函数一起使用时候会表现出一些差异</p>
<span id="more"></span>

<h2 id="exit-amp-exit"><a href="#exit-amp-exit" class="headerlink" title="exit &amp; _exit"></a>exit &amp; _exit</h2><hr>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先分别看看C&#x2F;C++标准里面的各自使用说明<br>1._exit</p>
<pre><code>void _exit (int status);
Terminate calling process
Terminates the process normally by returning control to the host environment, but without performing any of the regular cleanup tasks for terminating processes (as function exit does).
No object destructors, nor functions registered by atexit or at_quick_exit are called.
Whether C streams are closed and/or flushed, and files open with tmpfile are removed depends on the particular system or library implementation.
If status is zero or EXIT_SUCCESS, a successful termination status is returned to the host environment.
If status is EXIT_FAILURE, an unsuccessful termination status is returned to the host environment.
Otherwise, the status returned depends on the system and library implementation.
Parameters:
status
Status code.
If this is 0 or EXIT_SUCCESS, it indicates success.
If it is EXIT_FAILURE, it indicates failure.
</code></pre>
<blockquote>
<p>可以看出_exit主要特点是在退出的时候，不会执行常规的cleanup清理工作，对象的析构也不会执行，通过atexit或_atquick_exit函数注册的自定义退出执行代码段函数也不会执行，对于是否C数据流是否关闭或刷新缓存区，临时打开的文件释放移除跟特定的系统或库实现有关系<br>对于linux系统而言，_exit需要包含头文件为<code>unistd.h</code></p>
</blockquote>
<p>2.exit</p>
<pre><code>void exit (int status);
Terminate calling process
Terminates the process normally, performing the regular cleanup for terminating programs.
Normal program termination performs the following (in the same order):
Objects associated with the current thread with thread storage duration are destroyed (C++11 only).
Objects with static storage duration are destroyed (C++) and functions registered with atexit are called.
All C streams (open with functions in &lt;cstdio&gt;) are closed (and flushed, if buffered), and all files created with tmpfile are removed.
Control is returned to the host environment.
Note that objects with automatic storage are not destroyed by calling exit (C++).
If status is zero or EXIT_SUCCESS, a successful termination status is returned to the host environment.
If status is EXIT_FAILURE, an unsuccessful termination status is returned to the host environment.
Otherwise, the status returned depends on the system and library implementation.
For a similar function that does not perform the cleanup described above, see quick_exit.
Parameters:
status
Status code.
If this is 0 or EXIT_SUCCESS, it indicates success.
If it is EXIT_FAILURE, it indicates failure.
</code></pre>
<blockquote>
<p>可以看出exit主要特点是在退出的时候，与_exit不同，会执行常规的cleanup清理工作，静态存储的对象也会销毁，但是对于自动存储的对象则不会销毁，通过atexit或_atquick_exit函数注册的自定义退出执行代码段函数同样会执行，对于C数据流也会关闭或刷新缓存区，会释放临时打开的文件对于，<strong>可见与_exit主要区别在于退出前是否执行清理工作包括对象销毁、文件移除、数据缓存关闭或刷新等操作上</strong><br>exit需要包含头文件为<code>stdlib.h</code></p>
</blockquote>
<p>对于异常退出还有个abort函数，标准库是这样简单的说明的：</p>
<pre><code>void abort (void);
Abort current process
Aborts the current process, producing an abnormal program termination.
The function raises the SIGABRT signal (as if raise(SIGABRT) was called). This, if uncaught, causes the program to terminate returning a platform-dependent unsuccessful termination error code to the host environment.
The program is terminated without destroying any object and without calling any of the functions passed to atexit or at_quick_exit.
</code></pre>
<blockquote>
<p>abort会产生SIGABRT信号，就像调用了raise(SIGABRT)一样，终止时候不会销毁任何对象也不会调用通过atexit或at_quick_exit注册的用户自定义退出代码段</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr>
<p>1.与printf等带有缓存区的I&#x2F;O使用情况<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;I am a string with \\n end \n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;I am a string without \\n&quot;</span>);</span><br><span class="line"> _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am a string with \n end 
</code></pre>
<blockquote>
<p>只有第一句带有\n会打印，因为带有行缓存的IO接口遇到\n或EOF或缓存区满会自动输出，而第二句由于_exit退出未刷新清空缓存区到输出设备，故未显示出来</p>
</blockquote>
<p>若改为exit(0)，则运行结果为：</p>
<pre><code>I am a string with \n end 
I am a string without \n⏎  
</code></pre>
<blockquote>
<p>由于exit退出会刷新清空缓存区到输出设备，故第二句也显示出来了</p>
</blockquote>
<p>2.与vfork等创建新进程共享地址空间的使用情况<br>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global_a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> auto_a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before vfork\n&quot;</span>);<span class="comment">// need&#x27;t flush, will print because of \n exit</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;global_a = %d, auto_a = %d\n&quot;</span>, global_a, auto_a);</span><br><span class="line"></span><br><span class="line"> pid = <span class="built_in">vfork</span>();</span><br><span class="line"> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;vfork error!\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">// child process</span></span><br><span class="line"> &#123;</span><br><span class="line">  global_a++; <span class="comment">// modify global var</span></span><br><span class="line">  auto_a++; <span class="comment">// modifty auto var</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// exit child process, but _exit is better`</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;after vfork\n&quot;</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;pid = %d, global_a  = %d, auto_a = %d\n&quot;</span>, pid, global_a, auto_a);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;         </span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>before vfork
global_a = 1, auto_a = 1
after vfork
pid = 9040, global_a  = 2, auto_a = 2
</code></pre>
<blockquote>
<p>可以看到，子进程虽然退出但是，父进程仍然有输出，虽然子进程和父进程在vfork时候共享了标准输入输出，但是子进程exit时候，可能是递减了引用计数（vfork调用时候增加了该引用计数，类似于多进程socket创建），不可能关闭父进程，所以仍有输出，由于数据是共享的，故父进程的数据被改变了<br>但是在其他类unix系统中父进程可能就没输出了，原因是子进程调用了exit之后，刷新关闭了所有IO流，虽然是子进程进行的，但是与父进程共享了地址空间，所以可能影响到了父进程的输入输出，所以比较安全的做法是子进程使用_exit退出，但是它会直接将进程关闭，缓存区数据会丢失（可以通过手动调用flush刷新输出），如果想保持数据完整性，就还是要使用exit</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.<code>exit</code>函数能保证数据的完整性，在退出之前会做些清理工作，然后再调用_exit再退出的；而_exit是直接退出程序，但是不管咋样，两者都会关闭进程打开的文件描述符，释放内存<br>2.在<code>fork</code>或<code>vfork</code>创建的子进程分支中，推荐使用_exit，防止标准IO的缓存区被清空两次，临时文件被意外清除或静态对象被意外销毁，推荐做法是exit在main函数退出时候只调用一次<br>3.关于标准IO的几种缓冲机制：</p>
<ul>
<li>全缓冲<br>全缓冲指的是系统在填满标准IO缓冲区之后才进行实际的IO操作；对于驻留在磁盘上的文件来说通常是由标准IO库实施全缓冲</li>
<li>行缓冲<br>在这种情况下，标准IO在输入和输出中遇到换行符时执行IO操作；当流涉及终端的时候，通常使用的是行缓冲，如本文的printf输出</li>
<li>无缓冲<br>无缓冲指的是标准IO库不对字符进行缓冲存储；标准出错流stderr通常是无缓冲的</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>exit</tag>
      </tags>
  </entry>
  <entry>
    <title>Gcc编译链接及常用选项总结</title>
    <url>/2016/06/08/Linux-Gcc%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>GNU CC（简称Gcc）是GNU项目中符合ANSI C标准的编译系统，能够编译用C、C++和Object- C等语言编写的程序。Gcc不仅功能强大，而且可以编译如C、C++、Object C、Java等多种语言，而且Gcc又是一个交叉平台编译器，它能够在当前CPU平台上为多种不同体系结构的硬件平台开发软件。本章中的示例均采用Gcc版本为4.8.2。</p>
<span id="more"></span>

<h2 id="Gcc编译链接流程"><a href="#Gcc编译链接流程" class="headerlink" title="Gcc编译链接流程"></a>Gcc编译链接流程</h2><hr>
<p>Gcc编译链接流程分为<strong>四个步骤</strong>:</p>
<ol>
<li>预处理(Pre-Processsing)</li>
<li>编译(Compiling)</li>
<li>汇编(Assembling)</li>
<li>链接(Linking)</li>
</ol>
<p>Gcc指令的一般格式为：</p>
<pre><code>gcc [option1] compile-files [option2] object-files
</code></pre>
<blockquote>
<p>其中目标文件可缺省，Gcc默认生成的可执行文件命名为:编译文件名.out</p>
</blockquote>
<p>下面以简单的<code>hello world</code>程序为例说明Gcc编译的四个过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="预处理过程"><a href="#预处理过程" class="headerlink" title="预处理过程"></a>预处理过程</h3><p><code>option1</code> 为<code>-E</code>,生成的目标文件为<code>.i</code>(c)或<code>.ii</code>(c++)后缀的经过预处理的编译输入文件,Gcc指令为：</p>
<pre><code>tly@ubuntu ~&gt; gcc -E test.c -o test.i
</code></pre>
<p>生成的预编译文件内容为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">27</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">374</span> <span class="string">&quot;/usr/include/features.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/i386-linux-gnu/sys/cdefs.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line">... 省略</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title">ctermid</span> <span class="params">(<span class="type">char</span> *__s)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">913</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">flockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">ftrylockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">943</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;test.c&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gcc预处理过程把<code>&lt;stdio.h&gt;</code>的内容插入到hello.i文件中了</p>
</blockquote>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>option1</code> 为<code>-S</code>,生成的目标文件为<code>.s</code>或<code>.S</code>后缀的经过编译但是没有汇编过的汇编文件,Gcc编译过程首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，Gcc把代码翻译成汇编语言Gcc指令为：</p>
<pre><code>tly@ubuntu ~&gt; gcc -S test.i -o test.s
</code></pre>
<p>生成的编译之后的汇编文件内容为：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">        <span class="string">.file</span>   <span class="string">&quot;test.c&quot;</span></span><br><span class="line">        <span class="string">.section</span>        <span class="string">.rodata</span></span><br><span class="line"><span class="string">.LC0</span>:</span><br><span class="line">        <span class="string">.string</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">        <span class="string">.text</span></span><br><span class="line">        <span class="string">.globl</span>  main</span><br><span class="line">        <span class="string">.type</span>   main, @function</span><br><span class="line">main:</span><br><span class="line"><span class="string">.LFB0</span>:</span><br><span class="line">        <span class="string">.cfi_startproc</span></span><br><span class="line">        pushl   %ebp</span><br><span class="line">        <span class="string">.cfi_def_cfa_offset</span> 8</span><br><span class="line">        <span class="string">.cfi_offset</span> 5, -8</span><br><span class="line">        movl    %esp, %ebp</span><br><span class="line">        <span class="string">.cfi_def_cfa_register</span> 5</span><br><span class="line">        andl    $-16, %esp</span><br><span class="line">        subl    $16, %esp</span><br><span class="line">        movl    $<span class="string">.LC0</span>, <span class="params">(%esp)</span></span><br><span class="line">        call    printf</span><br><span class="line">        nop</span><br><span class="line">        leave</span><br><span class="line">        <span class="string">.cfi_restore</span> 5</span><br><span class="line">        <span class="string">.cfi_def_cfa</span> 4, 4</span><br><span class="line">        ret</span><br><span class="line">        <span class="string">.cfi_endproc</span></span><br><span class="line"><span class="string">.LFE0</span>:</span><br><span class="line">        <span class="string">.size</span>   main, <span class="string">.-main</span></span><br><span class="line">        <span class="string">.ident</span>  <span class="string">&quot;GCC: (Ubuntu 4.8.2-19ubuntu1) 4.8.2&quot;</span></span><br><span class="line">        <span class="string">.section</span>        <span class="string">.note.GNU-stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br><span class="line">~                                                       </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gcc编译过程已经将其转化为汇编语言了</p>
</blockquote>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p><code>option1</code> 为<code>-c</code>，生成的目标文件为以<code>.o</code>为后缀的二进制目标代码文件，Gcc指令为：</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.s -o test.o
</code></pre>
<p>生成的汇编之后的目标文件内容为：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">^?ELF^A^A^A^@^@^@^@^@^@^@^@^@^A^@^C^@^A^@^@^@^@^@^@^@^@^@^@^@^X^A^@^@^@^@^@^@4^@^@^@^@^@(^@^M^@</span><br><span class="line">^@U&lt;<span class="number">89</span>&gt;å&lt;<span class="number">83</span>&gt;äð&lt;<span class="number">83</span>&gt;ì^PÇ^D$^@^@^@^@èüÿÿÿ&lt;<span class="number">90</span>&gt;ÉÃhello world^@^@GCC: (Ubuntu <span class="number">4.8</span><span class="number">.2</span><span class="number">-19</span>ubuntu1) <span class="number">4.8</span><span class="number">.2</span>^@^@^@^@^T^@^@^@^@^@^@^@^AzR^@^A|^H^A^[^L^D^D&lt;<span class="number">88</span>&gt;^A^@^@^\^@^@^@^\^@^@^@^@^@^@^@^X^@^@^@^@A^N^H&lt;<span class="number">85</span>&gt;^BB^M^ETÅ^L^D^D^@^@^@.symtab^@.strtab^@.shstrtab^@.rel.<span class="keyword">text</span>^@.data^@.bss^@.rodata^@.comment^@.note.GNU-stack^@.rel.eh_frame^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^_^@^@^@^A^@^@^@^F^@^@^@^@^@^@^@4^@^@^@^X^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^[^@^@^@  ^@^@^@^@^@^@^@^@^@^@^@ä^C^@^@^P^@^@^@^K^@^@^@^A^@^@^@^D^@^@^@^H^@^@^@%^@^@^@^A^@^@^@^C^@^@^@^@^@^@^@L^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@+^@^@^@^H^@^@^@^C^@^@^@^@^@^@^@L^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@0^@^@^@^A^@^@^@^B^@^@^@^@^@^@^@L^@^@^@^L^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@8^@^@^@^A^@^@^@0^@^@^@^@^@^@^@X^@^@^@%^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^A^@^@^@A^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@&#125;^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@U^@^@^@^A^@^@^@^B^@^@^@^@^@^@^@&lt;<span class="number">80</span>&gt;^@^@^@8^@^@^@^@^@^@^@^@^@^@^@^D^@^@^@^@^@^@^@Q^@^@^@        ^@^@^@^@^@^@^@^@^@^@^@ô^C^@^@^H^@^@^@^K^@^@^@^H^@^@^@^D^@^@^@^H^@^@^@^Q^@^@^@^C^@^@^@^@^@^@^@^@^@^@^@¸^@^@^@_^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^A^@^@^@^B^@^@^@^@^@^@^@^@^@^@^@ ^C^@^@°^@^@^@^L^@^@^@       ^@^@^@^D^@^@^@^P^@^@^@  ^@^@^@^C^@^@^@^@^@^@^@^@^@^@^@Ð^C^@^@^T^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@^A^@^@^@^@^@^@^@^@^@^@^@^D^@ñÿ^@^@^@^@^@^@^@^@^@^@^@^@^C^@^A^@^@^@^@^@^@^@^@^@^@^@^@^@^C^@^C^@^@^@^@^@^@^@^@^@^@^@^@^@^C^@^D^@^@^@^@^@^@^@^@^@^@^@^@^@^C^@^E^@^@^@^@^@^@^@^@^@^@^@^@^@^C^@^G^@^@^@^@^@^@^@^@^@^@^@^@^@^C^@^H^@^@^@^@^@^@^@^@^@^@^@^@^@^C^@^F^@^H^@^@^@^@^@^@^@^X^@^@^@^R^@^A^@^M^@^@^@^@^@^@^@^@^@^@^@^P^@^@^@^@test.c^@main^@printf^@^L^@^@^@^A^E^@^@^Q^@^@^@^B</span><br><span class="line">^@^@ ^@^@^@^B^B^@^@</span><br><span class="line">                                                </span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gcc汇编成的.o目标文件是乱码，不过可以通过nm命令查看其符号表：</p>
</blockquote>
<pre><code>tly@ubuntu ~&gt; nm test.o
00000000 T main
         U printf
</code></pre>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>在成功编译之后，就进入了链接阶段，这个<code>hello world</code>小程序的链接过程主要是查找包含的<code>stdio.h</code>头文件的<code>printf()</code>函数的实现（因为<code>stdio.h</code>头文件只包含函数声明)，这个函数实现是在<code>libc.so.6</code>的库文件中。在没有特别指定时，Gcc会到系统默认的搜索路径<code>/usr/lib</code>下进行查找，也就是链接到<code>libc.so.6</code>库函数中去，这样就能实现函数<code>printf()</code>了，而这也就是链接的作用。</p>
<blockquote>
<p>函数库一般分为<strong>静态库</strong>和<strong>动态库</strong>两种。<br><strong>静态库</strong>:是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为<code>.a</code>(linux)或<code>.lib</code>(windows)。<br><strong>动态库</strong>: 与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由<em>运行时链接文件加载库</em>，这样可以节省系统的开销。动态库一般为<code>.so</code>(linux)或<code>.dll</code>(windows)，如前面所述的libc.so.6就是动态库。<br>Gcc在编译时默认使用动态库</p>
</blockquote>
<p>当然，也可以一次性使用<code>-c</code>选项，直接生成目标文件<code>test.o</code>,Gcc指令为:</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o
</code></pre>
<p>完成了链接之后，Gcc就可以生成可执行文件<code>test</code>,Gcc指令为:</p>
<pre><code>tly@ubuntu ~&gt; gcc test.o -o test
</code></pre>
<p>运行该可执行文件<code>test</code>：</p>
<pre><code>tly@ubuntu ~&gt; ./test
hello world⏎      
</code></pre>
<h3 id="Gcc编译选项分析"><a href="#Gcc编译选项分析" class="headerlink" title="Gcc编译选项分析"></a>Gcc编译选项分析</h3><p>Gcc有超过100个的可用选项，一般主要包括以下五种类型选项：</p>
<ol>
<li>总体选项</li>
<li>告警和出错选项</li>
<li>优化选项</li>
<li>体系结构相关选项</li>
</ol>
<h4 id="总体选项"><a href="#总体选项" class="headerlink" title="总体选项"></a>总体选项</h4><hr>
<table>
<thead>
<tr>
<th align="center">选项名</th>
<th align="center">选项意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-E</td>
<td align="center">只是编译不汇编，生成汇编代码.s</td>
</tr>
<tr>
<td align="center">-S</td>
<td align="center">只进行预编译生成.i，不做其他处理</td>
</tr>
<tr>
<td align="center">-c</td>
<td align="center">只是编译不链接，生成目标文件.o</td>
</tr>
<tr>
<td align="center">-g</td>
<td align="center">在可执行程序中包含标准调试信息</td>
</tr>
<tr>
<td align="center">-o file</td>
<td align="center">把输出文件输出到file里</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">打印出编译器内部编译各过程的命令行信息和编译器的版本</td>
</tr>
<tr>
<td align="center">-I dir</td>
<td align="center">在头文件的搜索路径列表中添加dir目录</td>
</tr>
<tr>
<td align="center">-L dir</td>
<td align="center">在库文件的搜索路径列表中添加dir目录</td>
</tr>
<tr>
<td align="center">-static</td>
<td align="center">链接静态库</td>
</tr>
<tr>
<td align="center">-llibrary</td>
<td align="center">链接名为library的库文件库</td>
</tr>
</tbody></table>
<blockquote>
<p>对于<code>-I dir</code>选项可在头文件的搜索路径列表中添加dir目录。由于Linux中头文件都默认放到了<code>/usr/include/</code>目录下，因此，当用户希望添加放置在其他位置的头文件时，就可以通过<code>-I dir</code>选项来指定(<code>-L dir</code>类似)，这样，Gcc就会到相应的位置查找对应的目录<br><code>&lt;&gt;</code>表示在标准路径中搜索头文件，<code>“ ”</code>表示在本目录中搜索，如果把自定义的头文件<code>#include&lt;my.h&gt;改为</code>#include “my.h”<code>，就不需要加上“-I”选项了</code><br><code>-I dir</code>和<code>-L dir</code>都只是指定了路径，而没有指定文件，因此不能在路径中包含文件名</p>
</blockquote>
<blockquote>
<p>对于<code>-llibrary</code>选项，省去了前缀<code>lib</code>,它实际上是指示Gcc去连接库文件liblibrary.so。由于在Linux下的库文件命名时有一个规定：必须以<code>lib</code>三个字母开头。因此在用<code>-l</code>选项指定链接的库文件名时可以省去<code>lib</code>三个字母。也就是说Gcc在对<code>-llibrary</code>进行处理时，会自动去链接名为<code>liblibrary.so</code>的文件</p>
</blockquote>
<h4 id="告警和出错选项"><a href="#告警和出错选项" class="headerlink" title="告警和出错选项"></a>告警和出错选项</h4><hr>
<table>
<thead>
<tr>
<th align="center">选项名</th>
<th align="center">选项意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-ansi</td>
<td align="center">支持符合ANSI标准的C程序</td>
</tr>
<tr>
<td align="center">-pedantic</td>
<td align="center">允许发出ANSI C标准所列的全部警告信息</td>
</tr>
<tr>
<td align="center">-pedantic-error</td>
<td align="center">允许发出ANSI C标准所列的全部错误信息</td>
</tr>
<tr>
<td align="center">-w</td>
<td align="center">关闭所有告警</td>
</tr>
<tr>
<td align="center">-Wall</td>
<td align="center">允许发出Gcc提供的所有有用的报警信息</td>
</tr>
</tbody></table>
<p>修改上述的<code>helloworld</code>测试程序为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> tmp; <span class="comment">// 增加非ANSI-C类型long long 未使用的临时变量tmp</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回错误类型int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.默认无告警和出错选项情况：</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o
test.c: In function ‘main’:
test.c:6:3: warning: ‘return’ with a value, in function returning void [enabled by default]
   return 0;
   ^
</code></pre>
<blockquote>
<p>只识别了main的错误返回类型int</p>
</blockquote>
<p>2.增加<code>-ansi</code>选项情况：</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o -ansi
test.c: In function ‘main’:
test.c:6:3: warning: ‘return’ with a value, in function returning void [enabled by default]
   return 0;
   ^
</code></pre>
<blockquote>
<p>只识别了main的错误返回类型int</p>
</blockquote>
<p>3.增加<code>-pedantic</code>选项情况：</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o -pedantic
test.c:2:6: warning: return type of ‘main’ is not ‘int’ [-Wmain]
 void main(int argc, char* argv[])
      ^
test.c: In function ‘main’:
test.c:4:8: warning: ISO C90 does not support ‘long long’ [-Wlong-long]
   long long tmp;
        ^
test.c:6:3: warning: ‘return’ with a value, in function returning void [enabled by default]
   return 0;
   ^
</code></pre>
<blockquote>
<p>识别了main的错误返回类型int 和 long long 非 ISO C90 支持类型</p>
</blockquote>
<p>4.增加<code>-pedantic-errors</code>选项情况：</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o -pedantic-errors 
test.c:2:6: error: return type of ‘main’ is not ‘int’ [-Wmain]
 void main(int argc, char* argv[])
      ^
test.c: In function ‘main’:
test.c:4:8: error: ISO C90 does not support ‘long long’ [-Wlong-long]
   long long tmp;
        ^
test.c:6:3: error: ‘return’ with a value, in function returning void
   return 0;
   ^
</code></pre>
<blockquote>
<p>识别了main的错误返回类型int 和 long long 非 ISO C90 支持类型</p>
</blockquote>
<p>5.增加<code>-w</code>选项情况：</p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o -w
</code></pre>
<blockquote>
<p>屏蔽了告警和出错信息</p>
</blockquote>
<p>6.增加<code>-Wall</code>选项情况： </p>
<pre><code>tly@ubuntu ~&gt; gcc -c test.c -o test.o -Wall
test.c:2:6: warning: return type of ‘main’ is not ‘int’ [-Wmain]
 void main(int argc, char* argv[])
      ^
test.c: In function ‘main’:
test.c:6:3: warning: ‘return’ with a value, in function returning void [enabled by default]
   return 0;
   ^
test.c:4:13: warning: unused variable ‘tmp’ [-Wunused-variable]
   long long tmp;
             ^
</code></pre>
<blockquote>
<p>识别了main的错误返回类型int 和临时变量tmp未使用的告警信息</p>
</blockquote>
<h4 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h4><hr>
<table>
<thead>
<tr>
<th align="center">选项名</th>
<th align="center">选项意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-On</td>
<td align="center">n是一个代表优化级别的整数,典型的范围是从0变化到2或3</td>
</tr>
</tbody></table>
<blockquote>
<p>不同的优化级别对应不同的优化处理工作。<br>-O 提供基础级别的优化<br>-O2 提供更加高级的代码优化,会占用更长的编译时间<br>-O3 提供最高级的代码优化<br>进行调试的时候，最好关闭编译优化，否则程序自动优化，执行的步骤可能有变化</p>
</blockquote>
<h4 id="体系结构相关选项"><a href="#体系结构相关选项" class="headerlink" title="体系结构相关选项"></a>体系结构相关选项</h4><hr>
<table>
<thead>
<tr>
<th align="center">选项名</th>
<th align="center">选项意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-mcpu&#x3D;type</td>
<td align="center">对不同的CPU使用相应的CPU指令。可选择的有i386、i486、pentium等</td>
</tr>
<tr>
<td align="center">-mieee-fp</td>
<td align="center">使用IEEE标准进行浮点数的比较</td>
</tr>
<tr>
<td align="center">-mno-ieee-fp</td>
<td align="center">不使用IEEE标准进行浮点数的比较</td>
</tr>
<tr>
<td align="center">-msoft-float</td>
<td align="center">输出包含浮点库调用的目标代码</td>
</tr>
<tr>
<td align="center">-mshort</td>
<td align="center">把int类型作为16位处理，相当于short int</td>
</tr>
<tr>
<td align="center">-mrtd</td>
<td align="center">将函数参数个数固定的函数用ret NUM返回，节省调用函数的一条指令</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Gcc</tag>
        <tag>编译</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title>fork和vfork函数区别</title>
    <url>/2016/06/10/Linux-fork%E5%92%8Cvfork%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Linux系统创建新的进程函数<code>fork</code>及<code>vfork</code>有相似地方也有不同的地方，本篇通过实例说明两者的特点和使用时候应该注意事项</p>
<span id="more"></span>

<h2 id="fork-amp-vfork"><a href="#fork-amp-vfork" class="headerlink" title="fork &amp; vfork"></a>fork &amp; vfork</h2><hr>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1.相似点：</p>
<ul>
<li><code>fork</code>和<code>vfork</code>均用来创建新的进程，且都是一次调用，两次返回：两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id，若失败返回-1</li>
<li><code>fork</code>和<code>vfork</code>返回后，子进程和父进程都从调用<code>fork</code>或<code>vfork</code>函数返回处开始执行</li>
</ul>
<blockquote>
<p><code>fork</code>和<code>vfork</code>函数在调用返回处分叉，对于同一代码分别各执行一次，通过返回值来区分</p>
</blockquote>
<p>2.不同点：</p>
<ul>
<li><code>fork</code>创建的子进程拷贝了父进程的数据段;子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存。而对于只读的代码段，通常使用共享内存的方式访问<br>而<code>vfork</code>创建的子进程并未拷贝父进程的数据段和代码段，在子进程调用<code>exec</code>或<code>exit</code> 之前与父进程数据是共享的</li>
<li><code>fork</code>创建的子进程和父进程的执行顺序不确定;<br>而<code>vfork</code>创建的子进程必须是先运行的，此时父进程是阻塞的，在子进程调用<code>exec</code>或<code>exit</code> 之前与父进程数据是共享的，在它调用<code>exec</code>或<code>exit</code>之后父进程才可能被调度运行</li>
<li><code>vfork</code>保证子进程先运行，在其调用<code>exec</code>或<code>exit</code>之后父进程才可能被调度运行。如果在<br> 调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁</li>
</ul>
<blockquote>
<p>一个进程process，通常包含三个元素：<br>1.一个可以执行的程序；<br>2.和该进程相关联的全部数据（包括变量，内存空间，缓冲区等等）；<br>3.程序的执行上下文（execution context）</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><hr>
<h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><hr>
<p>1.<code>fork</code>一般情况使用<br>代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the child process with ID[%d]\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the father process with ID[%d]\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am the child process with ID[4060]
I am the father process with ID[4059]
</code></pre>
<blockquote>
<p>执行顺序不定，根据OS调度情况而定</p>
</blockquote>
<p>2.<code>fork</code>拷贝数据段情况使用<br>增加<code>count</code>变量代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    count++; <span class="comment">// add data</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the child process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    count++; <span class="comment">// add data</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the father process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am the child process with ID[4107], count = 1
I am the father process with ID[4106], count = 1
</code></pre>
<blockquote>
<p>由于fork之后，子进程虽然拷贝了父进程数据段(拷贝时候该数据段初始化为0)，但是都是独立的，故分别在自己的数据空间加1了</p>
</blockquote>
<p>3.<code>fork</code>拷贝文件描述符情况使用<br>增加<code>FILE</code>变量代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> mybuffer[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  FILE *file = <span class="built_in">fopen</span>(<span class="string">&quot;/home/tly/networkProgram/my.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>); <span class="comment">// add</span></span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the child process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;child&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fwrite</span>(buffer, <span class="built_in">strlen</span>(<span class="string">&quot;child&quot;</span>)+<span class="number">1</span>, <span class="number">1</span>, file);</span><br><span class="line">    <span class="comment">// &quot;child&quot; write in file my.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;child2&quot;</span>);</span><br><span class="line">    <span class="comment">// &quot;child2&quot; write to buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// let child process run first </span></span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the father process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fread</span>(mybuffer, <span class="built_in">strlen</span>(<span class="string">&quot;child&quot;</span>)+<span class="number">1</span>, <span class="number">1</span>, file);</span><br><span class="line">    <span class="comment">// read from file my.txt to mybuffer and display</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process read is %s\n&quot;</span>, mybuffer);</span><br><span class="line">    <span class="comment">// fork&#x27;s child copy parent&#x27;s file description pointer and so the file contents are the same</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;final buffer is %s\n&quot;</span>, buffer);</span><br><span class="line">  <span class="comment">// fork&#x27;s child copy parent&#x27;s buffer but default value is 0, and the two buffer are independent and final buffer is parent buffer is empty!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am the child process with ID[4211], count = 1
I am the father process with ID[4210], count = 1
father process read is child
final buffer is 
</code></pre>
<blockquote>
<p>可以看到，<code>fork</code>的子进程由于拷贝了父进程的文件描述符指针，导致父进程和子进程操作的是同一个文件，子进程修改了my.txt文件内容，父进程由于读取的是同一个文件也感知到了这个修改<br>但是数据buffer虽然是拷贝的，但是相互是独立的，所以父进程最终读取的buffer还是空的，但是此时子进程的buffer是”child2”</p>
</blockquote>
<h4 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h4><hr>
<p>1.<code>vfork</code>一般情况即未执行<code>_exit(0)</code>情况使用<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = <span class="built_in">vfork</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// child process exec first no matter sleep or not</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the child process with ID[%d]\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the father process with ID[%d]\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am the child process with ID[4294]
I am the father process with ID[4293]
I am the child process with ID[4295]
I am the father process with ID[4293]
I am the child process with ID[4296]
I am the father process with ID[4293]
I am the child process with ID[4297]
...
</code></pre>
<blockquote>
<p>由于<code>vfork</code>创建子进程之后，未调用<code>exit()</code>或<code>exec()</code>函数，且子进程依赖于父进程的进一步动作，导致死锁了，两个进程在不断的打印，都无法正常的结束</p>
</blockquote>
<p>2.<code>vfork</code>增加变量和执行<code>_exit(0)</code>情况使用<br>增加<code>count</code>变量和<code>_exit(0)</code>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = <span class="built_in">vfork</span>();</span><br><span class="line">  <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// child process run first no matter sleep or not</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the child process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">    _exit(<span class="number">0</span>); <span class="comment">// exit without clean up </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the father process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am the child process with ID[4392], count = 1
I am the father process with ID[4391], count = 1
</code></pre>
<blockquote>
<p>可以看到由于子进程未拷贝数据段，而是共享数据段，但由于写时拷贝技术(当需要改变共享数据段中变量的值，则拷贝父进程，在未改变共享数据段之前不拷贝父进程而是共享数据)，子进程的改变共享变量并未体现在父进程上，两者在拷贝完成后就各自数据相互独立了</p>
</blockquote>
<p>3.<code>vfork</code>增加文件描述符执行<code>_exit(0)</code>情况使用<br>增加<code>FILE</code>变量代码和<code>_exit(0)</code>代码:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid;</span><br><span class="line">  pid = <span class="built_in">vfork</span>();</span><br><span class="line">  <span class="type">int</span> count  = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> mybuffer[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  FILE *file = <span class="built_in">fopen</span>(<span class="string">&quot;/home/tly/networkProgram/my2.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// child process run first no matter sleep or not</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the child process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;child&quot;</span>);</span><br><span class="line">    <span class="built_in">fwrite</span>(buffer, <span class="built_in">strlen</span>(<span class="string">&quot;child&quot;</span>)+<span class="number">1</span>, <span class="number">1</span>, file);<span class="comment">// &quot;child&quot; write in file my.txt</span></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;child2&quot;</span>);<span class="comment">// &quot;child2&quot; write to buffer</span></span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am the father process with ID[%d], count = %d\n&quot;</span>, <span class="built_in">getpid</span>(), count);</span><br><span class="line">    <span class="built_in">fread</span>(mybuffer, <span class="built_in">strlen</span>(<span class="string">&quot;child&quot;</span>)+<span class="number">1</span>, <span class="number">1</span>, file);<span class="comment">// read from file my2.txt to mybuffer and display</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;father process read is %s\n&quot;</span>, mybuffer);<span class="comment">// vfork&#x27;s child will not copy father&#x27;s data space , file description and so on, so my2.txt is empty! </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;final buffer is %s\n&quot;</span>, buffer);<span class="comment">// vfork&#x27;s child and parent data space is independent  and final buffer is parent buffer is empty!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am the child process with ID[4392], count = 1
I am the father process with ID[4391], count = 1
father process read is 
final buffer is 
</code></pre>
<blockquote>
<p>可以看到由于子进程未拷贝文件描述符，而是共享数据段，同共享数据段表现一致</p>
</blockquote>
<h3 id="循环fork问题"><a href="#循环fork问题" class="headerlink" title="循环fork问题"></a>循环fork问题</h3><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     fork();</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;  $  &quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;parent = %d, child = %d, i = %d\n&quot;</span>, <span class="built_in">getppid</span>(), <span class="built_in">getpid</span>(), i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>  $  parent = 2661, child = 4745, i = 0
  $  parent = 2661, child = 4745, i = 1
  $  parent = 4745, child = 4747, i = 1
  $  parent = 4745, child = 4746, i = 0
  $  parent = 4745, child = 4746, i = 1
  $  parent = 4746, child = 4748, i = 1
</code></pre>
<blockquote>
<p>可以看到有正常的6次的<code>$</code>打印</p>
</blockquote>
<p>若在<code>printf</code>函数中去掉<code>\n</code>，运行结果：</p>
<pre><code>$  parent = 2661, child = 4821, i = 0  $  parent = 2661, child = 4821, i = 1  $  parent = 2661, child = 4821, i = 0  $  parent = 4821, child = 4823, i = 1  $  parent = 4821, child = 4822, i = 0  $  parent = 4821, child = 4822, i = 1  $  parent = 4821, child = 4822, i = 0  $  parent = 4822, child = 4824, i = 1⏎       
</code></pre>
<blockquote>
<p>有8次的<code>$</code>打印,由于在<code>fork</code>的调用处,整个父进程空间会原模原样地复制到子进程中,包括指令,变量值,程序调用栈,环境变量,<strong>缓冲区</strong>。而<code>printf</code>函数属于块设备输出函数,有缓冲区存在,<code>printf(&quot;  $  &quot;)</code>把<code>&quot;  $  &quot;</code>放到了缓存中,并没有真正的输出,<strong>而在<code>fork</code>的时候,缓存被复制到了子进程空间就多了两个</strong><br>设备有“块设备”和“字符设备”的概念，所谓块设备，就是以一块一块的数据存取的设备，字符设备是一次存取一个字符的设备。磁盘、内存、显示器都是块设备，字符设备如键盘和串口。块设备一般都有缓存，而字符设备一般都没有缓存</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.linux在<code>vfork</code>进程中引入了<strong>写时拷贝</strong>技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。好处是在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据<br>2.引用网上的一段理解：<br>为什么会有<code>vfork</code>,因为以前的<code>fork</code>很傻,它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，而通常在子进程中会执行exec调用，这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了<code>vfork</code>，它产生的子进程刚开始暂时与父进程共享地址空间（其实就是线程的概念了），因为这时候子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子霸占着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec或者exit后，相当于儿子买了自己的房子了，这时候就相当于分家了</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux信号</title>
    <url>/2016/06/14/Linux%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>信号类似于硬件中断是一种“软中断”，包括信号源，信号中断处理函数和信号的安装。Linux中信号的种类比较多，本篇简要介绍和总结下Linux下的信号种类和信号的处理流程及相关的函数接口</p>
<span id="more"></span>

<h2 id="Linux信号简介"><a href="#Linux信号简介" class="headerlink" title="Linux信号简介"></a>Linux信号简介</h2><hr>
<h3 id="信号定义"><a href="#信号定义" class="headerlink" title="信号定义"></a>信号定义</h3><hr>
<p>下面是摘自Wiki百科的一段信号定义：</p>
<pre><code>Signals are a limited form of inter-process communication used in Unix, Unix-like, and other POSIX-compliant operating systems. A signal is an asynchronous notification sent to a process or to a specific thread within the same process in order to notify it of an event that occurred. Signals originated in 1970s Bell Labs Unix and have been more recently specified in the POSIX standard.
When a signal is sent, the operating system interrupts the target process&#39; normal flow of execution to deliver the signal. Execution can be interrupted during any non-atomic instruction. If the process has previously registered a signal handler, that routine is executed. Otherwise, the default signal handler is executed.
Embedded programs may find signals useful for interprocess communications, as the computational and memory footprint for signals is small
</code></pre>
<blockquote>
<p>这段关于信号的定义描述了信号以下几个特点：</p>
</blockquote>
<ol>
<li>信号作用是类Unix系统之间用来进行进程间通信的，是一种异步通信方式的形式来通知一件事件的发生</li>
<li>信号类似于硬件中断，某个进程接受到信号就会中断当前的执行流转而处理信号（当然软中断非原子操作）</li>
<li>如果信号未安装用户自定义的信号处理函数，就会安装默认方式处理信号，否则按照用户自定义的方式来处理信号</li>
</ol>
<h3 id="信号分类"><a href="#信号分类" class="headerlink" title="信号分类"></a>信号分类</h3><hr>
<h4 id="信号划分"><a href="#信号划分" class="headerlink" title="信号划分"></a>信号划分</h4><p>1.可靠性方面<br>信号的可靠与不可靠只与信号值有关，分为可靠和不可靠信号：</p>
<ul>
<li>可靠信号<br>信号值小于<code>SIGRTMIN</code>的信号都是不可靠信号，信号不支持排队，信号可能丢失</li>
<li>不可靠信号<br>信号值位于<code>SIGRTMIN</code>和<code>SIGRTMAX</code>之间的信号都是可靠信号，信号支持排队，信号不会丢失</li>
</ul>
<p>2.实时性方面</p>
<ul>
<li>实时信号<br>前32个信号表示非实时信号，不支持排队，信号可能丢失与可靠性类似</li>
<li>非实时信号<br>后32个信号表示实时信号，支持排队，信号不会丢失与可靠性类似</li>
</ul>
<h4 id="Linux信号列表"><a href="#Linux信号列表" class="headerlink" title="Linux信号列表"></a>Linux信号列表</h4><p>在Ubuntu14.04LTS系统输入<code>kill -L</code>可以看到系统支持的信号列表：</p>
<pre><code>root@ubuntu /# kill -L
 1 HUP      2 INT      3 QUIT     4 ILL      5 TRAP     6 ABRT     7 BUS
 8 FPE      9 KILL    10 USR1    11 SEGV    12 USR2    13 PIPE    14 ALRM
15 TERM    16 STKFLT  17 CHLD    18 CONT    19 STOP    20 TSTP    21 TTIN
22 TTOU    23 URG     24 XCPU    25 XFSZ    26 VTALRM  27 PROF    28 WINCH
29 POLL    30 PWR     31 SYS 
</code></pre>
<blockquote>
<p>只列出了编号为1~31号的传统UNIX支持的信号，是不可靠的（非实时的，而未列出的编号为32 ~ 63的信号是后来扩充的，都是可靠信号(实时信号)</p>
</blockquote>
<p>信号的宏定义都是以<code>SIG</code>作为前缀的，且定义在<code>&lt;signal.h&gt;</code>头文件中，Linux定义的信号(1~31)如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">Signal</th>
<th align="center">Default Handler</th>
<th align="center">Signal Source or Cause</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIGHUP</td>
<td align="center">Terminate</td>
<td align="center">终端挂起或者控制进程终止</td>
</tr>
<tr>
<td align="center">SIGINT</td>
<td align="center">Terminate</td>
<td align="center">键盘中断,如CTRL+Z</td>
</tr>
<tr>
<td align="center">SIGQUIT</td>
<td align="center">Terminate(core dump)</td>
<td align="center">键盘的退出键被按下</td>
</tr>
<tr>
<td align="center">SIGILL</td>
<td align="center">Terminate(core dump)</td>
<td align="center">非法指令</td>
</tr>
<tr>
<td align="center">SIGTRAP</td>
<td align="center">Terminate(core dump)</td>
<td align="center">由断点指令或其他trap指令产生</td>
</tr>
<tr>
<td align="center">SIGABRT</td>
<td align="center">Terminate(core dump)</td>
<td align="center">由abort(3)发出的退出指令</td>
</tr>
<tr>
<td align="center">SIGFPE</td>
<td align="center">Terminate(core dump)</td>
<td align="center">浮点异常</td>
</tr>
<tr>
<td align="center">SIGKILL</td>
<td align="center">Terminate</td>
<td align="center">Kill信号(不能被捕获，不能被忽略)</td>
</tr>
<tr>
<td align="center">SIGSEGV</td>
<td align="center">Terminate(core dump)</td>
<td align="center">无效的内存引用</td>
</tr>
<tr>
<td align="center">SIGPIPE</td>
<td align="center">Terminate</td>
<td align="center">管道破裂: 写一个没有读端口的管道</td>
</tr>
<tr>
<td align="center">SIGALRM</td>
<td align="center">Terminate</td>
<td align="center">由alarm(2)发出的信号</td>
</tr>
<tr>
<td align="center">SIGTERM</td>
<td align="center">Terminate</td>
<td align="center">终止信号</td>
</tr>
<tr>
<td align="center">SIGUSR1</td>
<td align="center">Terminate</td>
<td align="center">用户自定义信号1</td>
</tr>
<tr>
<td align="center">SIGUSR2</td>
<td align="center">Terminate</td>
<td align="center">用户自定义信号2</td>
</tr>
<tr>
<td align="center">SIGCHLD</td>
<td align="center">Ignore</td>
<td align="center">子进程结束信号</td>
</tr>
<tr>
<td align="center">SIGCONT</td>
<td align="center">Continue</td>
<td align="center">进程继续（曾被停止的进程）</td>
</tr>
<tr>
<td align="center">SIGSTOP</td>
<td align="center">Stop</td>
<td align="center">终止进程(不能被捕获，不能被忽略)</td>
</tr>
<tr>
<td align="center">SIGTSTP</td>
<td align="center">Stop</td>
<td align="center">控制终端（tty）上按下停止键</td>
</tr>
<tr>
<td align="center">SIGTTIN</td>
<td align="center">Stop</td>
<td align="center">后台进程企图从控制终端读</td>
</tr>
<tr>
<td align="center">SIGTTOU</td>
<td align="center">Stop</td>
<td align="center">后台进程企图从控制终端写</td>
</tr>
<tr>
<td align="center">SIGURG</td>
<td align="center">Ignore</td>
<td align="center">socket上有紧急数据时向当前正在运行的进程发出此信号，报告有紧急数据到达</td>
</tr>
<tr>
<td align="center">SIGXCPU</td>
<td align="center">Terminate</td>
<td align="center">进程执行时间超过了分配给该进程的CPU时间，系统产生该信号并发送给该进程</td>
</tr>
<tr>
<td align="center">SIGXFSZ</td>
<td align="center">Terminate</td>
<td align="center">超过文件最大长度的限制</td>
</tr>
<tr>
<td align="center">SIGVTALRM</td>
<td align="center">Terminate</td>
<td align="center">虚拟时钟超时时产生该信号。类似于SIGALRM，但是它只计算该进程占有用的CPU时间</td>
</tr>
<tr>
<td align="center">SIGPROF</td>
<td align="center">Terminate</td>
<td align="center">类似于SIGVTALRM，它不仅包括该进程占用的CPU时间还抱括执行系统调用的时间</td>
</tr>
<tr>
<td align="center">SIGPOLL</td>
<td align="center">Ignore</td>
<td align="center">向进程指示发出一个异步IO事件</td>
</tr>
<tr>
<td align="center">SIGPWR</td>
<td align="center">Terminate</td>
<td align="center">关机</td>
</tr>
<tr>
<td align="center">SIGRTMIN~SIGRTMAX</td>
<td align="center">Terminate</td>
<td align="center">Linux的实时信号，可以由用户自由使用（Linux线程机制使用了前3个实时信号）</td>
</tr>
</tbody></table>
<blockquote>
<p>SIGPOLL是SystemV使用的异步IO，BSD系统用SIGIO<br>两个信号可以停止进程:SIGTERM和SIGKILL<br>SIGTERM：进程能捕捉这个信号，根据您的需要来关闭程序。在关闭程序之前，您可以结束打开的记录文件和完成正在做的任务。在某些情况下还进程可以忽略这个SIGTERM信号<br>SIGKILL：进程是不能忽略的。这是一个 “我不管您在做什么，立刻停止”的信号</p>
</blockquote>
<h2 id="信号处理流程"><a href="#信号处理流程" class="headerlink" title="信号处理流程"></a>信号处理流程</h2><hr>
<p>信号处理流程包括三个基本过程：信号产生；信号在进程中注册；信号执行和注销</p>
<h3 id="信号产生"><a href="#信号产生" class="headerlink" title="信号产生"></a>信号产生</h3><hr>
<h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><hr>
<p>信号来源主要包括两个方面：<br>1.硬件来源<br>按下了键盘或者其它硬件故障<br>2.软件来源<br>通过调用系统函数<code>kill</code>，<code>raise</code>，<code>alarm</code>，<code>setitimer</code>，<code>sigqueue</code>，<code>abort</code>来发送信号，软件来源还包括一些非法运算等操作</p>
<h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;sys/types.h&gt; &amp; &lt;signal.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>int kill(pid_t pid, int signo)</code></p>
</li>
</ol>
<blockquote>
<p>作用：<br>kill可以用来向任何进程或进程组发送任何信号<br>参数：<br>pid : 目标进程id，以下取值：</p>
<ul>
<li>pid &gt; 0 : 进程id为pid的进程</li>
<li>pid &#x3D;&#x3D; 0 : 同一进程组的所有进程</li>
<li>pid &lt; 0 &amp;&amp; pid !&#x3D; -1 : 进程组id为-pid的所有进程</li>
<li>pid &#x3D;&#x3D; -1 : 除发送进程本身外，所有进程id大于1的进程<br>signo: 信号值，0为空信号，不发生任何信号</li>
</ul>
</blockquote>
<h4 id="raise"><a href="#raise" class="headerlink" title="raise"></a>raise</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;signal.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>int raise(int signo)</code></p>
</li>
</ol>
<blockquote>
<p>作用：<br>raise可以用来向进程本身发送信号<br>参数：<br>signo: 信号值，0为空信号，不发生任何信号</p>
</blockquote>
<h4 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;unistd.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>unsigned int alarm(unsigned int seconds)</code></p>
</li>
</ol>
<blockquote>
<p>作用：<br>alarm可以用来安排内核为调用进程在指定的seconds秒后发出一个SIGALRM的信号。<br>参数：<br>seconds : 在指定的seconds秒后发出一个SIGALRM的信号：</p>
<ul>
<li>seconds &#x3D; 0 : 不再发送 SIGALRM信号,后一次设定将取消前一次的设定</li>
</ul>
</blockquote>
<blockquote>
<p>该调用返回值为上次定时调用到发送之间剩余的时间，或者因为没有前一次定时调用而返回0<br>使用时，alarm只设定为发送一次信号，如果要多次发送，就要多次使用alarm调用</p>
</blockquote>
<h4 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer"></a>setitimer</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;sys/time.h&gt;</code></p>
</li>
<li><p>函数原型<br>得到定时器状态：<br><code>int getitimer(int which, struct itimerval *value)</code><br>设定定时器：<br><code>int setitimer(int which, const struct itimerval *value, struct itimerval *ovalue)</code></p>
</li>
</ol>
<blockquote>
<p>作用：<br>setitimer可以用来安排内核为调用进程在指定的value值定时时长循环发出一个SIGALRM或SIGVTALRM或SIGPROF的信号。<br>参数：<br>which : 三种类型定时器，它们各自有其独有的计时域，当其中任何一个到达，就发送一个相应的信号给进程，并使得计时器重新开始：</p>
<ul>
<li>which &#x3D;&#x3D; TIMER_REAL : 按实际时间计时，计时到达将给进程发送SIGALRM信号</li>
<li>which &#x3D;&#x3D; ITIMER_VIRTUAL : 仅当进程执行时才进行计时，计时到达将发送SIGVTALRM信号</li>
<li>which &#x3D;&#x3D; PROF : 当进程执行时和系统为该进程执行动作时都计时。与ITIMER_VIRTUAL是一对，该定时器经常用来统计进程在用户态和内核态花费的时间。计时到达将发送SIGPROF信号给进程<br>value : 指明定时器的时长</li>
</ul>
</blockquote>
<h4 id="sigqueue"><a href="#sigqueue" class="headerlink" title="sigqueue"></a>sigqueue</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;sys/types.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>int sigqueue(pid_t pid, int sig, const union sigval val)</code></p>
</li>
</ol>
<blockquote>
<p>作用：<br>sigqueue可以用来向指定pid进程发送带参数val的sig信号，支持信号带有参数，与函数sigaction配合使用。<br>参数：<br>pid : 接收目标进程pid<br>sig : 发送的信号<br>val : 信号传递的参数，即通常所说的4字节值</p>
</blockquote>
<blockquote>
<p>sigqueue比kill传递了更多的附加信息，但sigqueue只能向一个进程发送信号，而不能发送信号给一个进程组</p>
</blockquote>
<p>sigval定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">sigval</span> &#123;</span><br><span class="line">               <span class="type">int</span>  sival_int;</span><br><span class="line">               <span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;<span class="type">sigval_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;stdlib.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>void abort(void)</code></p>
</li>
</ol>
<blockquote>
<p>作用：<br>sigqueue可以用来向进程发送SIGABORT信号，默认情况下进程会异常退出，也可自定义的信号处理函数，即使SIGABORT被进程设置为阻塞信号，调用abort()后，SIGABORT仍然能被进程接收。<br>参数：<br>无</p>
</blockquote>
<h3 id="信号在进程中注册"><a href="#信号在进程中注册" class="headerlink" title="信号在进程中注册"></a>信号在进程中注册</h3><hr>
<p>进程表的表项中有一个<strong>软中断信号域</strong>，该域中每一位对应一个信号，内核给一个进程发送软中断信号的方法，是在<strong>进程所在的进程表项的软中断信号域设置对应于该信号的位</strong></p>
<p>信号在进程中注册指的就是<strong>信号值加入到进程的未决信号集</strong>sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该信号被进程阻塞</p>
<p>未决信号集sigpending:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">sigpending</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="type">sigqueue</span> *head, *tail; <span class="comment">//未决信号信息链</span></span><br><span class="line">        sigset_t signal; <span class="comment">//未决信号集</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个特定信号所携带的信息sigqueue：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="type">sigqueue</span>&#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="type">sigqueue</span> *next;</span><br><span class="line">        siginfo_t info; <span class="comment">//信号所携带信息内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的这一段时间<br>信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生</p>
</blockquote>
<p>实时信号和非实时信号的注册差异处理：</p>
<ul>
<li>当一个实时信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失，同一个实时信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构</li>
<li>当一个非实时信号发送给一个进程时，如果该信号已经在进程中注册（通过sigset_t signal指示），则该信号将被丢弃，造成信号丢失，同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构</li>
</ul>
<h3 id="信号执行和注销"><a href="#信号执行和注销" class="headerlink" title="信号执行和注销"></a>信号执行和注销</h3><hr>
<p>内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当其由于被信号唤醒或者正常调度重新获得CPU时，在其从内核空间返回到用户空间时会检测是否有信号等待处理。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉</p>
<p>实时信号和非实时信号的注销差异处理：</p>
<ul>
<li>对于非实时信号来说，由于在未决信号信息链中最多只占用一个sigqueue结构，因此该结构被释放后，应该把信号在进程未决信号集中删除（信号注销完毕）</li>
<li>对于实时信号来说，可能在未决信号信息链中占用多个sigqueue结构，要待该信号的所有sigqueue处理完毕后再在进程的未决信号集中删除该信号（信号注销完毕）</li>
</ul>
<p><strong>内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时</strong>。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。<strong>进程只有处理完信号才会返回用户态</strong>，进程在用户态下不会有未处理完的信号</p>
<blockquote>
<p>处理信号的三种方式：</p>
</blockquote>
<ul>
<li>Ignore 忽略信号</li>
<li>Default Handler执行默认处理方式</li>
<li>User Define Handler执行用户自定义安装的回调处理方式</li>
</ul>
<p>安装信号主要用来确定信号值及进程针对该信号值的动作之间的映射关系，即进程将要处理哪个信号。对于用户自定义信号的安装，主要有signal和sigaction两个系统调用，前者不支持信号传递信息，后者支持信号传递信息且与sigqueue系统调用配合使用</p>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;signal.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>void (*signal(int signum, void (*handler))(int)))(int)</code></p>
</li>
</ol>
<blockquote>
<p>作用：signal安装不带信息参数的信号。<br>参数：<br>signum : 信号值，可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号<br>handler : 信号处理回调,该回调</p>
<ul>
<li>SIG_IGN 忽略该信号</li>
<li>SIG_DFL 默认方式处理</li>
<li>handler 自定义方式处理</li>
</ul>
</blockquote>
<h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h4><hr>
<ol>
<li><p>头文件<br><code>&lt;signal.h&gt;</code></p>
</li>
<li><p>函数原型<br><code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact))</code></p>
</li>
</ol>
<blockquote>
<p>作用：sigaction安装带信息参数的信号。<br>参数：<br>signum : 信号值，可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号<br>act : 指定对信号的处理，可以为空，进程会以缺省方式对信号处理</p>
<ul>
<li>SIG_IGN 忽略该信号</li>
<li>SIG_DFL 默认方式处理</li>
<li>handler 自定义方式处理<br>oldact: 该参数指向的对象用来保存返回的原来对相应信号的处理</li>
</ul>
</blockquote>
<p>sigaction定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">union</span>&#123;</span><br><span class="line">       <span class="type">__sighandler_t</span> _sa_handler;          <span class="comment">// 用户自定义函数</span></span><br><span class="line">      <span class="built_in">void</span> (*_sa_sigaction)(<span class="type">int</span>,<span class="keyword">struct</span> siginfo *, <span class="type">void</span> *)； <span class="comment">// 用户自定义函数</span></span><br><span class="line">      &#125;_u</span><br><span class="line"></span><br><span class="line">  <span class="type">sigset_t</span> sa_mask；</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sa_flags；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sigqueue发送信号时，sigqueue的第三个参数sigval联合数据结构中的数据就将拷贝到信号处理函数_sa_sigaction的第二个参数siginfo中</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>signal</tag>
      </tags>
  </entry>
  <entry>
    <title>GFM格式Markdown简介</title>
    <url>/2016/12/15/Markdown-GFM%E6%A0%BC%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="Markdown各种扩展"><a href="#Markdown各种扩展" class="headerlink" title="Markdown各种扩展"></a>Markdown各种扩展</h2><p>Markdown除了标准的语法格式外，还有各种格式的扩展</p>
<span id="more"></span>
<ul>
<li><a href="https://michelf.ca/projects/php-markdown/extra/">PHP Markdown Extra</a><ul>
<li>支持在html块元素中插入markdown语法</li>
<li>支持为一些元素添加id或class</li>
<li>支持将代码块用`或者<code>~</code>包起来，这样可以避免一些二义，还可以为代码块添加id或class</li>
<li>支持手写的表格</li>
<li>支持脚注引用</li>
</ul>
</li>
<li><a href="https://github.com/bhollis/maruku/blob/master/docs/markdown_syntax.md">Maruku</a><br>是基于<strong>Ruby</strong>开发的解释器，具有以下特点：<ul>
<li>支持原生Markdown</li>
<li>支持所有PHP Markdown Extra的特性</li>
<li>支持新的元数据语法，实际上就是给元素添加属性的能力</li>
<li>支持公式格式输出<br>不过，该项目已经停止维护了</li>
</ul>
</li>
<li><a href="http://kramdown.gettalong.org/">kramdown</a><br>同样是<strong>Ruby</strong>开发的解释器，kramdown吸取了Maruku几乎所有的特点，功能更为强大。其中有特点的功能有:<ul>
<li>引入EOB标记^作为块元素的分隔符</li>
<li>手写table的语法更加强大一些，支持table中的header和footer</li>
<li>还支持注释，以及在转化时配置一些转化选项</li>
<li>同样支持ALD(Attribute List Definitions属性列表定义)<br><a href="https://help.github.com/articles/migrating-your-pages-site-from-maruku/">GitHub Page 推荐使用kramdown解释器</a></li>
</ul>
</li>
<li><a href="http://www.pell.portland.or.us/~orc/Code/discount/">RDiscount</a><br>同样是<strong>Ruby</strong>开发的解释器，不过它是基于<a href="http://www.pell.portland.or.us/~orc/Code/discount/">Discount</a>的语法移植的,以语法规则需要参考Discount。其语法支持几种上面没有提到过的特性:<ul>
<li>文本居中，即输出<code>&lt;center&gt;</code></li>
<li>图片大小定义<code>![dust mite](http://dust.mite =150x150)</code></li>
<li>输出alpha列表：<code>&lt;ol type=&#39;a&#39;&gt;&lt;/ol&gt;</code></li>
</ul>
</li>
<li><a href="https://github.com/vmg/redcarpet">Redcarpet</a><br>Redcarpet是一个转化库，可以在标准Markdown的基础上，配置一些额外的功能:<ul>
<li>单词中间的_不处理</li>
<li>转化PHP-Markdown风格的手写表格</li>
<li>转化PHP-Markdown风格的带包含的代码块，也可禁用标准markdown的代码块语法自动link生成</li>
<li>删除线支持：<code>~~good~~</code></li>
<li>高亮标签<code>&lt;mark&gt;&lt;/mark&gt;</code>通过<code>==highlighted==</code>输出</li>
<li>引用标签<code>&lt;q&gt;&lt;/q&gt;</code>通过<code>&quot;quote&quot;</code>输出</li>
<li>转化PHP-Markdown风格脚注</li>
<li>一些二义性的约束支持</li>
</ul>
</li>
<li><a href="https://help.github.com/articles/writing-on-github/">GitHub</a><br><strong>Github Page对于上述的基于<em>Ruby</em>的markdown都是支持的</strong>，从<a href="https://pages.github.com/versions/">这里</a>可以看到。另外，Github对于Issue、comments等，还定义了GFM(<a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a>)，其中的语法一般基本来源于上面的提到的东西。除此之外，github还支持一些额外的特性：<ul>
<li>支持把列表变成带勾选框的任务列表</li>
<li>站内对分支、问题、用户等对象的直接引用</li>
<li><a href="http://www.emoji-cheat-sheet.com/">表情</a></li>
</ul>
</li>
</ul>
<h2 id="GFM-Markdown"><a href="#GFM-Markdown" class="headerlink" title="GFM Markdown"></a>GFM Markdown</h2><hr>
<p>GitHub 使用的是“GitHub Flavored Markdown”，简称GFM，有site-in issues,comments,pull requests等功能，它与标准的Markdown有一些区别，并增加了些新的扩展功能，区别如下：</p>
<h3 id="单词内多下划线"><a href="#单词内多下划线" class="headerlink" title="单词内多下划线"></a>单词内多下划线</h3><p>标准的Markdown转换<code>_</code>成斜体，GFM忽略了单词内部的<code>_</code>，如：</p>
<pre><code>hi_great_world
do_this_and_do_other
</code></pre>
<p>效果：<br>hi_great_world<br>do_this_and_do_other</p>
<blockquote>
<p>这个特性允许代码里和名字里含有多个<code>_</code>的单词能够正确的解释，如果强调一个单词可以使用<code>*</code></p>
</blockquote>
<h3 id="URL自动链接"><a href="#URL自动链接" class="headerlink" title="URL自动链接"></a>URL自动链接</h3><p>标准Markdown使用<code>&lt;</code>URL<code>&gt;</code>来支持自动链接；GFM会自动链接标准的URLs，如果你想链接到一个URL(而不是设置链接文本)，你可以简单的输入一个URL地址，GFM会自动转换成一个URL链接，如:</p>
<pre><code>http://www.franktly.com
</code></pre>
<p>效果：<br><a href="http://www.franktly.com/">http://www.franktly.com</a></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>GFM增加了标准Markdown中没有的删除线的语法，使用两个<code>~</code>表示，如：</p>
<pre><code>~~wrong text.~~
</code></pre>
<p>效果：<br><del>wrong text.</del></p>
<h3 id="栅栏式的代码块"><a href="#栅栏式的代码块" class="headerlink" title="栅栏式的代码块"></a>栅栏式的代码块</h3><p>标准的Markdown把每行的开始带有4个空格或一个Tab的文本转换为代码块；GFM除了此，还支持<br>栅栏式代码块，仅仅需要把你的代码你用三个`包裹起来即可，不需要通过4个空格来区分了，如：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">void hello()</span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;hello&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>效果(栅栏式代码块自动加了默认的高亮)：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管栅栏式代码块并不需要在前面增加一个空行（不像缩进式代码块），GFM建议最好加上一个空行，这样方便原始的Markdown更容易阅读<br>在列表里面，你必须使用8个空格来表示一个非栅栏式的代码块</p>
</blockquote>
<h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>代码块通过加语法高亮更容易阅读，在栅栏式代码块基础之上，增加一个可选的语言标字符(如 ruby,C,C++,pyhon等等)，GFM通过此种方式来进行代码语法高亮，如以下Ruby代码：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">```ruby</span><br><span class="line">require &#x27;redcarpet&#x27;</span><br><span class="line">markdown = Redcarpet.<span class="keyword">new</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">puts markdown.to_html</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;redcarpet&#x27;</span></span><br><span class="line">markdown = <span class="title class_">Redcarpet</span>.new(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">puts markdown.to_html</span><br></pre></td></tr></table></figure>
<p>而没加高亮是这样的(标准Markdown换行加空四格)：</p>
<pre><code>require &#39;redcarpet&#39;
markdown = Redcarpet.new(&quot;Hello World!&quot;)
puts markdown.to_html
</code></pre>
<blockquote>
<p>GFM使用<a href="https://github.com/github/linguist">Linguist</a>来检测语言进行语法高亮，可以参阅<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">YAML file</a>来确定哪些关键字的语言被支持</p>
</blockquote>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>1)GFM在标准的Markdown语法基础上增加了表格，可以通过组合一系列单词通过连字符<code>-</code>（仅在第一行上使用）分隔第一行，通过<code>|</code>来分隔表格的每一列即可，如：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">First Header | <span class="built_in">Second</span> Header</span><br><span class="line">-------------| -------------</span><br><span class="line">Content <span class="built_in">Cell</span> | Content <span class="built_in">Cell</span> </span><br><span class="line">Content <span class="built_in">Cell</span> | Content <span class="built_in">Cell</span>  </span><br></pre></td></tr></table></figure>

<p>效果：</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<p>2)为了好看，可以在最后一列增加<code>|</code>:</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">First Header |<span class="string"> Second Header </span>|</span><br><span class="line">-------------|<span class="string"> ------------- </span>|</span><br><span class="line">Content Cell |<span class="string"> Content Cell  </span>|</span><br><span class="line">Content Cell |<span class="string"> Content Cell  </span>|<span class="string"> </span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<p>3)表头开始的破折号并不需要一定要匹配Header文本的长度(匹配的目的也是为了格式美观):</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Name |<span class="string"> Description           </span>|</span><br><span class="line">-------------|<span class="string"> ------------- </span>|</span><br><span class="line">Open   |<span class="string"> Open Door </span>|</span><br><span class="line">Close  |<span class="string"> Close Door </span>|<span class="string"> </span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Open</td>
<td>Open Door</td>
</tr>
<tr>
<td>Close</td>
<td>Close Door</td>
</tr>
</tbody></table>
<p>4)通过在第一个行的<code>-</code>序列中增加<code>:</code>可以格式化文本的对齐方式，如<code>:</code>位于<code>-</code>序列左边表示文本左对齐，两边都有表示文本中间对齐，位于右边则表示右对齐，如：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">| <span class="title class_">Left</span> <span class="title class_">Aligned</span> | <span class="title class_">Center</span> <span class="title class_">Aligned</span> | <span class="title class_">Right</span> <span class="title class_">Aligned</span> |</span><br><span class="line">|<span class="symbol">:------------</span> |<span class="symbol">:--------------</span><span class="symbol">:|</span> -------------<span class="symbol">:|</span></span><br><span class="line">| c11          | c12            | c13           |</span><br><span class="line">| c21          | c22            | c23           | </span><br></pre></td></tr></table></figure>

<p>效果：</p>
<table>
<thead>
<tr>
<th align="left">Left Aligned</th>
<th align="center">Center Aligned</th>
<th align="right">Right Aligned</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c11</td>
<td align="center">c12</td>
<td align="right">c13</td>
</tr>
<tr>
<td align="left">c21</td>
<td align="center">c22</td>
<td align="right">c23</td>
</tr>
</tbody></table>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>可以在GitHub的READMEs，issues和requests中使用HTML的子集，支持的标签和属性可以参考<a href="https://github.com/github/markup">github&#x2F;markup repository</a></p>
<h3 id="GFM换行"><a href="#GFM换行" class="headerlink" title="GFM换行"></a>GFM换行</h3><p>标准Markdown要在一行的最后加两个空格符才表示换行，否则是不换行的；但是GFM则没有此要求</p>
<pre><code>第一行(最后无两个空格)
第二行
</code></pre>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>GFM支持将列表变为<a href="https://github.com/blog/1375%0A-task-lists-in-gfm-issues-pulls-comments">任务列表</a>，通过在列表的前面增加 <code>[ ]</code>或<code>[x]</code>(分别代码未完成和完成)，如：</p>
<pre><code>+ [ ] a task list item
+ [ ] list syntax required
+ [ ] normal **formatting**,@emontions, #1232 refs
+ [ ] incomplete
+ [x] completed
</code></pre>
<p>看到的结果是checkboxes 列表，可以修改Markdown文本，可以Check或者Uncheck Boxes,文本会自动更新, 任务列表可以嵌套任务的深度,GFM建议最多嵌套1到2层，如：</p>
<pre><code>+ [ ] a bigger project
  + [ ] first subtask #1
  + [ ] second subtask #2
+ [x] a small project
  + [x] first substask #3
</code></pre>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>特定的引用会自动被链接，如：</p>
<pre><code>- SHA: a5c3785ed8d6a35868bc169f07e40e889087fd2e
- User@SHA: jlord@a5c3785ed8d6a35868bc169f07e40e889087fd2e
- User/Repository@SHA: jlord/sheetsee.js@a5c3785ed8d6a35868bc169f07e40e889087fd2e
- #Num: #26
- GH-Num: GH-26
- User#Num: jlord#26
- User/Repository#Num: jlord/sheetsee.js#26
</code></pre>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>快速引用(<code>r</code>)</li>
<li>@mentions自动生成名字和组(<code>@</code>)</li>
<li>Emoji自动生成表情(<code>:</code>)</li>
<li>Issue自动生成(<code>#</code>)</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.pchou.info/open-source/2014/07/07/something-about-markdown.html">Markdown的各种扩展</a></p>
<p><a href="https://help.github.com/articles/github-flavored-markdown/">GitHub Flavored Markdown</a></p>
<p><a href="https://help.github.com/articles/markdown-basics/">Markdown Basics</a></p>
<p><a href="https://help.github.com/articles/writing-on-github/">Writing on GitHub</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Markdown</tag>
        <tag>标记语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用介绍</title>
    <url>/2016/10/21/Markdown%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Markdown 是一个从文本到HTML的转换工具，通过简单的易读易写的文本格式生成结构化的HTML文档，是一种用来写作的轻量级<strong>标记语言</strong>，它使得我们能够专心于码字，而用<strong>标记</strong>语法来代替常见的排版格式，Markdown可以支持导出HTML格式的网页形式，也可以很方便的导出PDF格式</p>
<span id="more"></span>

<h2 id="Markdown-介绍"><a href="#Markdown-介绍" class="headerlink" title="Markdown 介绍"></a>Markdown 介绍</h2><hr>
<p>Markdown的目标是<em>易读易写</em>，具有以下优点：</p>
<ul>
<li>兼容HTML，Markdown作为轻量级的标记语言，其初衷不是想取代HTML，而是让文档更容易读、写和随意更改，HTML是一种发布的格式，而Markdown是一种书写的格式。Markdown 的格式语法只涵盖纯文本可以涵盖的范围，不在Markdown涵盖范围之内的标签，都可以直接在文档里面用 HTML撰写，不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了</li>
<li>专注你的文字内容而不是排版样式，安心写作</li>
<li>轻松的导出 HTML、PDF 和本身的 .md 文件</li>
<li>纯文本内容，兼容所有的文本编辑器与字处理软件</li>
<li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱</li>
<li>可读、直观、学习成本低</li>
</ul>
<h2 id="Markdown-语法（Standard）"><a href="#Markdown-语法（Standard）" class="headerlink" title="Markdown 语法（Standard）"></a>Markdown 语法（<a href="http://daringfireball.net/projects/markdown/syntax">Standard</a>）</h2><hr>
<h3 id="Markdown术语"><a href="#Markdown术语" class="headerlink" title="Markdown术语"></a>Markdown术语</h3><h4 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h4><p>一个 Markdown <strong>段落</strong>是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<blockquote>
<p>[由一个或多个连续的文本行组]成这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），如果你确实想要依赖 Markdown 来插入 <code>&lt;br/&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车<br>需要多费点事（多加空格然后回车）来产生<code>&lt;br/&gt;</code>，但是简单地[每个换行都转换为 <code>&lt;br/&gt;</code>]的方法在 Markdown 中并不适合， Markdown 中 email 式的 区块引用 和多段落的 列表 在使用换行来排版的时候，不但更好用，还更方便阅读</p>
</blockquote>
<h3 id="Markdown区块元素"><a href="#Markdown区块元素" class="headerlink" title="Markdown区块元素"></a>Markdown区块元素</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>Markdown支持两种标题的语法，类 Setext 和类 atx 形式:<br>类 Setext 形式是用底线的形式，利用 <code>=</code>（最高阶标题）和<code>-</code> （第二阶标题），例如:</p>
<pre><code>This is H1
=============
This is H2
-------------
</code></pre>
<p>效果：</p>
<h1 id="This-is-H1"><a href="#This-is-H1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This-is-H2"><a href="#This-is-H2" class="headerlink" title="This is H2"></a>This is H2</h2><p>类 Atx 形式则是在行首插入 1 到 6 个<code>#</code>，对应到标题 1 到 6 阶，例如:</p>
<pre><code># This is H1
## This is H2
### This is H3
#### This is H4
##### This is H5
###### This is H6
</code></pre>
<p>效果：</p>
<h1 id="This-is-H1-1"><a href="#This-is-H1-1" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This-is-H2-1"><a href="#This-is-H2-1" class="headerlink" title="This is H2"></a>This is H2</h2><h3 id="This-is-H3"><a href="#This-is-H3" class="headerlink" title="This is H3"></a>This is H3</h3><h4 id="This-is-H4"><a href="#This-is-H4" class="headerlink" title="This is H4"></a>This is H4</h4><h5 id="This-is-H5"><a href="#This-is-H5" class="headerlink" title="This is H5"></a>This is H5</h5><h6 id="This-is-H6"><a href="#This-is-H6" class="headerlink" title="This is H6"></a>This is H6</h6><p>可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上<code>#</code>，而行尾的<code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）</p>
<pre><code># This is H1 #
## This is H2 ##
### This is H3 ###
#### This is H4 ####
##### This is H5 #####
###### This is H6 ######
</code></pre>
<p>效果:</p>
<h1 id="This-is-H1-2"><a href="#This-is-H1-2" class="headerlink" title="This is H1"></a>This is H1</h1><h2 id="This-is-H2-2"><a href="#This-is-H2-2" class="headerlink" title="This is H2"></a>This is H2</h2><h3 id="This-is-H3-1"><a href="#This-is-H3-1" class="headerlink" title="This is H3"></a>This is H3</h3><h4 id="This-is-H4-1"><a href="#This-is-H4-1" class="headerlink" title="This is H4"></a>This is H4</h4><h5 id="This-is-H5-1"><a href="#This-is-H5-1" class="headerlink" title="This is H5"></a>This is H5</h5><h6 id="This-is-H6-1"><a href="#This-is-H6-1" class="headerlink" title="This is H6"></a>This is H6</h6><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>Markdown 标记区块引用是使用类似 email 中用<code>&gt;</code>的引用方式，如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown文件中建立一个区块引用</p>
<ol>
<li>Markdown区块看起来像是你自己先断好行，然后在每行的最前面加上<code>&gt;</code>：<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="title class_">This</span> is <span class="title class_">Paragraph</span> <span class="number">1</span> <span class="title class_">Line</span> <span class="number">1</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="title class_">This</span> is <span class="title class_">Paragraph</span> <span class="number">1</span> <span class="title class_">Line</span> <span class="number">2</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="title class_">This</span> is <span class="title class_">Paragraph</span> <span class="number">2</span> <span class="title class_">Line</span> <span class="number">1</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="title class_">This</span> is <span class="title class_">Paragraph</span> <span class="number">2</span> <span class="title class_">Line</span> <span class="number">2</span>,</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：</p>
<blockquote>
<p>This is Paragraph 1 Line 1,<br>This is Paragraph 1 Line 2,</p>
<p>This is Paragraph 2 Line 1,<br>This is Paragraph 2 Line 2,</p>
</blockquote>
<ol start="2">
<li>Markdown也允许你偷懒只在整个段落的第一行最前面加上<code>&gt;</code>：<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&gt; This <span class="keyword">is</span> Paragraph <span class="number">1</span> <span class="type">Line</span> <span class="number">1</span>,</span><br><span class="line">This <span class="keyword">is</span> Paragraph <span class="number">1</span> <span class="type">Line</span> <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">&gt; This <span class="keyword">is</span> Paragraph <span class="number">2</span> <span class="type">Line</span> <span class="number">1</span>,</span><br><span class="line">This <span class="keyword">is</span> Paragraph <span class="number">2</span> <span class="type">Line</span> <span class="number">2</span>,</span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：</p>
<blockquote>
<p>This is Paragraph 1 Line 1,<br> This is Paragraph 1 Line 2,</p>
</blockquote>
<blockquote>
<p>This is Paragraph 2 Line 1,<br>This is Paragraph 2 Line 2,</p>
</blockquote>
<ol start="3">
<li>Markdown区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的<code>&gt;</code>:<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="variable">This</span> <span class="variable">is</span> <span class="variable">Paragrah</span> <span class="number">1</span> <span class="built_in">Line</span> <span class="number">1</span> <span class="built_in">Depth</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="variable">This</span> <span class="variable">is</span> <span class="variable">Paragraph</span> <span class="number">1</span> <span class="built_in">Line</span> <span class="number">2</span> <span class="built_in">Depth</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">This</span> <span class="variable">is</span> <span class="variable">Pargaraph</span> <span class="number">1</span> <span class="built_in">Line</span> <span class="number">3</span> <span class="built_in">Depth</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> </span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">This</span> <span class="variable">is</span> <span class="variable">Paragrah</span> <span class="number">2</span> <span class="built_in">Line</span> <span class="number">1</span> <span class="built_in">Depth</span> <span class="number">1</span></span><br><span class="line"><span class="operator">&gt;&gt;</span><span class="variable">This</span> <span class="variable">is</span> <span class="variable">Paragraph</span> <span class="number">2</span> <span class="built_in">Line</span> <span class="number">2</span> <span class="built_in">Depth</span> <span class="number">2</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="variable">This</span> <span class="variable">is</span> <span class="variable">Pargaraph</span> <span class="number">2</span> <span class="built_in">Line</span> <span class="number">3</span> <span class="built_in">Depth</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：</p>
<blockquote>
<p>This is Paragrah 1 Line 1 Depth 1</p>
<blockquote>
<p>This is Paragraph 1 Line 2 Depth 2<br>This is Pargaraph 1 Line 3 Depth 2</p>
</blockquote>
<p>This is Paragrah 2 Line 1 Depth 1</p>
<blockquote>
<p>This is Paragraph 2 Line 2 Depth 2<br>This is Pargaraph 2 Line 3 Depth 2</p>
</blockquote>
</blockquote>
<ol start="4">
<li>Markdown引用的区块内也可以使用其他的Markdown语法，包括标题、列表、代码区块等：<figure class="highlight node-repl"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript">## <span class="title class_">This</span> is A title</span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="number">1.</span> <span class="title class_">This</span> is <span class="title class_">List</span> <span class="number">1</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="number">2.</span> <span class="title class_">This</span> is <span class="title class_">List</span> <span class="number">2</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span> <span class="language-javascript"><span class="string">`cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;`</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：</p>
<blockquote>
<h2 id="This-is-A-title"><a href="#This-is-A-title" class="headerlink" title="This is A title"></a>This is A title</h2><ol>
<li>This is List 1</li>
<li>This is List 2<br><code>cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;</code></li>
</ol>
</blockquote>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Markdown支持有序和无序列表</p>
<ol>
<li>无序列表使用<code>*</code>、<code>+</code>、<code>-</code>作为列表标记<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>China</span><br><span class="line"><span class="bullet">- </span>Japan</span><br><span class="line"><span class="bullet">- </span>Korea</span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果:</p>
<ul>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ul>
<p>等同于：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>China</span><br><span class="line"><span class="bullet">* </span>Japan</span><br><span class="line"><span class="bullet">* </span>Korea</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ul>
<p>也等同于：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">+</span> China</span><br><span class="line"><span class="bullet">+</span> Japan</span><br><span class="line"><span class="bullet">+</span> Korea</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ul>
<ol start="2">
<li><p>有序列表使用数字接着一个英文句点：</p>
<ol>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ol>
</li>
</ol>
<p>效果：</p>
<ol>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ol>
<p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的HTML结果</p>
<ol>
<li>如果列表项目间用空行分开，在输出HTML时Markdown就会将项目内容用<code>&lt;p&gt;</code>标签包起来，举例来说: <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>China</span><br><span class="line"><span class="bullet">- </span>Japan</span><br><span class="line"><span class="bullet">- </span>Korea</span><br></pre></td></tr></table></figure></li>
</ol>
<p>会被转换为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;ul&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ul>
<ol start="2">
<li>有序列表使用数字接着一个英文句点：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> China</span><br><span class="line"><span class="bullet">2.</span> Japan</span><br><span class="line"><span class="bullet">3.</span> Korea</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ol>
<li>China</li>
<li>Japan</li>
<li>Korea</li>
</ol>
<ol>
<li>如果列表项目间用空行分开，在输出HTML时Markdown就会将项目内容用<code>&lt;p&gt;</code>标签包起来，举例来说: <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>China</span><br><span class="line"><span class="bullet">- </span>Japan</span><br><span class="line"><span class="bullet">- </span>Korea</span><br></pre></td></tr></table></figure></li>
</ol>
<p>会被转换为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>China<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Japan<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Korea<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这个如果有空行：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>China</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Japan</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>Korea</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<ul>
<li><p>China</p>
</li>
<li><p>Japan</p>
</li>
<li><p>Korea</p>
</li>
</ul>
<p>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;China&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Japan&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Korea&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<ol start="2">
<li>列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符：<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  This <span class="keyword">is</span> p1</span><br><span class="line">    This <span class="keyword">is</span> p1 <span class="keyword">and</span> <span class="number">4</span> <span class="literal">space</span> <span class="keyword">or</span> <span class="number">1</span> <span class="literal">tab</span> draw <span class="keyword">back</span></span><br><span class="line"><span class="number">2.</span>  This <span class="keyword">is</span> p2</span><br><span class="line">    This <span class="keyword">is</span> p2 <span class="keyword">and</span> <span class="number">4</span> <span class="literal">space</span> <span class="keyword">or</span> <span class="number">1</span> <span class="literal">tab</span> draw <span class="keyword">back</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：</p>
<ol>
<li>This is p1<br>This is p1 and 4 space or 1 tab draw back</li>
<li>This is p2<br>This is p2 and 4 space or 1 tab draw back</li>
</ol>
<ol start="3">
<li>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.  This is <span class="built_in">p1</span> <span class="meta">code</span></span><br><span class="line">        Hello World <span class="number">1</span></span><br><span class="line"><span class="number">2</span>.  This is <span class="built_in">p2</span></span><br><span class="line">        Hello World <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：</p>
<ol>
<li>This is p1 code<br>Hello World 1</li>
<li>This is p2<br>Hello World 2</li>
</ol>
<ol start="4">
<li>如果在行首出现数字句点空白，要避免这样的状况与有序列表格式冲突，你可以在句点前面加上反斜杠转义：<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="number">1988</span>\. This <span class="keyword">is</span> a great <span class="built_in">year</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>效果：<br>1988. This is a great year</p>
<h4 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h4><p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来</p>
<ol>
<li>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">This <span class="keyword">is</span> a paragragh</span><br><span class="line"><span class="comment">// !此处加空行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<pre><code>This is a paragragh
// !此处加空行
    cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
</code></pre>
<p>Markdown 会转换成：</p>
<pre><code>&lt;p&gt; This is a paragraph&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">Here <span class="keyword">is</span> a Expample of Python:</span><br><span class="line"><span class="comment">// !此处加空行</span></span><br><span class="line">    def showhello:</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">&quot;How are you&quot;</span>)</span><br><span class="line">This <span class="keyword">is</span> a normal paragraph</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<pre><code>Here is a Expample of Python:
// !此处加空行
    def showhello:
        print(&quot;Hello World&quot;)
        print(&quot;How are you&quot;)
This is a normal paragraph
</code></pre>
<blockquote>
<p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
</blockquote>
<ol start="2">
<li><p>在代码区块里面，<code>&amp;</code> 、<code>&lt;</code> 和 <code>&gt;</code>会自动转成 HTML 实体<code>&amp;amp</code>、<code>&amp;lt;</code>、<code>&amp;gt;</code>，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
 <div class="footer">
   &copy; Markdown Corporation
 </div></li>
</ol>
<p>会被转换为：</p>
<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; Markdown Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>
<ol start="3">
<li>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件</li>
</ol>
<h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4><p>你可以在一行中用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>***
- * * *
----
_ _ _ _
</code></pre>
<p>效果：</p>
<hr>
<ul>
<li><hr>
</li>
</ul>
<hr>
<hr>
<h3 id="Markdown区段元素"><a href="#Markdown区段元素" class="headerlink" title="Markdown区段元素"></a>Markdown区段元素</h3><hr>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="文字链接"><a href="#文字链接" class="headerlink" title="文字链接"></a>文字链接</h5><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式<br>不管是哪一种，链接文字都是用 [方括号] 来标记</p>
<ol>
<li><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<p> This is <a href="http://www.taolingyang.com/" title="frank">My Blog</a> inline link.</p>
</li>
</ol>
<p>效果：<br>    This is <a href="http://www.taolingyang.com/" title="frank">My Blog</a> inline link.</p>
<p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [About](/about/) page for details.
</code></pre>
<p>效果：<br>    See my <a href="/about/">About</a> page for details.</p>
<ol start="2">
<li><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<p> This is [My Blog][id] reference link<br> [id]: <a href="http://www.franktly.com/">http://www.franktly.com/</a> “frank”</p>
</li>
</ol>
<p>效果：<br>This is [My Blog][id] reference link<br>[id]: <a href="http://www.taolingyang.com/">http://www.taolingyang.com/</a> “frank”</p>
<blockquote>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<strong>不区分</strong>大小写</p>
</blockquote>
<p><strong>隐式链接标记</strong>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号<br>链接内容定义的形式为：</p>
<pre><code>[My Blog][]
[My Blog]: http://www.franktly.com &quot;frank&quot;
</code></pre>
<p>效果：<br>[My Blog][]<br>[My Blog]: <a href="http://www.taolingyang.com/">http://www.taolingyang.com</a> “frank”</p>
<blockquote>
<p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
</blockquote>
<p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<h5 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h5><p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。</p>
<ol>
<li><p>行内式的图片语法看起来像是：</p>
<p> <img src="http://www.taolingyang.com/2016/10/21/Markdown%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/to/img.jpg" alt="Alt text"><br> <img src="http://www.taolingyang.com/2016/10/21/Markdown%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/to/img.jpg" alt="Alt text" title="Optional title"></p>
</li>
</ol>
<blockquote>
<ul>
<li>一个惊叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
</blockquote>
<ol start="2">
<li><p>参考式的图片语法则长得像这样：</p>
<p> ![Alt text][id]<br> [id]: &#x2F;path&#x2F;to&#x2F;img.jpg “Optional title”</p>
</li>
</ol>
<h4 id="斜体与加强"><a href="#斜体与加强" class="headerlink" title="斜体与加强"></a>斜体与加强</h4><p>Markdown 使用星号（*）和底线（_）作为标记强调字词的符号，被 * 或 _ 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围表示斜体，用两个 * 或 _ 包起来的话，则会被转成 <code>&lt;strong&gt;</code>表示变粗加强，例如:</p>
<pre><code>*Single Strong*
**Double Strong**
_Single Strong_
__Double Strong__
</code></pre>
<p>效果：<br><em>Single Strong</em><br><strong>Double Strong</strong><br><em>Single Strong</em></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li><p>如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：</p>
<p> Program Begin With <code>main()</code> function</p>
</li>
</ol>
<p>效果：<br>Program Begin With <code>main()</code> function</p>
<p>会被转换成这样：</p>
<pre><code>&lt;p&gt;&lt;code&gt;Program Begin With `main()` function&lt;/code&gt;&lt;/p&gt;
</code></pre>
<ol start="2">
<li><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<p> <code>This is a Literal Backtick ` Here</code></p>
</li>
</ol>
<p>效果：<br><code>This is a Literal Backtick ` Here</code></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号进行转义，真实的表示该符号，而不进行标签替换处理</p>
<pre><code>\* This is incluced By (\*) \*
</code></pre>
<p>效果：<br>* This is incluced By (*) *</p>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
-   星号
_   底线
&#123;&#125;  花括号
[]  方括号
()  括弧
#   井字号
*   加号
+   减号
.   英文句点
!   惊叹号
</code></pre>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>Markdown支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://www.taolingyang.com&gt;
</code></pre>
<p>效果：<br><a href="http://www.taolingyang.com/">http://www.taolingyang.com</a><br>被转化为：</p>
<pre><code>&lt;a href=&quot;http://www.taolingyang.com&quot;&gt;http://www.taolingyang.com&lt;/a&gt;
</code></pre>
<p>邮址的自动链接也很类似</p>
<h2 id="Markdown-免费编辑器"><a href="#Markdown-免费编辑器" class="headerlink" title="Markdown 免费编辑器"></a>Markdown 免费编辑器</h2><hr>
<p>Windows：</p>
<ul>
<li><a href="http://markdownpad.com/">MarkdownPad</a></li>
<li><a href="http://markpad.fluid.impa.br/">MarkPad</a></li>
<li><a href="https://atom.io/">GitHub Atom</a></li>
</ul>
<p>Linux:</p>
<ul>
<li><a href="http://www.oschina.net/p/retext">ReText</a></li>
</ul>
<p>Mac:</p>
<ul>
<li><a href="http://25.io/mou/">Mou</a></li>
</ul>
<p>网页在线：</p>
<ul>
<li><a href="https://markable.in/">Markable.in</a></li>
<li><a href="http://dillinger.io/">Dillinger.io</a></li>
<li><a href="http://mahua.jser.me/">MaHua</a></li>
</ul>
<p>高级：Sublime Text 3 + MarkdownPre + MarkdownEditing</p>
<ul>
<li>Sublime Text 3</li>
</ul>
<h2 id="Markdown项目主页"><a href="#Markdown项目主页" class="headerlink" title="Markdown项目主页"></a>Markdown项目主页</h2><p><a href="http://daringfireball.net/projects/markdown/">Markdown Project</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.markdown.cn/">http://www.markdown.cn</a><br><a href="http://wowubuntu.com/markdown/index.html">http://wowubuntu.com/markdown</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown进阶</title>
    <url>/2016/11/03/Markdown%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="Markdown列表嵌套"><a href="#Markdown列表嵌套" class="headerlink" title="Markdown列表嵌套"></a>Markdown列表嵌套</h2><p>Markdown列表(包括有序和无序列表）嵌套，可以通过缩进4个空格或1个Tab来实现：</p>
<span id="more"></span>

<pre><code>- China
    + Beijing
    + Shanghai
- Japan
    + Tokyo
- America
    + NewYork
    + Washington
</code></pre>
<p>效果：</p>
<ul>
<li>China<ul>
<li>Beijing</li>
<li>Shanghai</li>
</ul>
</li>
<li>Japan<ul>
<li>Tokyo</li>
</ul>
</li>
<li>America<ul>
<li>NewYork</li>
<li>Washington</li>
</ul>
</li>
</ul>
<h2 id="Markdown代码嵌入连续3个-字符"><a href="#Markdown代码嵌入连续3个-字符" class="headerlink" title="Markdown代码嵌入连续3个`字符"></a>Markdown代码嵌入连续3个`字符</h2><p>Markdown要想在代码里面保留三个`字符它的原始样子而不被转换成代码块(标准MD中没有)，可以增加4个或更多的` 来包裹：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">````</span><br><span class="line">```</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;Hello World!&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">````</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于连续N个`，需要N + 1 个`来进行包裹</p>
</blockquote>
<h2 id="Markdown首行缩进"><a href="#Markdown首行缩进" class="headerlink" title="Markdown首行缩进"></a>Markdown首行缩进</h2><p>写文章时，我们常常希望能够首行缩进，这时可以在段首加入<code>&amp;ensp;</code>来输入一个空格.加入<code>&amp;emsp;</code>来输入两个空格。<br>如：</p>
<pre><code>&gt; No Space In Line
&gt; &amp;emsp;Two Space In Line
&gt; &amp;emsp;&amp;emsp; Four Space In Line
&gt; &amp;ensp;One Space In Line
&gt; &amp;ensp;&amp;ensp; Two Space In Line
</code></pre>
<p>效果：<br><img src="http://www.taolingyang.com/2016/11/03/Markdown%E8%BF%9B%E9%98%B6/markdown-ex1.png" alt="markdown-indent"></p>
<p>普通段落尽量不用空格或制表符来缩进，即使使用它们后得到的效果看似是对的</p>
<h2 id="Markdown脚注"><a href="#Markdown脚注" class="headerlink" title="Markdown脚注"></a>Markdown脚注</h2><p>Markdown脚注(标准MD中没有)的语法看起来是这样的：</p>
<pre><code>A[^A]
[^A]: 注释
</code></pre>
<p>如：</p>
<pre><code>Markdown[^Markdown]
[^Markdown]: Markdown 是一种轻量级的标记语言，以易读易写作为宗旨
GFM[^GFM]
[^GFM]: GFM全称为GitHub Flavored Markdown
</code></pre>
<p>效果：<br><img src="http://www.taolingyang.com/2016/11/03/Markdown%E8%BF%9B%E9%98%B6/markdown-ex2.png" alt="markdown-foot"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>标记语言</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题美化</title>
    <url>/2020/09/06/Next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>Next主题默认配置满足基本的写作需求，有时候需要根据自定义配置让Next主题按照自己喜欢的方式呈现或增加一些额外的实用功能</p>
<span id="more"></span>

<h2 id="Next主题版本"><a href="#Next主题版本" class="headerlink" title="Next主题版本"></a>Next主题版本</h2><hr>
<p>Next主题GitHub仓库经过了几次大的变更，以前的仓库由于作者不维护了或者维护的比较少或者仓库管理权限问题，导致仓库地址经常变动，最新的仓库地址为<a href="https://github.com/next-theme/hexo-theme-next">hexo-theme-next</a></p>
<blockquote>
<p>如果需要了解各个版本和Hexo的兼容性即升级方法可以访问官方<a href="https://theme-next.js.org/docs/getting-started/upgrade">Upgrade</a></p>
</blockquote>
<h2 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h2><hr>
<h3 id="侧边栏一直显示"><a href="#侧边栏一直显示" class="headerlink" title="侧边栏一直显示"></a>侧边栏一直显示</h3><pre><code>sidebar:
  display: always
</code></pre>
<blockquote>
<p>左边的侧边栏一直显示，<code>post</code>默认打开文章显示</p>
</blockquote>
<h3 id="增加侧边栏阅读进度及回顶端"><a href="#增加侧边栏阅读进度及回顶端" class="headerlink" title="增加侧边栏阅读进度及回顶端"></a>增加侧边栏阅读进度及回顶端</h3><pre><code>back2top:
  enable: true
  sidebar: true
  scrollpercent: true
</code></pre>
<h2 id="增加右上角GitHub入口"><a href="#增加右上角GitHub入口" class="headerlink" title="增加右上角GitHub入口"></a>增加右上角GitHub入口</h2><hr>
<pre><code>github_banner:
  enable: true
  permalink: https://github.com/your_github_name
</code></pre>
<h2 id="隐藏powered-By-Hexo"><a href="#隐藏powered-By-Hexo" class="headerlink" title="隐藏powered By Hexo"></a>隐藏powered By Hexo</h2><hr>
<pre><code> powered: false
</code></pre>
<h2 id="添加文章版权声明"><a href="#添加文章版权声明" class="headerlink" title="添加文章版权声明"></a>添加文章版权声明</h2><hr>
<pre><code>creative_commons:
  post: true
</code></pre>
<h2 id="显示文章字数统计"><a href="#显示文章字数统计" class="headerlink" title="显示文章字数统计"></a>显示文章字数统计</h2><hr>
<p>1.<code>Hexo</code>根目录安装插件:</p>
<pre><code>npm install hexo-symbols-count-time
</code></pre>
<p>2.修改<code>Next</code>配置文件:</p>
<pre><code>symbols_count_time:
  separated_meta: true
  item_text_total: true
</code></pre>
<h2 id="增加评论系统"><a href="#增加评论系统" class="headerlink" title="增加评论系统"></a>增加评论系统</h2><hr>
<p>静态博客的评论系统比较多，本文选取了<a href="https://github.com/walinejs/waline">Waline</a>作为博客评论系统，<code>Waline</code>的官方教程: <a href="https://waline.js.org/">Waline Org</a><br>常用的部署<code>Waline</code>评论系统有以下几种方式:</p>
<h3 id="Vercel-LeadCloud"><a href="#Vercel-LeadCloud" class="headerlink" title="Vercel + LeadCloud"></a>Vercel + LeadCloud</h3><p>该方案使用<code>Vercel</code>作为服务器，<code>LeadCloud</code>作为默认数据库配置<code>Waline</code>评论系统,主要缺点是<code>Vercel</code>服务器自带的域名国内无法访问，需要自己绑定备案的域名，且<code>LeadCloud</code>国内版也需要备案域名或国际版经常被屏蔽无法访问，所以搭建国内使用的评论系统没有备案的域名访问起来很不稳定，配置方法见<a href="https://waline.js.org/guide/get-started.html">Vercel-LeadCloud快速上手</a></p>
<h3 id="Railway-PostSQL"><a href="#Railway-PostSQL" class="headerlink" title="Railway + PostSQL"></a>Railway + PostSQL</h3><p>该方案使用<code>Railway</code>作为服务器，<code>PostSQL</code>作为数据库配置<code>Waline</code>评论系统,由于两者都是对国内比较友好的方案，所以本人选取了此方案，且<code>Railway</code>可以直接通过授权<code>GitHub</code>账户进行配置，里面也自带了<code>PostSQL</code>作为数据库存储评论系统的用户信息和评论信息，配置方式相对简单，具体方法见<a href="https://waline.js.org/guide/server/railway.html">Railway部署</a></p>
<blockquote>
<p>更新Waline版本方法：进入到个人的GitHub 仓库中，修改<code>package.json</code>文件中的<code>@waline/vercel</code>版本号为最新版本即可</p>
</blockquote>
<h3 id="其他服务器-数据库独立部署"><a href="#其他服务器-数据库独立部署" class="headerlink" title="其他服务器+数据库独立部署"></a>其他服务器+数据库独立部署</h3><p>其他的方案包括使用<code>CloudBase</code>腾讯云开发部署，<code>Deta</code>部署等方式，数据库也除了默认<code>LeadCloud</code>还支持多种其他数据库，包括<code>MySQL</code>,<code>PostSQL</code>,<code>SQLite</code>及<code>MongoDB</code>等等，这些服务器和数据库组合起来独立部署相对来说操作比较复杂，具体搭建方法，也可以通过官方的指南进行部署</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCascade及资源汇总</title>
    <url>/2021/08/01/OpenCascade%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><a href="https://www.opencascade.com/">OpenCascade</a>，简称<code>OCCT</code>，是一个开源的3D几何内核开发平台库，Wiki上这样论述<code>OCCT</code>：</p>
<pre><code>Open Cascade Technology (OCCT), formerly called CAS.CADE, is an open-source software development platform for 3D CAD, CAM, CAE, etc.
that is developed and supported by Open Cascade SAS. 
OCCT is a full-scale B-Rep (Boundary representation) modeling toolkit. 
OCCT is available under the LGPL-2.1-only license permitting its usage in open source and proprietary applications
</code></pre>
<blockquote>
<p><code>OCCT</code> 前称 CAS.CADE，是一个开源的3D计算机辅助设计，辅助制造，辅助功能等的软件开发平台，由 Open Cascade SAS这家机构开发和支持。<code>OCCT</code>是一个<code>BRep</code>模型工具包，在LGPL-2.1的开源许可证下使用。</p>
</blockquote>
<span id="more"></span>

<h2 id="几何内核平台"><a href="#几何内核平台" class="headerlink" title="几何内核平台"></a>几何内核平台</h2><p>除了<code>OCCT</code>作为数不多的开源几何内核平台外，还有其他的商业几何平台，常见的应用和内核如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">Kernel</th>
<th align="center">Application</th>
<th align="center">Country</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ShapeManager</td>
<td align="center">AutoCAD</td>
<td align="center">USA</td>
</tr>
<tr>
<td align="center">Parasolid</td>
<td align="center">Siemens NX</td>
<td align="center">USA,Germany</td>
</tr>
<tr>
<td align="center">Parasolid</td>
<td align="center">SolidWorks</td>
<td align="center">USA,France</td>
</tr>
<tr>
<td align="center">C3D</td>
<td align="center">KOMPAS</td>
<td align="center">Russia</td>
</tr>
<tr>
<td align="center">ACIS</td>
<td align="center">ArchiCAD</td>
<td align="center">Hungary</td>
</tr>
<tr>
<td align="center">CGM</td>
<td align="center">CATIA</td>
<td align="center">France</td>
</tr>
<tr>
<td align="center">ACIS</td>
<td align="center">Cimatron</td>
<td align="center">Israel</td>
</tr>
<tr>
<td align="center">OpenCascade</td>
<td align="center">FreeCAD</td>
<td align="center">France</td>
</tr>
<tr>
<td align="center">ACIS</td>
<td align="center">SpaceClaim</td>
<td align="center">USA</td>
</tr>
</tbody></table>
<blockquote>
<p>几何内核平台基本上被Siemens公司的<code>Parasolid</code>和Dassault公司的<code>ACIS</code>垄断，常用的UG，SolidWorks软件都是基于这些内核开发的，而本文介绍的<code>OCCT</code>开源内核比较出名的也是开源的FreeCAD软件</p>
</blockquote>
<h2 id="OCCT概况"><a href="#OCCT概况" class="headerlink" title="OCCT概况"></a>OCCT概况</h2><h3 id="OCCT功能"><a href="#OCCT功能" class="headerlink" title="OCCT功能"></a>OCCT功能</h3><p><code>OCCT</code>提供了3D表面和实体建模，CAD数据交换，可视化等基本功能，主要是以C++库的形式提供，包括以下功能：</p>
<ol>
<li>基本的数据结构，包括几何模型，可视化，交互式选择及特定应用服务接口</li>
<li>模型算法</li>
<li>Mesh数据</li>
<li>和标准数据格式(IGES,STEP)交互</li>
</ol>
<h3 id="OCCT模块"><a href="#OCCT模块" class="headerlink" title="OCCT模块"></a>OCCT模块</h3><p><code>OCCT</code>以C++库形式组合成模块，主要包括以下模块：</p>
<ol>
<li>Foundation Classse: 其他OCCT类依赖的基本类库，包括基本类，内存分配器，OS抽象层，集合数据结构，BVH树，向量，矩阵等基本数学运算类库</li>
<li>Modeling Data: 提供表达2D&#x2F;3D几何基本元素及其组合的CAD模型数据结构，集合图元包括分析曲线如直线，圆，椭圆，双曲线，抛物线，Bezier曲线，B样条曲线，偏移等；分析曲面如平面，圆柱面，圆锥面，圆环面，球面，Bezier,B样条，旋转，拉伸，偏移等，这些基本的图元模型定义及<code>Brep</code>表达实现</li>
<li>Modeling Algorithm: 提供Mesh和各种几何和拓扑相关算法，如交集，布尔运算，网格划分，倒角，修复等等</li>
<li>Visualiztion: 提供数据可视化显示的复杂机制，实现了一个紧凑的<code>OpenGL/OpenGL ES</code>渲染器，支持常用的着色模型和光线跟踪路径跟踪算法，除了<code>OCCT</code>自己提供<code>AIS</code>模块可视化显示外还支持第三方的如<code>VTK</code>库的集成显示</li>
<li>Data Exchange: 提供与主流数据格式的互操作性和依赖<code>Shape Healing</code>提高不同CAD系统的兼容性</li>
<li>Application Framework: 提供开箱即可用的开发上层应用的基本框架<br>模块功能如下图所示：<br><img src="http://www.taolingyang.com/2021/08/01/OpenCascade%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/occt-modular.png" alt="occt-modular"></li>
</ol>
<h2 id="OCCT资源"><a href="#OCCT资源" class="headerlink" title="OCCT资源"></a>OCCT资源</h2><p>本人在使用<code>OCCT</code>平台时候，主要参考了以下几种资源，现在罗列如下:</p>
<h3 id="官方资源"><a href="#官方资源" class="headerlink" title="官方资源"></a>官方资源</h3><ol>
<li><p>最权威齐全的说明文档地址：<a href="https://dev.opencascade.org/doc/overview/html/">Full Online Documentation</a></p>
<blockquote>
<p>里面包含了<code>OCCT</code>大部分的说明包括模块介绍，每个模块的具体详细部分原理和代码说明，源码和第三方库各个平台编译<code>OCCT</code>的方法，官方自带的各种例子，算法测试命令行，一些标准说明比如<code>Brep</code>格式等等，算是比较权威和齐全的说明</p>
</blockquote>
</li>
<li><p>开发API查询地址：<a href="https://dev.opencascade.org/doc/refman/html/index.html">Reference Manual</a></p>
<blockquote>
<p>根据<code>OCCT</code>源代码文档注释通过<code>Doxygen</code>文档生成工具生成的文档，实时更新的文档，对查询<code>OCCT</code>各个模块，类，函数，变量，常量等各种类型的定义和使用说明很有帮助</p>
</blockquote>
</li>
<li><p>付费的E-Training: <a href="https://www.opencascade.com/training-programs/">E-Training</a></p>
<blockquote>
<p>付费的官方培训或电子视频资源</p>
</blockquote>
</li>
<li><p>官方论坛: <a href="https://dev.opencascade.org/forums">Forums</a></p>
<blockquote>
<p>遇到问题可以在上面进行提问，里面包含了<code>OCCT</code>实时的release和announcement信息及分模块讨论板块</p>
</blockquote>
</li>
<li><p>技术博客：<a href="https://dev.opencascade.org/blog">Blog</a></p>
<blockquote>
<p>官方的版本发布信息及一些技术原理分享</p>
</blockquote>
</li>
<li><p>视频资源：<a href="https://www.youtube.com/channel/UCO6fnQhuib2WjMZwB-lxIwA">Youtube</a></p>
<blockquote>
<p>需要科学上网，官方的<code>Youtube</code>视频，主要包括一些<code>OCCT</code>产品应用和部分特性讲解，相对而言技术干货比较少些</p>
</blockquote>
</li>
<li><p>源码：<br><a href="https://github.com/Open-Cascade-SAS/OCCT">OCCT-GitHub</a><br><a href="https://github.com/tpaviot/pythonocc">pythonOCC-Github</a></p>
</li>
</ol>
<h3 id="其他第三方资源"><a href="#其他第三方资源" class="headerlink" title="其他第三方资源"></a>其他第三方资源</h3><ol>
<li><p>技术博客<br>国内的为数不多的<code>OCCT</code>技术相关个人博客：<br><a href="http://www.cppblog.com/eryar/category/17808.html">eryar</a><br>国外<code>OCCT</code>技术相关个人博客(可能需要科学上网)：<br><a href="https://unlimited3d.wordpress.com/">Unlimited 3D</a><br><a href="https://opencascade.blogspot.com/">OpenCascade Notes</a><br><a href="http://quaoar.su/blog/">Manifold Geometry</a></p>
</li>
<li><p>视频资源：<a href="https://www.youtube.com/c/QuaoarsWorkshop">Quaoar’s Workshop</a></p>
<blockquote>
<p>需要科学上网，俄罗斯<code>OCCT</code>资深开发者的<code>Youtube</code>频道，讲解了很多关于<code>OCCT</code>的方面的技术和教程，很详细很难得的免费视频资源</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://en.wikipedia.org/wiki/Open_Cascade_Technology">OpenCascade Technology wikipedia</a></p>
<p><a href="https://www.opencascade.com/">OpenCascade Official</a></p>
<p><a href="https://dev.opencascade.org/doc/overview/html">OpenCascade Dev Doc</a></p>
<p><a href="https://github.com/Open-Cascade-SAS/OCCT">OpenCascade -GitHub</a></p>
]]></content>
      <categories>
        <category>OpenCascade</category>
      </categories>
      <tags>
        <tag>OpenCascade</tag>
        <tag>3D</tag>
        <tag>Geometry</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim编辑器总结</title>
    <url>/2017/07/08/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>最近换了工作，博客很久没跟新了。新工作与原来的领域知识相差很多，变化比较大，所以需要了解的东西比较多。之前大部分情况都是使用VS或SourceInsight阅读写代码，由于最近需要频繁在Linux远程服务器上进行代码开发，同时Windows磁盘映射的速度很慢，为了提高生产力，因此尝试这使用Linux自带的文本编辑器VIM来进行代码编辑,下面简要介绍下对VIM的基本了解和使用。</p>
<span id="more"></span>
<h2 id="VIM入门"><a href="#VIM入门" class="headerlink" title="VIM入门"></a>VIM入门</h2><hr>
<h3 id="VIM工作模式"><a href="#VIM工作模式" class="headerlink" title="VIM工作模式"></a>VIM工作模式</h3><hr>
<p>VIM是纯文本的文本编辑器，纯文本的编辑常用的操作就是增删改减，在这些基本的操作过程中，需要辅助一些其他的操作，如为了定位文本需要进行鼠标移动操作命令，为了选中文本需要进行文本选中操作，为了进行文本查找、替换等操作需要文本筛选操作等等。为了方便这些操作VIM延伸出4种基本的工作模式。</p>
<h4 id="Normal模式"><a href="#Normal模式" class="headerlink" title="Normal模式"></a>Normal模式</h4><hr>
<p>VIM缺省模式,主要在该模式下进行文本定位移动和删除, 在其他模式下通过Esc回到Normal模式.</p>
<h4 id="Insert模式"><a href="#Insert模式" class="headerlink" title="Insert模式"></a>Insert模式</h4><hr>
<p>该模式在需要输入文本时候使用，正常模式下通过以下命令进入插入模式:</p>
<ol>
<li><code>i</code>(光标前插入)</li>
<li><code>a</code>(光标后插入)</li>
<li><code>c</code>(光标处固定长度替换插入)</li>
<li><code>s</code>(光标处不固定长度替换插入)</li>
<li><code>o</code>(在光标下一行行首插入)</li>
<li><code>I</code>(行首前插入)</li>
<li><code>A</code>(行尾后插入)</li>
<li><code>C</code>(光标处到行尾替换插入)</li>
<li><code>S</code>(整行替换插入)</li>
<li><code>O</code>(在光标上一行行首插入)</li>
</ol>
<h4 id="Visual模式"><a href="#Visual模式" class="headerlink" title="Visual模式"></a>Visual模式</h4><hr>
<p>该模式主要用于文本选定,这样可以方便后续进行块的替换、删除、复制粘贴操作,正常模式输入以下命令进入Visual模式：</p>
<ol>
<li><code>v</code>(小写):按字符选定</li>
<li><code>V</code>(大写):按行选定</li>
<li><code>Ctrl-V</code>(大写):按列选定</li>
</ol>
<h4 id="Command模式"><a href="#Command模式" class="headerlink" title="Command模式"></a>Command模式</h4><hr>
<p>该模式用于执行文本编辑命令，正常模式下输入以下命令然后回车(Enter)即可完成所需的命令：</p>
<ol>
<li>:(冒号)一般的命令,命令包括外部命令(以！开头),内部命令(不加！)</li>
<li>&#x2F;(正斜杠)正向搜索命令</li>
<li>?(问号)反向搜索命令</li>
</ol>
<p>在了解基本命令后通过后续不断练习来熟悉VIM操作.</p>
<h3 id="VIM练习"><a href="#VIM练习" class="headerlink" title="VIM练习"></a>VIM练习</h3><hr>
<h4 id="vimtutor"><a href="#vimtutor" class="headerlink" title="vimtutor"></a>vimtutor</h4><hr>
<p>一开始练习，推荐Linux系统自带的vimtutor工具，直接在shell终端输入:</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vimtutor</span></span><br></pre></td></tr></table></figure>
<p>按照vimtutor的顺序开始45min~60min的练习后，大概会了解和熟悉VIM的基本操作：</p>
<ol>
<li>上下左右移动: <code>k</code>,<code>j</code>,<code>h</code>,<code>l</code>; 移动到单词末尾:<code>e</code>; </li>
<li>强制退出: <code>:q!&lt;Enter&gt;</code>; 保存退出: <code>:wq&lt;Enter&gt;</code>;保存所有Buffer: <code>:wa&lt;Enter&gt;</code>;保存当前打开文本到新建文件: <code>:w + new_file_name&lt;Enter&gt;</code>; 打开文件: <code>:e + file_name</code>; 查看Buffer: <code>:ls</code>,选中某一个Buffer n: <code>:b N</code>;选中打开的Buffer前一个和后一个文件:<code>:bp</code>, <code>:bn</code>;</li>
<li>删除光标处字符:<code>x</code> </li>
<li>光标前插入:<code>i</code>; 行尾插入:<code>A</code></li>
<li>删除命令:<code>d + motion</code>,如: <blockquote>
<p><code>de</code>:删除光标至单词末尾<br><code>d$</code>:删除光标至行尾<br><code>dw</code>:删除光标至下一个单词首<br><code>dd</code>:删除当前行</p>
</blockquote>
</li>
<li>使用数字进行一次行多次移动,删除操作,如:<blockquote>
<p><code>2k</code>:向上移动两行<br><code>3e</code>:移动到光标后第3个单词末尾<br><code>0</code>:移动到行首(不忽略空格, ^:移动到行首忽略空格)<br><code>d2w(2dw)</code>:删除光标位置开始两个单词(d + num + motion 或者 num + d + motion)<br><code>2dd(d2d)</code>:删除当前行和下一行共两行</p>
</blockquote>
</li>
<li>恢复上一次修改:<code>u</code>; 恢复当前行的所有修改:<code>U</code>; 撤销恢复:<code>Ctrl+R</code></li>
<li>复制黏贴: 复制:<code>y + motion</code>; 黏贴:<code>p</code><blockquote>
<p><code>yw</code>:  复制到下个单词行首(不包括行首字符)<br><code>yaw</code>: 复制当前单词(y a word for short)<br><code>y$</code>:  复制光标至行末</p>
</blockquote>
</li>
<li>单个字符替换: <code>r</code>; 当前光标无长度限制覆盖式替换:<code>R</code></li>
<li>替换操作:<code>c + num + motion</code>,如:<blockquote>
<p><code>cw</code>:  替换到下个单词首(不包括首字符);<br><code>caw</code>: 替换当前单词(y a word for short)<br><code>c$</code>:  替换光标至行末<br><code>c2e</code>: 替换光标至下一个单词末(包括尾字符)</p>
</blockquote>
</li>
<li>文件状态定位,如:<blockquote>
<p><code>Ctrl-G</code>:查看当前文件位置和状态<br><code>G</code>:移动到文件首行<br><code>gg</code>:移动到文件尾行</p>
</blockquote>
</li>
<li>搜索&amp;替换,如:<blockquote>
<p><code>/</code>: 正向搜索<br><code>n</code>:匹配同向搜索结果,N:匹配反向搜索结果<br><code>?</code>: 反向搜索<br><code>n</code>:匹配同向搜索结果,N:匹配反向搜索结果<br>  <code>:s&lt;Enter&gt;</code>:替换<br><code>:s/old/new&lt;Enter&gt;</code>:在一行内替换第一个old为new<br><code>:s/old/new/g&lt;Enter&gt;</code>:在一行内替换所有old为new<br><code>:#,#s/old/new/g&lt;Enter&gt;</code>:在两个#代表的行内替换所有old为new<br><code>:%s/old/new/g&lt;Enter&gt;</code>:在整个文件内替换所有old为new<br><code>:%s/old/new/gci&lt;Enter&gt;</code>:在整个文件内替换所有old为new,且需要确认(c)并且忽略大小写(i)</p>
</blockquote>
</li>
<li>执行外部命令,以!开头:<blockquote>
<p><code>:!pwd&lt;Enter&gt;</code>: 显示当前工作路径<br><code>:!ls&lt;Enter&gt;</code>:  显示当前工作路径所有文件</p>
</blockquote>
</li>
<li>读取文本到当前光标位置<blockquote>
<p><code>:r !pwd&lt;Enter&gt;</code>: 读取当前工作路径文本到光标位置<br><code>:r filename&lt;Enter&gt;</code>: 读取filename文件内文本到光标位置</p>
</blockquote>
</li>
</ol>
<h4 id="VIM帮助"><a href="#VIM帮助" class="headerlink" title="VIM帮助"></a>VIM帮助</h4><hr>
<p>通过Linux自带的vimtutor基本上就会使用基本的文本编辑操作了,如果需要查询更详细的可以输入如下命令:</p>
<pre><code>:help user-manual
</code></pre>
<h2 id="VIM规律与技巧"><a href="#VIM规律与技巧" class="headerlink" title="VIM规律与技巧"></a>VIM规律与技巧</h2><hr>
<h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><hr>
<p>VIM移动光标命令是以一定的操作单位为基本移动距离的,然后在需要的时候选择合适的操作次数,基本原则是: <strong>先定操作单位再定操作次数</strong>,基本的操作单位如下表所示:</p>
<table>
<thead>
<tr>
<th align="center">操作单位</th>
<th align="center">命令</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符</td>
<td align="center"><code>h</code>(左移动一个字符);<code>l</code>(右移动一个字符)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">单词</td>
<td align="center"><code>w/W</code>(移动到下单词首);<code>b/B</code>(移动到上单词首);<code>e/E</code>(移动到光标所在单词首)</td>
<td align="center"><code>W</code>,<code>B</code>,<code>E</code>单词是以空格和Tab区分单词的,<code>w</code>,<code>b</code>,<code>e</code>是以数字和字母外其他字符区分单词的</td>
</tr>
<tr>
<td align="center">行</td>
<td align="center"><code>j</code>(移动到下行);<code>k</code>(移动到上行);<code>0</code>(移动到当前行首);<code>^</code>(移动到当前行首第一个非空字符);<code>$</code>(移动到当前行尾);<code>:n</code>(移动到第n行)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">句子</td>
<td align="center"><code>)</code>(移动到当前句尾);<code>(</code>(移动到当前句首)</td>
<td align="center">句子边界是以<code>.</code>,<code>!</code>,<code>?</code>结尾并紧随着一个换行、空格或制表符,段落和节也视为句子边界</td>
</tr>
<tr>
<td align="center">段落</td>
<td align="center"><code>&#125;</code>(移动到当前段尾);<code>&#123;</code>(移动到当前段首)</td>
<td align="center">段边界是以空行为边界,段落和节也视为句子边界</td>
</tr>
<tr>
<td align="center">屏</td>
<td align="center"><code>H</code>(移动到屏幕第一行);<code>M</code>(移动到屏幕中间行);<code>L</code>(移动到屏幕最后行)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">页</td>
<td align="center"><code>Ctrl-f</code>(向前滚动一页);<code>Ctrl-b</code>(向后滚动一页);<code>Ctrl-u</code>(向前滚动半页);<code>Ctrl-d</code>(向后滚动半页)</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">文件</td>
<td align="center"><code>G</code>(移动到文件尾);<code>gg</code>(移动到文件头);<code>:0</code>(移动到文件第一行);<code>:$</code>(移动到文件最后一行)</td>
<td align="center">无</td>
</tr>
</tbody></table>
<ol>
<li><p>移动光标到指定字符:</p>
<blockquote>
<p><code>fa</code>:移动到当前行字符a处,<code>F</code>则表示反方向<br><code>2fa</code>:移动到当前行第二次出现字符a处,<code>F</code>则表示反方向<br><code>ta</code>:移动到当前行字符a前一处,<code>T</code>则表示反方向</p>
</blockquote>
</li>
<li><p>文本编辑确定原则后,基本的编辑格式为:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">num</span> + motion</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>3j</code>: 向下移动三行<br><code>5G</code>: 移动到第5行</p>
</blockquote>
</li>
<li><p>移动光标基本单位外还有些常用命令如下:</p>
<blockquote>
<p><code>%</code>: 跳转到与之匹配的括号处<br><code>.</code>: 重复执行上次命令<br><code>/</code>.<code>: 跳转到最近修改位置并定位编辑点 </code>*<code>: 向前搜索光标所在单词 </code>#<code>: 向后搜索光标所在单词 </code>q&#x2F;<code>: 显示搜索命令历史窗口 </code>q:&#96;: 显示命令模式输入的命令历史窗口</p>
</blockquote>
</li>
</ol>
<h3 id="编辑文本"><a href="#编辑文本" class="headerlink" title="编辑文本"></a>编辑文本</h3><hr>
<h4 id="基本编辑文本命令"><a href="#基本编辑文本命令" class="headerlink" title="基本编辑文本命令"></a>基本编辑文本命令</h4><hr>
<p>与移动光标类似,在进行文本增删改选中等操作过程中也需要操作单位和操作数量,这些操作单位与光标移动一样,基本原则是: <strong>先定操作类型,后定操作单位和操作次数</strong>, 基本操作单位和命令如表所示:</p>
<table>
<thead>
<tr>
<th align="center">操作单位</th>
<th align="center">命令</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字符</td>
<td align="center"><code>x</code>(删除光标位置所在字符);<code>c</code>(替换光标位置所在字符,并进入插入模式);<code>s</code>(替换光标位置所在字符,并进入插入模式;<code>r</code>(替换光标位置所在字符,不进入插入模式;<code>i</code>(在光标位置所在字符前插入,并进入插入模式;<code>a</code>(在光标位置所在字符后插入,并进入插入模式;</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">单词</td>
<td align="center"><code>c(d,y,v)w/cW</code>(修改到下单词首);<code>c(d,y,v)b/c(d,y,v)B</code>(修改到上单词首);<code>c(d,y,v)e/c(d,y,v)E</code>(修改到光标所在单词首)</td>
<td align="center"><code>W</code>,<code>B</code>,<code>E</code>单词是以空格和Tab区分单词的,<code>w</code>,<code>b</code>,<code>e</code>是以数字和字母外其他字符区分单词的</td>
</tr>
<tr>
<td align="center">行</td>
<td align="center"><code>c(d,y,v)j</code>(修改到下行);<code>c(d,y,v)k</code>(修改到上行);<code>c(d,y,v)0</code>(修改到当前行首);<code>c(d,y,v)^</code>(修改到当前行首第一个非空字符);<code>c(d,y,v)$</code>(修改到当前行尾);</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">句子</td>
<td align="center"><code>c(d,y,v))</code>(修改到当前句尾);<code>c(d,y,v)(</code>(修改到当前句首)</td>
<td align="center">句子边界是以<code>.</code>,<code>!</code>,<code>?</code>结尾并紧随着一个换行、空格或制表符,段落和节也视为句子边界</td>
</tr>
<tr>
<td align="center">段落</td>
<td align="center"><code>c(d,y,v)&#125;</code>(修改到当前段尾);<code>c(d,y,v)&#123;</code>(修改到当前段首)</td>
<td align="center">段边界是以空行为边界,段落和节也视为句子边界</td>
</tr>
<tr>
<td align="center">文件</td>
<td align="center"><code>c(d,y,v)G</code>(修改到文件尾);<code>c(d,y,v)gg</code>(修改到文件头);<code>:0</code>(移动到文件第一行);<code>:$</code>(移动到文件最后一行)</td>
<td align="center">无</td>
</tr>
</tbody></table>
<p>文本编辑确定原则后,基本的编辑格式为:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">c</span><span class="params">(d,y,v)</span></span> + num + motion</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>caw</code>: 替换当前光标所在单词<br><code>d2w</code>: 删除当前光标所在至后面一个单词</p>
</blockquote>
<h4 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h4><hr>
<p>常用的列操作命令有:<br><code>Ctrl-V</code>: 进入列编辑模式,然后通过移动命令选中列进行编辑操作<br><code>I</code>: 进入列编辑模式时候鼠标前插入操作<br><code>A</code>: 进入列编辑模式时候鼠标后插入操作</p>
<h4 id="文本区域选中或编辑"><a href="#文本区域选中或编辑" class="headerlink" title="文本区域选中或编辑"></a>文本区域选中或编辑</h4><hr>
<ol>
<li>选中或编辑一个区域,不包括区域符号本身:<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">c</span><span class="params">(d,y,v)</span></span> + <span class="selector-tag">i</span> + <span class="built_in">region</span>(<span class="string">&quot;,&#x27;,),],&#125;)</span></span><br></pre></td></tr></table></figure></li>
<li>选中或编辑一个区域,包括区域符号本身:<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">c</span><span class="params">(d,y,v)</span></span> + <span class="selector-tag">a</span> + <span class="built_in">region</span>(<span class="string">&quot;,&#x27;,),],&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="文本编辑其他常用命令"><a href="#文本编辑其他常用命令" class="headerlink" title="文本编辑其他常用命令"></a>文本编辑其他常用命令</h4><hr>
<p>文本编辑基本单位外还有些常用命令如下:</p>
<blockquote>
<p><code>dd</code>: 删除光标所在行<br><code>yy</code>: 复制光标所在行<br><code>xp</code>: 交换光标位置和其后的字符<br><code>ddp</code>: 交换光标和其后的行<br><code>~</code>: 将光标所在字符大小写翻转<br><code>guw</code>: 将光标所在单词变为小写<br><code>gUw</code>: 将光标所在单词变为大写<br><code>guu</code>: 将光标所在行所有字符变为小写<br><code>gUU</code>: 将光标所在行所有字符变为大写<br><code>g~~</code>: 将光标所在行所有字符大小写翻转<br><code>ga</code>: 显示光标所在字符内码<br><code>&gt;&gt;</code>: 右缩进<br><code>&lt;&lt;</code>: 左缩进<br><code>==</code>: 格式化<br><code>Ctrl-p</code>: 自动补全<br><code>Ctrl-n</code>: 自动补全移动选中<br><code>Shirf-K</code>: 显示光标所在当前Linux系统函数帮助界面</p>
</blockquote>
<h2 id="VIM其他常用功能"><a href="#VIM其他常用功能" class="headerlink" title="VIM其他常用功能"></a>VIM其他常用功能</h2><hr>
<h3 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h3><hr>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><hr>
<p>VIM支持多窗口分屏功能,了解分屏功能之前,需了解VIM的几个概念:</p>
<ol>
<li><strong>Buffer</strong><br> A buffer is the in-memory text of a file:可以看做内存中的文本,还未写到磁盘上,修改均发生在内存上</li>
<li><strong>Window</strong><br> A window is a viewport on a buffer: 用来显示Buffer, 同一个Buffer可以有多个Window(一个Window只显示一个Buffer)</li>
<li><strong>Tab</strong><br> A tab page is a collection of windows: 包含一系列Window</li>
</ol>
<h4 id="分屏命令"><a href="#分屏命令" class="headerlink" title="分屏命令"></a>分屏命令</h4><hr>
<p>常用的分屏命令有:<br><code>:split</code>: 创建分屏,默认是水平分屏(<code>:vsplit</code>是垂直分屏)<br><code>Ctrl-w + (i,j,h,k)</code>: 上下左右切换分屏<br><code>Ctrl-w + (I,J,H,K)</code>: 上下左右移动光标所在分屏<br><code>Ctrl-w +(-) </code>: 增加或减少尺寸<br><code>Ctrl-w +(_[Shift+-]) </code>: 屏幕高度扩展到最大<br><code>Ctrl-w +(|[Shift+\]) </code>: 屏幕宽度扩展到最大</p>
<h4 id="切页命令"><a href="#切页命令" class="headerlink" title="切页命令"></a>切页命令</h4><hr>
<p>常用的切页命令有:<br><code>:tabnew + file_name</code>: 新建一个Tab页<br><code>:tabc</code>: 关闭当前Tab页<br><code>:tabo</code>: 关闭所有其他Tab页<br><code>:tabs</code>: 查看所有Tab页<br><code>:tabp</code>: 查看前一个Tab页<br><code>:tabn</code>: 查看后一个Tab页<br><code>Ngt</code>: 查看第N个Tab页</p>
<blockquote>
<p>xshell及SecureCRT可以通过<code>Alt + N</code>切换Tab页</p>
</blockquote>
<h3 id="文本折叠"><a href="#文本折叠" class="headerlink" title="文本折叠"></a>文本折叠</h3><hr>
<h4 id="折叠模式"><a href="#折叠模式" class="headerlink" title="折叠模式"></a>折叠模式</h4><hr>
<p>VIM文本支持多种折叠模式,可以通过以下命令在vim中设置或写在<code>.vimrc</code>配置文件中:</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> foldmethod=manual|<span class="type">indent</span>|<span class="type">expr</span>|<span class="type">syntax</span>|<span class="type">diff</span>|<span class="type">marker</span></span><br><span class="line">或者简写:</span><br><span class="line">:<span class="built_in">set</span> fdm=manual|<span class="type">indent</span>|<span class="type">expr</span>|<span class="type">syntax</span>|<span class="type">diff</span>|<span class="type">marker</span></span><br></pre></td></tr></table></figure>
<p>VIM折叠包括以下几种模式说明如下表所示:</p>
<table>
<thead>
<tr>
<th align="center">折叠模式</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">manual</td>
<td align="center">手工定义折叠</td>
</tr>
<tr>
<td align="center">indent</td>
<td align="center">缩进表示折叠</td>
</tr>
<tr>
<td align="center">expr</td>
<td align="center">表达式表示折叠</td>
</tr>
<tr>
<td align="center">syntax</td>
<td align="center">语法高亮表示折叠</td>
</tr>
<tr>
<td align="center">diff</td>
<td align="center">对没有更改文本表示折叠</td>
</tr>
<tr>
<td align="center">marker</td>
<td align="center">用特定标识(一般默认是<code>&#123;,&#125;,[,]</code>表示折叠)</td>
</tr>
</tbody></table>
<h4 id="折叠命令"><a href="#折叠命令" class="headerlink" title="折叠命令"></a>折叠命令</h4><hr>
<p>常用的VIM折叠命令如下表所示:</p>
<table>
<thead>
<tr>
<th align="center">折叠命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zf</td>
<td align="center">将选中的文本执行折叠</td>
</tr>
<tr>
<td align="center">zo</td>
<td align="center">打开当前的折叠</td>
</tr>
<tr>
<td align="center">zc</td>
<td align="center">关闭当前的折叠</td>
</tr>
<tr>
<td align="center">za</td>
<td align="center">打开关闭折叠切换</td>
</tr>
<tr>
<td align="center">zd</td>
<td align="center">删除当前的折叠</td>
</tr>
<tr>
<td align="center">zj</td>
<td align="center">移动至下一个折叠</td>
</tr>
<tr>
<td align="center">zk</td>
<td align="center">移动至上一个折叠</td>
</tr>
<tr>
<td align="center">zn</td>
<td align="center">禁用折叠</td>
</tr>
<tr>
<td align="center">zN</td>
<td align="center">启用折叠</td>
</tr>
<tr>
<td align="center">zE</td>
<td align="center">删除所有的折叠</td>
</tr>
<tr>
<td align="center">zM</td>
<td align="center">关闭所有及嵌套的折叠</td>
</tr>
<tr>
<td align="center">zr</td>
<td align="center">打开所有的折叠</td>
</tr>
<tr>
<td align="center">zR</td>
<td align="center">打开所有及嵌套的折叠</td>
</tr>
</tbody></table>
<p>折叠命令实例:</p>
<blockquote>
<p><code>zf</code>命令将选中的文本执行折叠,支持通过移动命令组合来折叠制定行,如:<br><code>zf10j</code>:折叠当前行后10行;<br><code>5zf</code>: 将当前行及其后4行折叠起来,<br><code>zf7G</code>: 将当前行至全文第7行折叠起来,<br><code>zfa(</code>: 折叠<code>(</code>包围区域<br>每次使用<code>zf</code>命令折叠后需要使用<code>:mkview</code>命令来保存折叠状态,该命令会在.vim下面生成view文件夹,后续重新打开该折叠后的文件可以通过<code>:loadview</code>来加载上次保存的折叠状态</p>
</blockquote>
<p>可以通过以下命令查看折叠help：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> folding</span><br></pre></td></tr></table></figure>
<h3 id="文本编辑宏录制"><a href="#文本编辑宏录制" class="headerlink" title="文本编辑宏录制"></a>文本编辑宏录制</h3><hr>
<p>VIM文本编辑宏主要是解决重复编辑操作或有一定规律的编辑操作,实在 <strong>Normal模式</strong> 下进行的,主要步骤如下:</p>
<ol>
<li><code>q*</code>:开始录制,<code>*</code>可以为<code>0~9a~zA~Z</code>中任意字符,相当于寄存器用来存刚才录制的宏</li>
<li>执行VIM编辑操作</li>
<li><code>q</code>: 停止录制宏</li>
<li><code>@*</code>: 执行录制宏,可以前面加数字表示执行多少次,如<code>10@a</code>表示重复执行10次录制在寄存器<code>a</code>中的宏,<code>@@</code>表示重复执行上次的<code>@*</code>操作</li>
</ol>
<p>如实现数字序号递增功能: </p>
<blockquote>
<ol>
<li>在某行输入<code>1</code>,并<code>Esc</code>退回至Normal模式</li>
<li>输入<code>qa</code>开始录制</li>
<li>输入<code>yy</code>复制当前<code>1</code>;输入<code>j</code>跳入下行;输入<code>p</code>黏贴到下行;输入<code>Ctrl-a</code>使数字自增</li>
<li>输入<code>q</code>结束录制</li>
<li>输入<code>n@a</code>可以使数字递增至n</li>
</ol>
</blockquote>
<p>可以通过以下命令查看宏help：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> recording</span><br></pre></td></tr></table></figure>


<h3 id="文本对比"><a href="#文本对比" class="headerlink" title="文本对比"></a>文本对比</h3><hr>
<p>VIM中可以通过如下命令以比较方式进行文件对比:</p>
<ol>
<li>打开两个文件进行对比:<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">vim -d file1 file2</span><br><span class="line"><span class="section">或者:</span></span><br><span class="line">vimdiff file1 file2</span><br></pre></td></tr></table></figure></li>
<li>已经打开文件file1,打开file2文件与其进行对比:<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">水平分割打开两个窗口:</span><br><span class="line"><span class="keyword">diffsplit</span> file2</span><br><span class="line">或垂直分割打开两个窗口:</span><br><span class="line"><span class="keyword">vert</span> <span class="keyword">diffsplit</span> file2</span><br></pre></td></tr></table></figure></li>
<li>已经打开文件file1,file2文件,分别在两个窗口输入:<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">diffthis</span></span><br></pre></td></tr></table></figure></li>
<li>其他文本比较命令:</li>
</ol>
<table>
<thead>
<tr>
<th align="center">比较命令</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:vimupdate</td>
<td align="center">更改文件后,更新diff结果</td>
</tr>
<tr>
<td align="center">[c</td>
<td align="center">跳转到上一个diff点</td>
</tr>
<tr>
<td align="center">]c</td>
<td align="center">跳转到下一个diff点</td>
</tr>
<tr>
<td align="center">dp</td>
<td align="center">将diff点的当前文档应用到另一个文档 (diff put)</td>
</tr>
<tr>
<td align="center">do</td>
<td align="center">将diff点的另一个文档应用到当前文档 (diff obtain)</td>
</tr>
</tbody></table>
<h2 id="VIM编译-Ubuntu"><a href="#VIM编译-Ubuntu" class="headerlink" title="VIM编译(Ubuntu)"></a>VIM编译(Ubuntu)</h2><hr>
<p>VIM可以从GitHub上下载最新源码进行编译,编译过程类似于这样的:</p>
<ol>
<li><p>下载最新的VIM源码:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/vim/</span>vim.git</span><br></pre></td></tr></table></figure></li>
<li><p>清除VIM源码之前的编译结果:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">make</span> clean</span><br><span class="line">sudo <span class="built_in">make</span> disclean</span><br></pre></td></tr></table></figure></li>
<li><p>配置编译选项:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">.<span class="regexp">/configure --with-feature=huge --enable-rubyinterp --enable-pythoninterp --enable-python3interp --enable-perlinterp --enable-multibyte --enable-cscope --with-python-config-dir=/u</span>sr<span class="regexp">/lib/</span>python2.<span class="number">7</span><span class="regexp">/config-x86_64-linux-gnu/</span> --with-python-config-dir=<span class="regexp">/usr/</span>lib<span class="regexp">/python3.5/</span>config-<span class="number">3.5</span>m-x86_64-linux-gnu<span class="regexp">/ --prefix=/u</span>sr<span class="regexp">/local/</span>vim</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--with-feature=huge</code>: 支持最大特性<br><code>--enable-rubyinterp</code>: 打开对ruby编写插件的支持<br><code>--enable-pythoninterp</code>:打开对python编写插件的支持<br><code>--enable-python3interp</code> :打开对python3编写插件的支持<br><code>--enable-perlinterp</code> :打开对perl编写插件的支持<br><code>--enable-multibyte</code> :打开多字节支持,可以在VIM中支持中文<br><code>--enable-cscope</code> :打开对CSCOPE的支持<br><code>--with-python-config-dir=/usr/lib/python2.7/config-x86_64-linux-gnu/</code> : 指定python路径<br><code>--with-python-config-dir=/usr/lib/python3.5/config-3.5m-x86_64-linux-gnu/</code> :指定python3的路径<br><code>--prefix=/usr/local/vim</code> : 自定义VIM安装路径</p>
</blockquote>
</li>
<li><p>编译安装VIM:</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure></li>
<li><p>若安装出现问题需要安装以下依赖:</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install python-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install python3-<span class="built_in">dev</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install libncurses5-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></li>
<li><p>至此,VIM已经安装到<code>--prefix</code>指定的<code>/usr/local/vim</code>路径了,可以通过<code>vim --version</code> 查看VIM的相关信息,还可以通过以下命令增加软连接来自启动新编译的VIM:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>bin<span class="regexp">/vim /u</span>sr<span class="regexp">/local/</span>vim</span><br></pre></td></tr></table></figure></li>
<li><p>VIM卸载方法:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="built_in">remove</span> --purge vim(--purge是完全删除,连同配置文件)</span><br><span class="line">sudo apt-<span class="built_in">get</span> clean</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="VIM配置及插件"><a href="#VIM配置及插件" class="headerlink" title="VIM配置及插件"></a>VIM配置及插件</h2><hr>
<h3 id="VIM配置"><a href="#VIM配置" class="headerlink" title="VIM配置"></a>VIM配置</h3><hr>
<p>本人的VIM配置如下:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nocompatible                         <span class="string">&quot; Set no compatible with vi (older version) so we can use extend function of</span></span><br><span class="line"><span class="string">set showcmd		                 &quot;</span> Show (partial) command <span class="keyword">in</span> status line.</span><br><span class="line"><span class="built_in">set</span> showmatch		                 <span class="string">&quot; Show matching brackets.</span></span><br><span class="line"><span class="string">set ignorecase		                 &quot;</span> <span class="keyword">Do</span> case insensitive matching</span><br><span class="line"><span class="built_in">set</span> smartcase		                 <span class="string">&quot; Do smart case matching</span></span><br><span class="line"><span class="string">set incsearch		                 &quot;</span> Incremental search</span><br><span class="line"><span class="built_in">set</span> hlsearch 		                 <span class="string">&quot; High light  search</span></span><br><span class="line"><span class="string">set autowrite		                 &quot;</span> Automatically save before commands like :next <span class="keyword">and</span> :make</span><br><span class="line"><span class="built_in">set</span> hidden		                 <span class="string">&quot; Hide buffers when they are abandoned</span></span><br><span class="line"><span class="string">set number 		                         &quot;</span> Display nunmber lines</span><br><span class="line"><span class="built_in">set</span> relativenumber 		                 <span class="string">&quot; Display  relative nunmber lines</span></span><br><span class="line"><span class="string">set foldenable                           &quot;</span> <span class="built_in">Enable</span> auto fold</span><br><span class="line"><span class="built_in">set</span> <span class="attribute">foldmethod</span>=indent                    <span class="string">&quot; Set fold method</span></span><br><span class="line"><span class="string">set foldlevel=99                         &quot;</span> <span class="built_in">Set</span> fold level</span><br><span class="line"><span class="built_in">set</span> autowrite                            <span class="string">&quot; Set auto save </span></span><br><span class="line"><span class="string">set cursorline                           &quot;</span> Dipslay the current line boldly</span><br><span class="line"><span class="string">&quot;hi CursorLine cterm=NONE ctermbg=gray ctermfg=darkred gui=bold&quot;</span> cursor line highlight color </span><br><span class="line">hi CursorLine <span class="attribute">cterm</span>=NONE <span class="attribute">ctermbg</span>=darkred <span class="attribute">ctermfg</span>=white <span class="attribute">gui</span>=bold&quot; cursor line highlight color </span><br><span class="line">hi CursorColumn <span class="attribute">cterm</span>=NONE <span class="attribute">ctermbg</span>=darkred <span class="attribute">ctermfg</span>=red <span class="string">&quot; cursor column line highlight color </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set confirm                              &quot;</span> Pop up confirm msg when processing unsaved files <span class="keyword">and</span> read-only files</span><br><span class="line"><span class="built_in">set</span> autoindent                           <span class="string">&quot; Set auto indent , when copying block text from outside to vim, this shoud be close in case indent problem</span></span><br><span class="line"><span class="string">set smartindent                          &quot;</span> <span class="built_in">Set</span> c-stlyel auto indent, when copying block text <span class="keyword">from</span> outside <span class="keyword">to</span> vim, this shoud be close <span class="keyword">in</span> case indent problem</span><br><span class="line"><span class="built_in">set</span> cindent                              <span class="string">&quot; Set auto indent, when copying block text from outside to vim, this shoud be close in case indent problem</span></span><br><span class="line"><span class="string">set noexpandtab                          &quot;</span> <span class="built_in">Set</span> <span class="literal">no</span> tab replaced by space</span><br><span class="line"><span class="built_in">set</span> smarttab                             <span class="string">&quot; Using tab at beginning of a row and paragraph</span></span><br><span class="line"><span class="string">set showmatch                            &quot;</span> Hightlight display matched brackets</span><br><span class="line"><span class="built_in">set</span> ruler                                <span class="string">&quot; Display cursor&#x27;s line number in staus bar</span></span><br><span class="line"><span class="string">set nobackup                             &quot;</span> <span class="keyword">Not</span> back up file when overlapping files  </span><br><span class="line"><span class="built_in">set</span> noswapfile                             <span class="string">&quot; Not swap file when overlapping files  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>++++++++++++++++++++ <span class="built_in">set</span> value config++++++++++++++++++++</span><br><span class="line"><span class="built_in">set</span> <span class="attribute">mouse</span>=a                              <span class="string">&quot; Enable mouse all</span></span><br><span class="line"><span class="string">set clipboard=unnamedplus                &quot;</span> Sync<span class="built_in"> System </span>clipboard with Vim, <span class="string">&#x27;vim --version \| grep clipboard&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;sudo apt install vim-gtk&#x27;</span></span><br><span class="line"><span class="built_in">set</span> <span class="attribute">guifont</span>=Courier_New:h10:cANSI        <span class="string">&quot; Set font </span></span><br><span class="line"><span class="string">set cmdheight=1                          &quot;</span> <span class="built_in">Set</span> cmd height </span><br><span class="line"><span class="built_in">set</span> <span class="attribute">termencoding</span>=utf-8                   <span class="string">&quot; Set terminate like console encoding </span></span><br><span class="line"><span class="string">set encoding=utf-8                       &quot;</span> <span class="built_in">Set</span> vim inner like buffer,msg txt, menu txt  encoding </span><br><span class="line"><span class="built_in">set</span> <span class="attribute">fileencodings</span>=utf-8,cp936,ucs-bom    <span class="string">&quot; Set file content encoding list and when opening a file, it will open according to the detected encoding sequence</span></span><br><span class="line"><span class="string">set fileencoding=utf-8                   &quot;</span> <span class="built_in">Set</span> the current file content encoding when saving a file </span><br><span class="line"><span class="built_in">set</span> expandtab                            <span class="string">&quot; Set Tab expand to space</span></span><br><span class="line"><span class="string">set tabstop=4                            &quot;</span> <span class="built_in">Set</span> tab widths = 4</span><br><span class="line"><span class="built_in">set</span> <span class="attribute">softtabstop</span>=4                        <span class="string">&quot; Set tab indent widths  = 4</span></span><br><span class="line"><span class="string">set shiftwidth=4                         &quot;</span> <span class="built_in">Set</span> swap row tab indent widths  = 4</span><br></pre></td></tr></table></figure>

<h3 id="VIM插件"><a href="#VIM插件" class="headerlink" title="VIM插件"></a>VIM插件</h3><hr>
<p>VIM可供选择的插件很多,本人常用的插件有:</p>
<ol>
<li><p>NerdTree<br>功能：文件导航,主要功能包括:<br>a)： 树状显示某个工程下文件,并支持文件打开,搜索,增删改查等基本操作<br>b)： 支持设置BookMark<br>c)： 支持文件预览和垂直及水平多屏方式打开<br>d)： 支持变更文件工程当前工作目录<br>帮助:<br>在NerdTree窗口输入<code>?</code> 或者输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> nerdtree</span><br></pre></td></tr></table></figure>
</li>
<li><p>Tagbar<br>功能：C&#x2F;C++文件内容分类和快速定位<br>a)： 支持文件namespace,functin,variant等类型分类及快速定位<br>帮助:<br>在Tagbar窗口输入<code>?</code> 或者输入:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> tagbar</span><br></pre></td></tr></table></figure>
</li>
<li><p>CtrlP<br>功能：文件快速搜索<br>a)： 支持文件在指定工程目录下快速搜索<br>b)： 支持文件在最近最常使用的文件集合中搜索<br>c)： 支持文件在Buffer文件集合中搜索<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> ctrlp</span><br></pre></td></tr></table></figure>
</li>
<li><p>a.vim<br>功能：C&#x2F;C++文件头文件和源文件切换<br>a)： 支持头文件和源文件在不同窗口模式(水平,垂直)中进行切换<br>帮助:</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`:A` switches to the header file corresponding to the current file being edited (<span class="literal">or</span> vise versa)</span><br><span class="line">`:AS` splits <span class="literal">and</span> switches</span><br><span class="line">`:AV` vertical splits <span class="literal">and</span> switches</span><br><span class="line">`:AT` <span class="keyword">new</span> tab <span class="literal">and</span> switches</span><br><span class="line">`:AN` cycles through matches</span><br><span class="line">`:IH` switches to file under cursor</span><br><span class="line">`:IHS` splits <span class="literal">and</span> switches</span><br><span class="line">`:IHV` vertical splits <span class="literal">and</span> switches</span><br><span class="line">`:IHT` <span class="keyword">new</span> tab <span class="literal">and</span> switches</span><br><span class="line">`:IHN` cycles through matches</span><br><span class="line">`&lt;Leader&gt;ih` switches to file under cursor</span><br><span class="line">`&lt;Leader&gt;is` switches to the alternate file of file under cursor (e.g. on  &lt;foo.h&gt; switches to foo.cpp)</span><br><span class="line">`&lt;Leader&gt;ihn` cycles through matches</span><br></pre></td></tr></table></figure>
</li>
<li><p>NerdCommenter<br>功能：快速注释<br>a)： 支持不同形式(行注释、块注释)的快速注释和反注释<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> nerdcommenter</span><br></pre></td></tr></table></figure>
</li>
<li><p>Syntastic<br>功能：静态语法错误检查<br>a)： 支持静态语法检查并提示出错行和出错信息<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> syntasitc</span><br></pre></td></tr></table></figure>
</li>
<li><p>vim-surround<br>功能：快速<code>]</code>,<code>&#125;</code>,<code>(</code>,<code>&#39;</code>,<code>&quot;</code>,<code>&lt;</code>等封闭符号编辑<br>a)： 支持快速<code>]</code>,<code>&#125;</code>,<code>(</code>,<code>&#39;</code>,<code>&quot;</code>,<code>&lt;</code>等封闭符号增删修改<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> surround</span><br></pre></td></tr></table></figure>
</li>
<li><p>vim-airline<br>功能：状态栏显示<br>a)： 支持状态栏各种编辑状态显示<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> airline</span><br></pre></td></tr></table></figure>
</li>
<li><p>solarized<br>功能：配色<br>a) 支持<code>dark</code>和<code>light</code>两种配色</p>
</li>
<li><p>vim-fugitive<br>功能：vim git管理插件<br>a) 支持vim git快速方便管理<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> fugitive</span><br></pre></td></tr></table></figure>
</li>
<li><p>YouCompleteMe<br>功能：vim 自动补全功能<br>a) 支持vim像IDE一样自动补全,不过安装很复杂,需要<code>llvm+clang</code>编译和VIM的<code>python</code>支持<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> youcompleteme</span><br></pre></td></tr></table></figure>
</li>
<li><p>vim-markdown<br>功能：vim markdown语法高亮<br>a) 支持vim中markdown编辑语法高亮<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> markdown</span><br></pre></td></tr></table></figure>
</li>
<li><p>markdown-preview.nvim<br>功能：vim markdown预览<br>a) 支持vim中markdown预览<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> markdown-preview</span><br></pre></td></tr></table></figure>
</li>
<li><p>fzf<br>功能：vim模糊查找功能<br>a) 支持vim中文本模糊查找<br>b) 支持vim文件名模糊查找<br>c) 支持vim最近使用文件模糊查找<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> fzf</span><br></pre></td></tr></table></figure>
</li>
<li><p>indentLine<br>功能：vim缩进可视化<br>a) 支持vim缩进显示<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> indentLine</span><br></pre></td></tr></table></figure>
</li>
<li><p>vim-snippets<br>功能：vim代码Snippet<br>a) 支持vim代码Snippet<br>帮助:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">help</span> snippets</span><br></pre></td></tr></table></figure>
</li>
<li><p>Vundle<br>功能：vim 插件包管理插件<br>a) 通过git方式来管理VIM插件包,支持通过github或VIM插件中在线自动更新插件和本地文件插件更新<br>帮助:</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="string">`:PluginList`</span>       - lists configured plugins</span><br><span class="line"><span class="string">`:PluginInstall`</span>    - installs plugins; append <span class="string">`!`</span> <span class="keyword">to</span> update <span class="literal">or</span> just</span><br><span class="line"><span class="string">`:PluginUpdate`</span>     - update plugins;</span><br><span class="line"><span class="string">`:PluginSearch`</span> foo - searches for foo; append <span class="string">`!`</span> <span class="keyword">to</span> refresh <span class="built_in">local</span> <span class="keyword">cache</span></span><br><span class="line"><span class="string">`:PluginClean`</span>      - confirms removal of unused plugins; append <span class="string">`!`</span> <span class="keyword">to</span> auto<span class="params">-approve</span> removal</span><br></pre></td></tr></table></figure></li>
</ol>
<p>VIM中插件配置如下:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot;++++++++++++++++++++ plugin in config++++++++++++++++++++ </span></span><br><span class="line"><span class="keyword">filetype</span> off                  <span class="comment">&quot; required</span></span><br><span class="line"><span class="keyword">set</span> rtp+=$HOME/.<span class="keyword">vim</span>/bundle/Vundle.<span class="keyword">vim</span>     <span class="comment">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="keyword">call</span> vundle#begin()</span><br><span class="line"><span class="comment">&quot; alternatively, pass a path where Vundle should install plugins</span></span><br><span class="line"><span class="comment">&quot; call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; let Vundle manage Vundle, required</span></span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;********** How to add different plugin **********  </span></span><br><span class="line"><span class="comment">&quot; The following are examples of different formats supported.</span></span><br><span class="line"><span class="comment">&quot; Keep Plugin commands between vundle#begin/end.</span></span><br><span class="line"><span class="comment">&quot; plugin on GitHub repo</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-scripts/a.vim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;preservim/nerdcommenter&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;altercation/solarized&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;preservim/tagbar&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;godlygeek/tabular&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;preservim/vim-markdown&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;iamcco/markdown-preview.nvim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;tpope/vim-surround&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;tpope/vim-fugitive&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf&#x27;</span>, &#123;<span class="string">&#x27;do&#x27;</span>: &#123;-&gt; fzf#install()&#125;&#125;</span><br><span class="line">Plugin <span class="string">&#x27;junegunn/fzf.vim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;dense-analysis/ale&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;rust-lang/rust.vim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;ycm-core/YouCompleteMe&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;tmhedberg/SimpylFold&#x27;</span> <span class="comment">&quot; Fold plugin for python</span></span><br><span class="line">Plugin <span class="string">&#x27;nvie/vim-flake8&#x27;</span>      <span class="comment">&quot; Syntax checking for python</span></span><br><span class="line">Plugin <span class="string">&#x27;Yggdroot/indentLine&#x27;</span>  <span class="comment">&quot; Display thin vertical lines at each indentation</span></span><br><span class="line">Plugin <span class="string">&#x27;SirVer/ultisnips&#x27;</span>     <span class="comment">&quot; Track the engine.</span></span><br><span class="line">Plugin <span class="string">&#x27;honza/vim-snippets&#x27;</span>   <span class="comment">&quot; Snippets are separated from the engine. Add this if you want them:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; plugin from http://vim-scripts.org/vim/scripts.html</span></span><br><span class="line"><span class="comment">&quot; Plugin &#x27;L9&#x27;</span></span><br><span class="line"><span class="comment">&quot; </span></span><br><span class="line"><span class="comment">&quot; Git plugin not hosted on GitHub</span></span><br><span class="line"><span class="comment">&quot; Plugin &#x27;git://git.wincent.com/command-t.git&#x27;</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; git repos on your local machine (i.e. when working on your own plugin)</span></span><br><span class="line"><span class="comment">&quot; Plugin &#x27;file:///home/gmarik/path/to/plugin&#x27;</span></span><br><span class="line"><span class="comment">&quot; The sparkup vim script is in a subdirectory of this repo called vim.</span></span><br><span class="line"><span class="comment">&quot; Pass the path to set the runtimepath properly.</span></span><br><span class="line"><span class="comment">&quot; Plugin &#x27;rstacruz/sparkup&#x27;, &#123;&#x27;rtp&#x27;: &#x27;vim/&#x27;&#125;</span></span><br><span class="line"><span class="comment">&quot; Install L9 and avoid a Naming conflict if you&#x27;ve already installed a</span></span><br><span class="line"><span class="comment">&quot; different version somewhere else.</span></span><br><span class="line"><span class="comment">&quot; Plugin &#x27;ascenator/L9&#x27;, &#123;&#x27;name&#x27;: &#x27;newL9&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; All of your Plugins must be added before the following line</span></span><br><span class="line"><span class="keyword">call</span> vundle#end()            <span class="comment">&quot; required</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span>    <span class="comment">&quot; required</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; To ignore plugin indent changes, instead use:</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="keyword">on</span> <span class="comment">&quot; load file type plugin </span></span><br><span class="line"><span class="keyword">filetype</span> <span class="keyword">on</span>        <span class="comment">&quot; file type detect on</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ nerdtree config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot; :help nerdtree OR ? </span></span><br><span class="line"><span class="keyword">autocmd</span> vimenter * NERDTree <span class="comment">&quot; open NERDTree when vim start up</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeIgnore=[<span class="string">&#x27;\.pyc$&#x27;</span>, <span class="string">&#x27;\~$&#x27;</span>, <span class="string">&#x27;\.so$&#x27;</span>, <span class="string">&#x27;\.dll$&#x27;</span>, <span class="string">&#x27;\.vim$&#x27;</span>, <span class="string">&#x27;\.swp$&#x27;</span>] <span class="comment">&quot;ignore files in NERDTree</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;C-n&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span>   </span><br><span class="line"><span class="comment">&quot; ctrl-n to toggle NERDTree</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ nerdcommenter config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot; :help nerdcommenter AND :help &lt;LEADER&gt; to see the leader is &#x27;\&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span> = <span class="number">1</span>   <span class="comment">&quot; add space after comment delimiters by default</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDDefaultAlign</span> = <span class="string">&#x27;left&#x27;</span>  <span class="comment">&quot; align line-wise comment delimiters flush left</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDAltDelims_java</span> = <span class="number">1</span> <span class="comment">&quot; use the alternative delimiters for a specific filetype by default </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCommentEmptyLines</span> = <span class="number">1</span> <span class="comment">&quot; If this option is turned on, then empty lines will be commented as well. Useful when commenting regions of code</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ tagbar config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot; :help tagbar OR ?</span></span><br><span class="line"><span class="string">&quot; autocmd VimEnter * nested :TagbarOpen &quot;</span> <span class="keyword">open</span> tagbar when <span class="keyword">vim</span> start <span class="keyword">up</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;C-t&gt;</span> :TagbarToggle<span class="symbol">&lt;CR&gt;</span>   </span><br><span class="line"><span class="comment">&quot; ctrl-t to toggle tagbar</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:tagbar_autofocus</span> = <span class="number">1</span> <span class="comment">&quot; If you set this option the cursor will move to the Tagbar window when it is</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:rust_use_custom_ctags_defs</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;let g:tagbar_type_rust = &#123;</span></span><br><span class="line"><span class="comment">&quot;  \ &#x27;ctagstype&#x27; : &#x27;rust&#x27;,</span></span><br><span class="line"><span class="comment">&quot; &#x27;ctagsbin&#x27; : &#x27;/path/to/your/universal/ctags&#x27;,</span></span><br><span class="line"><span class="comment">&quot;  \ &#x27;kinds&#x27; : [</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;n:modules&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;s:structures:1&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;i:interfaces&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;c:implementations&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;f:functions:1&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;g:enumerations:1&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;t:type aliases:1:0&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;v:constants:1:0&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;M:macros:1&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;m:fields:1:0&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;e:enum variants:1:0&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;P:methods:1&#x27;,</span></span><br><span class="line"><span class="comment">&quot;  \ ],</span></span><br><span class="line"><span class="comment">&quot;  \ &#x27;sro&#x27;: &#x27;::&#x27;,</span></span><br><span class="line"><span class="comment">&quot;  \ &#x27;kind2scope&#x27; : &#123;</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;n&#x27;: &#x27;module&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;s&#x27;: &#x27;struct&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;i&#x27;: &#x27;interface&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;c&#x27;: &#x27;implementation&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;f&#x27;: &#x27;function&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;g&#x27;: &#x27;enum&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;t&#x27;: &#x27;typedef&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;v&#x27;: &#x27;variable&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;M&#x27;: &#x27;macro&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;m&#x27;: &#x27;field&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;e&#x27;: &#x27;enumerator&#x27;,</span></span><br><span class="line"><span class="comment">&quot;      \ &#x27;P&#x27;: &#x27;method&#x27;,</span></span><br><span class="line"><span class="comment">&quot;  \ &#125;,</span></span><br><span class="line"><span class="comment">&quot;\ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ airline config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;C-a&gt;</span> :AirlineToggle<span class="symbol">&lt;CR&gt;</span>   </span><br><span class="line"><span class="comment">&quot; ctrl-a to toggle airline</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#tabline#enabled = <span class="number">1</span> <span class="comment">&quot; enable enhanced tabline </span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#tabline#show_buffers = <span class="number">1</span> <span class="comment">&quot; enable displaying buffers with a single tab. (c)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ solarized config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> t_Co=<span class="number">256</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;gui_running&#x27;</span>)</span><br><span class="line">	<span class="keyword">set</span> background=dark                      <span class="string">&quot; Set background color&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">set</span> background=dark</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; COMMENT THIS WHEN SSH CONNECTION</span></span><br><span class="line"><span class="keyword">colorscheme</span> solarized </span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ cscope config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&quot;cscope&quot;</span>)</span><br><span class="line">	<span class="keyword">set</span> csprg=/usr/bin/<span class="keyword">cscope</span></span><br><span class="line">	<span class="keyword">set</span> csto=<span class="number">0</span></span><br><span class="line">	<span class="keyword">set</span> <span class="keyword">cst</span></span><br><span class="line">	<span class="keyword">set</span> nocsverb</span><br><span class="line">	<span class="comment">&quot; add any database in current directory</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="string">&quot;cscope.out&quot;</span>)</span><br><span class="line">		<span class="keyword">cs</span> <span class="built_in">add</span> <span class="keyword">cscope</span>.out</span><br><span class="line">		<span class="comment">&quot; else add database pointed to by environment</span></span><br><span class="line">	<span class="keyword">elseif</span> $CSCOPE_DB != <span class="string">&quot;&quot;</span></span><br><span class="line">		<span class="keyword">cs</span> <span class="built_in">add</span> $CSCOPE_DB</span><br><span class="line">	<span class="keyword">endif</span></span><br><span class="line">	<span class="keyword">set</span> csverb</span><br><span class="line">    <span class="keyword">set</span> cscopequickfix=s-,<span class="keyword">c</span>-,d-,i-,t-,<span class="keyword">e</span>-</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Using &#x27;CTRL-@&#x27; then a search type makes the vim window</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;s :<span class="keyword">cs</span> <span class="keyword">find</span> s <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;g :<span class="keyword">cs</span> <span class="keyword">find</span> g <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;<span class="keyword">c</span> :<span class="keyword">cs</span> <span class="keyword">find</span> <span class="keyword">c</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;t :<span class="keyword">cs</span> <span class="keyword">find</span> t <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;<span class="keyword">e</span> :<span class="keyword">cs</span> <span class="keyword">find</span> <span class="keyword">e</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;<span class="keyword">f</span> :<span class="keyword">cs</span> <span class="keyword">find</span> <span class="keyword">f</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cfile&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;i :<span class="keyword">cs</span> <span class="keyword">find</span> i ^<span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cfile&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span>$<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> &lt;C-@&gt;d :<span class="keyword">cs</span> <span class="keyword">find</span> d <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Using &#x27;CTRL-spacebar&#x27; then a search type makes the vim window</span></span><br><span class="line"><span class="comment">&quot; split horizontally, with search result displayed in</span></span><br><span class="line"><span class="comment">&quot; the new window.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span>s :<span class="keyword">scs</span> <span class="keyword">find</span> s <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span>g :<span class="keyword">scs</span> <span class="keyword">find</span> g <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="keyword">c</span> :<span class="keyword">scs</span> <span class="keyword">find</span> <span class="keyword">c</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span>t :<span class="keyword">scs</span> <span class="keyword">find</span> t <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="keyword">e</span> :<span class="keyword">scs</span> <span class="keyword">find</span> <span class="keyword">e</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="keyword">f</span> :<span class="keyword">scs</span> <span class="keyword">find</span> <span class="keyword">f</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cfile&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span>i :<span class="keyword">scs</span> <span class="keyword">find</span> i ^<span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cfile&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span>$<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span>d :<span class="keyword">scs</span> <span class="keyword">find</span> d <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Hitting CTRL-space *twice* before the search type does a vertical</span></span><br><span class="line"><span class="comment">&quot; split instead of a horizontal one</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span>s</span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> s <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span>g</span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> g <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span><span class="keyword">c</span></span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> <span class="keyword">c</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span>t</span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> t <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span><span class="keyword">e</span></span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> <span class="keyword">e</span> <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span>i</span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> i ^<span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cfile&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span>$<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-Space&gt;</span><span class="symbol">&lt;C-Space&gt;</span>d</span><br><span class="line">	\:<span class="keyword">vert</span> <span class="keyword">scs</span> <span class="keyword">find</span> d <span class="symbol">&lt;C-R&gt;</span>=<span class="built_in">expand</span>(<span class="string">&quot;&lt;cword&gt;&quot;</span>)<span class="symbol">&lt;CR&gt;</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ markdown config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_folding_disabled</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_override_foldtext</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_folding_level</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_no_default_key_mappings</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_toc_autofit</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_conceal</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_conceal_code_blocks</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++  markdown preview  config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot; set to 1, nvim will open the preview window after entering the markdown buffer</span></span><br><span class="line"><span class="comment">&quot; default: 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_auto_start</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set to 1, the nvim will auto close current preview window when change</span></span><br><span class="line"><span class="comment">&quot; from markdown buffer to another buffer</span></span><br><span class="line"><span class="comment">&quot; default: 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_auto_close</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set to 1, the vim will refresh markdown when save the buffer or</span></span><br><span class="line"><span class="comment">&quot; leave from insert mode, default 0 is auto refresh markdown as you edit or</span></span><br><span class="line"><span class="comment">&quot; move the cursor</span></span><br><span class="line"><span class="comment">&quot; default: 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_refresh_slow</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set to 1, the MarkdownPreview command can be use for all files,</span></span><br><span class="line"><span class="comment">&quot; by default it can be use in markdown file</span></span><br><span class="line"><span class="comment">&quot; default: 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_command_for_global</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set to 1, preview server available to others in your network</span></span><br><span class="line"><span class="comment">&quot; by default, the server listens on localhost (127.0.0.1)</span></span><br><span class="line"><span class="comment">&quot; default: 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_open_to_the_world</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; use custom IP to open preview page</span></span><br><span class="line"><span class="comment">&quot; useful when you work in remote vim and preview on local browser</span></span><br><span class="line"><span class="comment">&quot; more detail see: https://github.com/iamcco/markdown-preview.nvim/pull/9</span></span><br><span class="line"><span class="comment">&quot; default empty</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_open_ip</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; specify browser to open preview page</span></span><br><span class="line"><span class="comment">&quot; for path with space</span></span><br><span class="line"><span class="comment">&quot; valid: `/path/with\ space/xxx`</span></span><br><span class="line"><span class="comment">&quot; invalid: `/path/with\\ space/xxx`</span></span><br><span class="line"><span class="comment">&quot; default: &#x27;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_browser</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set to 1, echo preview page url in command line when open preview page</span></span><br><span class="line"><span class="comment">&quot; default is 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_echo_preview_url</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; a custom vim function name to open preview page</span></span><br><span class="line"><span class="comment">&quot; this function will receive url as param</span></span><br><span class="line"><span class="comment">&quot; default is empty</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_browserfunc</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; options for markdown render</span></span><br><span class="line"><span class="comment">&quot; mkit: markdown-it options for render</span></span><br><span class="line"><span class="comment">&quot; katex: katex options for math</span></span><br><span class="line"><span class="comment">&quot; uml: markdown-it-plantuml options</span></span><br><span class="line"><span class="comment">&quot; maid: mermaid options</span></span><br><span class="line"><span class="comment">&quot; disable_sync_scroll: if disable sync scroll, default 0</span></span><br><span class="line"><span class="comment">&quot; sync_scroll_type: &#x27;middle&#x27;, &#x27;top&#x27; or &#x27;relative&#x27;, default value is &#x27;middle&#x27;</span></span><br><span class="line"><span class="comment">&quot;   middle: mean the cursor position alway show at the middle of the preview page</span></span><br><span class="line"><span class="comment">&quot;   top: mean the vim top viewport alway show at the top of the preview page</span></span><br><span class="line"><span class="comment">&quot;   relative: mean the cursor position alway show at the relative positon of the preview page</span></span><br><span class="line"><span class="comment">&quot; hide_yaml_meta: if hide yaml metadata, default is 1</span></span><br><span class="line"><span class="comment">&quot; sequence_diagrams: js-sequence-diagrams options</span></span><br><span class="line"><span class="comment">&quot; content_editable: if enable content editable for preview page, default: v:false</span></span><br><span class="line"><span class="comment">&quot; disable_filename: if disable filename header for preview page, default: 0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_preview_options</span> = &#123;</span><br><span class="line">    \ <span class="string">&#x27;mkit&#x27;</span>: &#123;&#125;,</span><br><span class="line">    \ <span class="string">&#x27;katex&#x27;</span>: &#123;&#125;,</span><br><span class="line">    \ <span class="string">&#x27;uml&#x27;</span>: &#123;&#125;,</span><br><span class="line">    \ <span class="string">&#x27;maid&#x27;</span>: &#123;&#125;,</span><br><span class="line">    \ <span class="string">&#x27;disable_sync_scroll&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    \ <span class="string">&#x27;sync_scroll_type&#x27;</span>: <span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">    \ <span class="string">&#x27;hide_yaml_meta&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    \ <span class="string">&#x27;sequence_diagrams&#x27;</span>: &#123;&#125;,</span><br><span class="line">    \ <span class="string">&#x27;flowchart_diagrams&#x27;</span>: &#123;&#125;,</span><br><span class="line">    \ <span class="string">&#x27;content_editable&#x27;</span>: <span class="variable">v:false</span>,</span><br><span class="line">    \ <span class="string">&#x27;disable_filename&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    \ <span class="string">&#x27;toc&#x27;</span>: &#123;&#125;</span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; use a custom markdown style must be absolute path</span></span><br><span class="line"><span class="comment">&quot; like &#x27;/Users/username/markdown.css&#x27; or expand(&#x27;~/markdown.css&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_markdown_css</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; use a custom highlight style must absolute path</span></span><br><span class="line"><span class="comment">&quot; like &#x27;/Users/username/highlight.css&#x27; or expand(&#x27;~/highlight.css&#x27;)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_highlight_css</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; use a custom port to start server or empty for random</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_port</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; preview page title</span></span><br><span class="line"><span class="comment">&quot; $&#123;name&#125; will be replace with the file name</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_page_title</span> = <span class="string">&#x27;「$&#123;name&#125;」&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; recognized filetypes</span></span><br><span class="line"><span class="comment">&quot; these filetypes will have MarkdownPreview... commands</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_filetypes</span> = [<span class="string">&#x27;markdown&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set default theme (dark or light)</span></span><br><span class="line"><span class="comment">&quot; By default the theme is define according to the preferences of the system</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:mkdp_theme</span> = <span class="string">&#x27;dark&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ rust.vim config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot; let g:rustfmt_autosave = 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ YCM For Rust config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot;install ycm step: </span></span><br><span class="line"><span class="string">&quot; 1. add Plugin &quot;</span>ycm-core/YouCompleteMe<span class="comment">&quot; and PluginInstall/Update</span></span><br><span class="line"><span class="comment">&quot; 2. cd ~</span></span><br><span class="line"><span class="comment">&quot;    sudo apt install build-essential cmake python3-dev libclang1</span></span><br><span class="line"><span class="comment">&quot;    sudo apt install libclang-dev -y</span></span><br><span class="line"><span class="comment">&quot; 3. clangd --version </span></span><br><span class="line"><span class="comment">&quot;    sudo apt-get install clangd-12(XXVERSION)</span></span><br><span class="line"><span class="comment">&quot;    sudo update-alternatives --install /usr/bin/clangd clangd /usr/bin/clangd-12 100</span></span><br><span class="line"><span class="comment">&quot; 4. cd ~/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="comment">&quot;    sudo apt-get install python-dev python3-dev</span></span><br><span class="line"><span class="comment">&quot; 5. cd ~ </span></span><br><span class="line"><span class="comment">&quot;    mkdir ycm_build</span></span><br><span class="line"><span class="comment">&quot;    cd ycm_build</span></span><br><span class="line"><span class="string">&quot;    cmake -G &quot;</span>Unix Makefiles<span class="comment">&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</span></span><br><span class="line"><span class="comment">&quot;    cmake --build . --target ycm_core --config Release</span></span><br><span class="line"><span class="comment">&quot; 6: cd ~</span></span><br><span class="line"><span class="comment">&quot;    sudo apt-get install python-setuptools</span></span><br><span class="line"><span class="comment">&quot;    cd ~/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="comment">&quot;    git submodule update --init --recursive (if .vim/bundle/YouCompleteMe/third_party/ycmd/third_party is empty </span></span><br><span class="line"><span class="comment">&quot;    or watchdog directory is empty, MAY reExecute more than 1 time)</span></span><br><span class="line"><span class="comment">&quot;    cd   ~/.vim/bundle/YouCompleteMe/third_party/ycmd/third_party/watchdog_deps/watchdog</span></span><br><span class="line"><span class="comment">&quot;    sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span></span><br><span class="line"><span class="comment">&quot;    sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2</span></span><br><span class="line"><span class="comment">&quot;    update-alternatives --config python(pick python3)</span></span><br><span class="line"><span class="comment">&quot;    python setup.py build --build-base=build/3 --build-lib=build/lib3</span></span><br><span class="line"><span class="comment">&quot; 7. cd ~</span></span><br><span class="line"><span class="comment">&quot;    sudo npm install -g --prefix third_party/tsserver typescript</span></span><br><span class="line"><span class="comment">&quot; 8. rustup update</span></span><br><span class="line"><span class="comment">&quot;    rustup toolchain install nightly</span></span><br><span class="line"><span class="comment">&quot;    rustup default nightly</span></span><br><span class="line"><span class="comment">&quot;    rustup component add rls</span></span><br><span class="line"><span class="comment">&quot;    rustup component add rust-src</span></span><br><span class="line"><span class="comment">&quot;    rustup component add rust-analysis</span></span><br><span class="line"><span class="comment">&quot; 9. cd ~/.vim/bundle/YouCompleteMe</span></span><br><span class="line"><span class="comment">&quot;    python3 ./install.py --clangd-completer --rust-completer --ts-completer</span></span><br><span class="line"><span class="comment">&quot; 10. config .vim.rc about ycm as below</span></span><br><span class="line"><span class="comment">&quot; clangd config</span></span><br><span class="line"><span class="comment">&quot; Let clangd fully control code completion</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_clangd_uses_ycmd_caching</span> = <span class="number">0</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_clangd_binary_path</span> = <span class="string">&quot;/usr/bin/clangd&quot;</span></span><br><span class="line"> <span class="comment">&quot; ycm config</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_semantic_triggers</span>=&#123;<span class="string">&#x27;c,cpp,python,rust,go,cs,javascript,typescript&#x27;</span>:[<span class="string">&#x27;re!\w&#123;2&#125;&#x27;</span>]&#125;</span><br><span class="line"> <span class="comment">&quot; rust toolchain check command: rustc --print sysroot</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_rust_src_path</span>=<span class="string">&#x27;$HOME/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src&#x27;</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span> = <span class="number">1</span></span><br><span class="line"> <span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_tags_files</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; let g:ycm_goto_buffer_command=&#x27;horizontal-split&#x27;</span></span><br><span class="line"><span class="comment">&quot; let g:ycm_global_ycm_extra_conf=&#x27;~/.vim/ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="keyword">set</span> completeopt=<span class="keyword">menu</span>,menuone <span class="comment">&quot; disable the function defininition preview window</span></span><br><span class="line"><span class="keyword">set</span> completeopt-=preview <span class="comment">&quot; disable windows to show up preview</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_add_preview_to_completeopt</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_autoclose_preview_window_after_completion</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_autoclose_preview_window_after_insertion</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_invoke_completion</span>=<span class="string">&#x27;&lt;C-x&gt;&#x27;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F12&gt;</span> : YcmCompleter GoToDefinitionElseDeclaration<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot; YCM Debug command:  YcmDebugInfo;  YcmRestartServer</span></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ make config++++++++++++++++++++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; %: current complete file name including suffix file type</span></span><br><span class="line"><span class="comment">&quot; %&lt;: current file name not including suffix file type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; c/c++/shell/python file compile and run</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F5&gt;</span> :<span class="keyword">call</span> CompileAndRun() <span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! CompileAndRun()</span><br><span class="line">    exec <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> ==<span class="string">&#x27;c&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;!gcc % -o %&lt;&quot;</span></span><br><span class="line">        exec <span class="string">&quot;slicent !clear&quot;</span></span><br><span class="line">        exec <span class="string">&quot;! ./%&lt;&quot;</span></span><br><span class="line">    <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> ==<span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;!g++ % -o %&lt;&quot;</span></span><br><span class="line">        exec <span class="string">&quot;slicent !clear&quot;</span></span><br><span class="line">        exec <span class="string">&quot;! ./%&lt;&quot;</span></span><br><span class="line">    <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> ==<span class="string">&#x27;sh&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;slicent !clear&quot;</span></span><br><span class="line">        exec <span class="string">&quot;! ./%&quot;</span></span><br><span class="line">    <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> ==<span class="string">&#x27;python&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;slicent !clear&quot;</span></span><br><span class="line">        exec <span class="string">&quot;!python ./%&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> RunGdb() <span class="symbol">&lt;CR&gt;</span></span><br><span class="line">func! RunGdb()</span><br><span class="line">    exec <span class="string">&quot;w&quot;</span></span><br><span class="line">    <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;!gcc % -g -o %&lt;&quot;</span></span><br><span class="line">        exec <span class="string">&quot;slicent !clear&quot;</span></span><br><span class="line">        exec <span class="string">&quot;!gdb ./%&lt;&quot;</span></span><br><span class="line">    <span class="keyword">elseif</span> &amp;<span class="keyword">filetype</span> == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">        exec <span class="string">&quot;!g++ % -g -o %&lt;&quot;</span></span><br><span class="line">        exec <span class="string">&quot;slicent !clear&quot;</span></span><br><span class="line">        exec <span class="string">&quot;!gdb ./%&lt;&quot;</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ leader f config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutF</span>= <span class="string">&#x27;&lt;c-p&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutB</span>= <span class="string">&#x27;&lt;c-b&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:WorkingDirectoryMode</span> = <span class="string">&#x27;AF&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_RootMarkers</span> = [<span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.svn&#x27;</span>, <span class="string">&#x27;.hg&#x27;</span>, <span class="string">&#x27;.project&#x27;</span>, <span class="string">&#x27;.root&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_PreviewInPopup</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WindowHeight</span> = <span class="number">0.30</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_StlColorscheme</span>= <span class="string">&#x27;powerline&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ simpyl fold config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:SimpylFold_docstring_preview</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ flake config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> python_highlight_all=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ indent line config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:indentLine_char_list</span> = [<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;¦&#x27;</span>, <span class="string">&#x27;┆&#x27;</span>, <span class="string">&#x27;┊&#x27;</span>]</span><br><span class="line"><span class="string">&quot; let g:indentLine_color_term = 255 &quot;</span> <span class="keyword">change</span> color </span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F3&gt;</span> :IndentLinesToggle<span class="symbol">&lt;cr&gt;</span> <span class="comment">&quot; F3 toggle indent line function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ UltiSnips  config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsExpandTrigger</span>=<span class="string">&quot;&lt;tab&gt;&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsJumpForwardTrigger</span>=<span class="string">&quot;&lt;c-b&gt;&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsJumpBackwardTrigger</span>=<span class="string">&quot;&lt;c-z&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; If you want :UltiSnipsEdit to split your window.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsEditSplit</span>=<span class="string">&quot;vertical&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ ALE  config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_linters</span> = &#123;</span><br><span class="line">            \ <span class="string">&#x27;rust&#x27;</span>: [<span class="string">&#x27;analyzer&#x27;</span>],</span><br><span class="line">\&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_fixers</span> = &#123;</span><br><span class="line">            \ <span class="string">&#x27;rust&#x27;</span>: [<span class="string">&#x27;rustfmt&#x27;</span>, <span class="string">&#x27;trim_whitespace&#x27;</span>, <span class="string">&#x27;remove_trailing_lines&#x27;</span>]</span><br><span class="line">\&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Optional, configure as-you-type completions</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_completion_enabled</span> = <span class="number">1</span><span class="comment">&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_python_flake8_options</span> = <span class="string">&#x27;--max-line-length=88&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ autopairs config++++++++++++++++++++</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:AutoPairsFlyMode</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F2&gt;</span> :AutoPairsShortcutToggle<span class="symbol">&lt;cr&gt;</span> <span class="comment">&quot; F2 toggle indent line function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;++++++++++++++++++++ fzf config++++++++++++++++++++</span></span><br><span class="line"><span class="comment">&quot;append and export MACRO in .zshrc AND .bashrc</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; # FZF using ripgrep [support multi-files search]</span></span><br><span class="line"><span class="comment">&quot; # Set custom color schemes</span></span><br><span class="line"><span class="comment">&quot; # Check color schemes : https://github.com/junegunn/fzf/wiki/Color-schemes</span></span><br><span class="line"><span class="comment">&quot; if type rg &amp;&gt; /dev/null; then</span></span><br><span class="line"><span class="comment">&quot;   export FZF_DEFAULT_COMMAND=&#x27;rg --files&#x27;</span></span><br><span class="line"><span class="comment">&quot;   export FZF_DEFAULT_OPTS=&#x27;</span></span><br><span class="line"><span class="comment">&quot;   -m --height 30% --border </span></span><br><span class="line"><span class="comment">&quot;   --color fg:242,bg:236,hl:65,fg+:15,bg+:239,hl+:108</span></span><br><span class="line"><span class="comment">&quot;   --color info:108,prompt:109,spinner:108,pointer:168,marker:168</span></span><br><span class="line"><span class="comment">&quot;   &#x27;</span></span><br><span class="line"><span class="comment">&quot; fi</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; Echo $SHELL to check DEFAULT shell and echo $0 to check CURRENT shell</span></span><br><span class="line"><span class="comment">&quot; Switch to related shell by zsh AND bash command and source .zshrc AND .bashrc</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; Remap shortkey</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> :Files<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>g :GFiles<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>r :Rg<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">b</span> :Buffers<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">l</span> :BLines<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>t :Helptags<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>h :History<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>h: :History:<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>h/ :History/<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot; Set grepprg as RipGrep </span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">executable</span>(<span class="string">&quot;rg&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span> grepprg=rg\ --<span class="keyword">vimgrep</span>\ --smart-case\ --hidden\ --follow</span><br><span class="line">    <span class="keyword">set</span> grepformat=%<span class="keyword">f</span>:%<span class="keyword">l</span>:%<span class="keyword">c</span>:%<span class="keyword">m</span>,%<span class="keyword">f</span>:%<span class="keyword">l</span>:%<span class="keyword">m</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; Exclude rg content search in file names and only search file contents</span></span><br><span class="line">command! -bang -nargs=* Rg <span class="keyword">call</span> fzf#vim#grep(<span class="string">&quot;rg --column --line-number --no-heading --color=always --smart-case &quot;</span>.<span class="built_in">shellescape</span>(<span class="symbol">&lt;q-args&gt;</span>), <span class="number">1</span>, &#123;<span class="string">&#x27;options&#x27;</span>: <span class="string">&#x27;--delimiter : --nth 4..&#x27;</span>&#125;, <span class="symbol">&lt;bang&gt;</span><span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; Rg basic Search Usage:</span></span><br><span class="line"><span class="comment">&quot; Search for foo in current working directory: :grep foo.</span></span><br><span class="line"><span class="comment">&quot; Search for foo in files under src/: :grep foo src.</span></span><br><span class="line"><span class="comment">&quot; Search for foo in current file directory: :grep foo %:h.</span></span><br><span class="line"><span class="comment">&quot; Search for foo in current file directory’s parent directory: :grep foo %:h:h (and so on).</span></span><br><span class="line"><span class="comment">&quot; Search for the exact word foo (not foobar): :grep -w foo (equivalent to :grep &#x27;\bfoo\b&#x27;).</span></span><br><span class="line"><span class="comment">&quot; Search for foo in files matching a glob: :grep foo -g &#x27;*.rs&#x27;</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"><span class="comment">&quot; Quickfix Replace Usage:</span></span><br><span class="line"><span class="comment">&quot; :cdo s/foo/bar/gc. And then :cfdo update</span></span><br><span class="line"><span class="comment">&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; ********** Brief help **********</span></span><br><span class="line"><span class="comment">&quot; :PluginList       - lists configured plugins</span></span><br><span class="line"><span class="comment">&quot; :PluginInstall    - installs plugins; append `!` to update or just</span></span><br><span class="line"><span class="comment">&quot; :PluginUpdate</span></span><br><span class="line"><span class="comment">&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache</span></span><br><span class="line"><span class="comment">&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal</span></span><br><span class="line"><span class="string">&quot; &quot;</span> see :h vundle <span class="keyword">for</span> more details <span class="built_in">or</span> wiki <span class="keyword">for</span> FAQ</span><br><span class="line"><span class="comment">&quot;</span></span><br></pre></td></tr></table></figure>

<p>本人的VIM环境整体的配置效果如图所示:<br><img src="http://www.taolingyang.com/2017/07/08/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%80%BB%E7%BB%93/vim-display.png" alt="vim-cfg"></p>
<blockquote>
<p>左边窗口是<code>NerdTree</code>，右边是<code>Tagbar</code>，下方是<code>fzf</code></p>
</blockquote>
<p>附:<br>比较齐全的VIM命令图解:<br><img src="http://www.taolingyang.com/2017/07/08/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%80%BB%E7%BB%93/vim-cheatsheet.jpg" alt="vim-cmd"><br><img src="http://www.taolingyang.com/2017/07/08/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%80%BB%E7%BB%93/vim-cheatsheet2.jpg" alt="vim-cmd2"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p><strong>工欲善其事必先利其器</strong>, 如果是在C&#x2F;C++&#x2F;Python等语言下做开发,VIM作为其编辑器在使用熟练情况能够一定程度上提高生产力,但是必须面对一个事实是:VIM的学习曲线很陡,需要不停的折腾.自己也是在不断的学习和了解它,不过慢慢感觉使用多了,习惯了使用它编辑,很快你就会喜欢上它。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://en.wikipedia.org/wiki/Vim_(text_editor)">https://en.wikipedia.org/wiki/Vim_(text_editor)</a></p>
<p><a href="www.vim.org">www.vim.org</a></p>
<p><a href="http://www.tuicool.com/articles/f6feae">http://www.tuicool.com/articles/f6feae</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-tip-vim/">https://www.ibm.com/developerworks/cn/linux/l-cn-tip-vim/</a></p>
<p><a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/">http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/</a></p>
<p><a href="http://www.cnblogs.com/DillGao/p/6268165.html">http://www.cnblogs.com/DillGao/p/6268165.html</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux使用总结</title>
    <url>/2019/01/23/Tmux%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><code>Tmux</code>是一个终端复用器(Terminal multiplexer)类自由软件，类似于<code>Screen</code>和<code>Byohu</code>，但是比这两者功能更强大，Wiki上这样说<code>Tmux</code>：</p>
<pre><code>tmux is an open-source terminal multiplexer for Unix-like operating systems. 
It allows multiple terminal sessions to be accessed simultaneously in a single window.
It is useful for running more than one command-line program at the same time.
It can also be used to detach processes from their controlling terminals, allowing remote sessions to remain active without being visible
</code></pre>
<blockquote>
<p><code>Tmux</code>是类Unix操作系统上的开源终端复用器，其允许多个终端会话在单个窗口中同时被访问，对于同一时刻允许多个命令行的程序来说很有用。它可以从控制终端中分离出进程并且允许远程回话在无窗口不可视化情况下保持激活状态。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><hr>
<h3 id="模块组成"><a href="#模块组成" class="headerlink" title="模块组成"></a>模块组成</h3><hr>
<p><code>Tmux</code>采用<code>Client/Server</code>模型，主要包括以下几种模块组成：</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Client</td>
<td align="center">从外部终端(xterm, terminal)连接到一个Tmux Session</td>
</tr>
<tr>
<td align="center">Server</td>
<td align="center">Tmux 运行的基础服务，Session,Window,Pane均依赖于此</td>
</tr>
<tr>
<td align="center">Session</td>
<td align="center">一个或多个Window 组成</td>
</tr>
<tr>
<td align="center">Window</td>
<td align="center">一个或多个Pane组成，连接到一个或多个Session</td>
</tr>
<tr>
<td align="center">Pane</td>
<td align="center">包含一个终端Terminal并且运行程序，出现在某个Window</td>
</tr>
</tbody></table>
<h4 id="Tmux-Clients-x2F-Server"><a href="#Tmux-Clients-x2F-Server" class="headerlink" title="Tmux Clients&#x2F;Server"></a>Tmux Clients&#x2F;Server</h4><hr>
<p><code>Tmux</code>服务器保持所有的状态在单个主进程中，该服务器运行在后台，并且管理着所有在<code>Tmux</code>中运行的程序，同时跟踪记录这些程序的输出，当用户运行一个<code>Tmux</code>命令，服务器自动启动并且在无程序运行时自动退出。<br>用户通过启动一个Client Attach连接到<code>Tmux</code>服务器, 这个操作接管了它运行所在的终端并且使用在<code>/tmp</code>目录下的socket文件与服务器进行交互，每个Client运行在一个终端中，这种终端Terminal可以是任意的如xterm, system console等等。</p>
<h4 id="Tmux-Pane"><a href="#Tmux-Pane" class="headerlink" title="Tmux Pane"></a>Tmux Pane</h4><hr>
<p>每个在<code>Tmux</code>中的终端Terminal属于一个Pane, Pane是用来显示终端内容的矩形区域，由于每个在<code>Tmux</code>中的终端Terminal仅在一个Pane中显示，Pane就代表了终端Terminal和运行其中的程序</p>
<h4 id="Tmux-Window"><a href="#Tmux-Window" class="headerlink" title="Tmux Window"></a>Tmux Window</h4><hr>
<p>每个Pane出现在某个Window中，Window由一个或多个Pane组成，并且覆盖了整个显示区域，所以多个Pane可以同时显示，每个Pane在Window中有相应的索引 。</p>
<h4 id="Tmux-Session"><a href="#Tmux-Session" class="headerlink" title="Tmux Session"></a>Tmux Session</h4><hr>
<p>多个Window组成了Session，如果一个Window是某个Session的一部分，那就意味着整个Window连接到该会话。Window可以同时连接到多个Session，尽管大部分只连接到一个Session，每个Window在Session亦有相应的索引，同样的Window在不同的Session中可能是不同的索引。<br>一个Session可以被Attach到一个或多个Client，任意的从Terminal中输入的文本被发送到Attached Sessioin的Current Window的Active Pane中。</p>
<blockquote>
<p>程序运行在属于某个Window的Pane的终端Terminal中<br>每个Window有个名称和Active Pane<br>Window可以连接到一个或多个Session<br>每个Session有多个Window，每个Window在其中有个索引<br>Session被Attach到0或多个Client<br>每个Client被Attach到一个Session</p>
</blockquote>
<h3 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h3><hr>
<ol>
<li>可以管理多个Session，Window，Pane</li>
<li>Window，Pane可以在Session中自由移动切换</li>
<li>分屏同时多个操作，并支持自定义快捷键</li>
<li>带有复制黏贴缓冲区</li>
<li>支持自定义配置</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><hr>
<ol>
<li>防止运行在远程服务器上的程序因为断开与客户端连接而停止或退出</li>
<li>多个不同的终端连接到共同的远程服务器上，方便远程结对编程</li>
<li>作为Window Manager可以在一个虚拟终端中同时进行多个程序运行</li>
</ol>
<h2 id="Tmux使用"><a href="#Tmux使用" class="headerlink" title="Tmux使用"></a>Tmux使用</h2><hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr>
<ol>
<li>Debian或Ubuntu命令安装：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">apt <span class="keyword">install</span> tmux</span><br></pre></td></tr></table></figure></li>
<li>从Git仓库源码编译安装：<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone https://github.<span class="keyword">com</span>/tmux/tmux.git</span><br><span class="line"><span class="keyword">cd</span> tmux</span><br><span class="line"><span class="keyword">sh</span> autogen.<span class="keyword">sh</span></span><br><span class="line">./configure</span><br><span class="line"><span class="keyword">make</span> &amp;&amp; sudo <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>安装完后，查看使用<code>Tmux</code>使用手册：输入命令<code>man 1 tmux</code>或者<code>man tmux</code>或者按下<code>Ctrl + b + ?</code>快捷键</p>
</blockquote>
<h3 id="Tmux启动与退出"><a href="#Tmux启动与退出" class="headerlink" title="Tmux启动与退出"></a>Tmux启动与退出</h3><hr>
<ol>
<li><p>输入<code>tmux</code>命令进入<code>Tmux</code>窗口，按下Ctrl + d 或者输入<code>exit</code>退出<code>Tmux</code>窗口。</p>
</li>
<li><p><code>Tmux</code>中所有快捷键都需要前缀键唤起，默认是<code>Ctrl + b</code>，可以在配置文件中更改该默认前缀键盘。</p>
</li>
</ol>
<h3 id="Session使用"><a href="#Session使用" class="headerlink" title="Session使用"></a>Session使用</h3><hr>
<p>Session交互主要包括创建，连接，分离，切换，重命名，罗列，删除等操作。</p>
<blockquote>
<p><code>Tmux</code>最大的优势就是在启动<code>Tmux</code>环境执行各种程序时，可以通过Session<strong>分离</strong>让<code>Tmux</code>在后台运行，一般情况下如果我们关闭一个普通的终端Session，那么这个Session中的所有程序就会被杀死，但是从<code>Tmux</code>Session后并没有关闭<code>Tmux</code>，在这个会话中运行的程序仍然在运行，可以在任何时候想要的时候Session<strong>连接</strong>过去。</p>
</blockquote>
<h4 id="创建Session"><a href="#创建Session" class="headerlink" title="创建Session"></a>创建Session</h4><p>新建一个Session，在终端输入<code>tmux</code>命令即可：</p>
<pre><code>tmux
</code></pre>
<p>新建一个带名称的Session：</p>
<pre><code>tmux new -s &lt;session-name&gt;
</code></pre>
<h4 id="连接Session"><a href="#连接Session" class="headerlink" title="连接Session"></a>连接Session</h4><p>可以通过会话编号或名称来接入连接某个已存在的Session，若不带参数则接入到最近最常用的Session：</p>
<pre><code>tmux attach
tmux attach -t &lt;session-id&gt;
tmux attach -t &lt;session-name&gt;
</code></pre>
<h4 id="分离Session"><a href="#分离Session" class="headerlink" title="分离Session"></a>分离Session</h4><p>可以通过会话编号或名称来分离Session，若不带参数则分离当前Session：</p>
<pre><code>tmux detach
tmux detach -t &lt;session-id&gt;
tmux detach -t &lt;session-name&gt;
</code></pre>
<h4 id="切换Session"><a href="#切换Session" class="headerlink" title="切换Session"></a>切换Session</h4><p>可以通过会话编号或名称来切换Session：</p>
<pre><code>tmux switch -t &lt;session-id&gt;
tmux switch -t &lt;session-name&gt;
</code></pre>
<h4 id="重命名Session"><a href="#重命名Session" class="headerlink" title="重命名Session"></a>重命名Session</h4><p>可以通过会话编号或名称来重命名Session，若只带一个参数表示重命名当前Session：</p>
<pre><code>tmux rename-session  &lt;new-session-anme&gt;
tmux rename-session -t &lt;old-session-id/name&gt; &lt;new-session-anme&gt;
</code></pre>
<h4 id="罗列Session"><a href="#罗列Session" class="headerlink" title="罗列Session"></a>罗列Session</h4><p>查看Session列表：</p>
<pre><code>tmux ls
tmux list-session
</code></pre>
<h4 id="删除Session"><a href="#删除Session" class="headerlink" title="删除Session"></a>删除Session</h4><p>可以通过会话编号或名称来删除Session，若不带参数则删除当前Session：</p>
<pre><code>tmux kill
tmux kill -t &lt;session-id&gt;
tmux kill -t &lt;session-name&gt;
</code></pre>
<h3 id="Session操作快捷键"><a href="#Session操作快捷键" class="headerlink" title="Session操作快捷键"></a>Session操作快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl-b + d</td>
<td align="center">分离当前会话</td>
</tr>
<tr>
<td align="center">Ctrl-b + s</td>
<td align="center">列出当前会话</td>
</tr>
<tr>
<td align="center">Ctrl-b + $</td>
<td align="center">重命名当前会话</td>
</tr>
<tr>
<td align="center">Ctrl-b + (</td>
<td align="center">移动到前一个会话</td>
</tr>
<tr>
<td align="center">Ctrl-b + )</td>
<td align="center">移动到后一个会话</td>
</tr>
</tbody></table>
<h3 id="Window使用"><a href="#Window使用" class="headerlink" title="Window使用"></a>Window使用</h3><hr>
<p>Window交互主要包括创建，切换，重命名，罗列，删除等操作。</p>
<h4 id="创建Window"><a href="#创建Window" class="headerlink" title="创建Window"></a>创建Window</h4><p>新建一个Window，在终端输入<code>tmux</code>命令即可：</p>
<pre><code>tmux new-window
</code></pre>
<p>新建一个带名称的Window：</p>
<pre><code>tmux new-window -n &lt;window-name&gt;
</code></pre>
<h4 id="切换Window"><a href="#切换Window" class="headerlink" title="切换Window"></a>切换Window</h4><p>可以通过窗口编号或名称来切换Window：</p>
<pre><code>tmux select-window -t &lt;window-id&gt;
tmux select-window -t &lt;window-name&gt;
</code></pre>
<h4 id="重命名Window"><a href="#重命名Window" class="headerlink" title="重命名Window"></a>重命名Window</h4><p>可以通过窗口编号或名称来重命名Window，若只带一个参数表示重命名当前Window：</p>
<pre><code>tmux rename-window  &lt;new-window-anme&gt;
tmux rename-window -t &lt;old-window-id/name&gt; &lt;new-window-anme&gt;
</code></pre>
<h4 id="罗列Window"><a href="#罗列Window" class="headerlink" title="罗列Window"></a>罗列Window</h4><p>查看Window列表，不带<code>-a</code>表示列出当前Session的所有Window，否则列出所有Session的所有Window：</p>
<pre><code>tmux list-window
tmux list-window -a
</code></pre>
<h4 id="删除Window"><a href="#删除Window" class="headerlink" title="删除Window"></a>删除Window</h4><p>可以通过窗口编号或名称来删除Window，若不带参数则删除当前Window，带表示<code>a</code>所有：</p>
<pre><code>tmux kill-window
tmux kill-window -a
tmux kill-window -t &lt;window-id&gt;
tmux kill-window -t &lt;window-name&gt;
</code></pre>
<h3 id="Window操作快捷键"><a href="#Window操作快捷键" class="headerlink" title="Window操作快捷键"></a>Window操作快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl-b + c</td>
<td align="center">创建新的窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + p</td>
<td align="center">切换到前一个窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + n</td>
<td align="center">切换到下一个窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + w</td>
<td align="center">从列表中选窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + 0-9</td>
<td align="center">切换到指定编号窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + ,</td>
<td align="center">重命名当前窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + &amp;</td>
<td align="center">关闭当前窗口</td>
</tr>
</tbody></table>
<h3 id="Pane使用"><a href="#Pane使用" class="headerlink" title="Pane使用"></a>Pane使用</h3><hr>
<p>Pane交互主要包括创建，切换，交换位置，调整大小，罗列，删除等操作。</p>
<h4 id="创建Pane"><a href="#创建Pane" class="headerlink" title="创建Pane"></a>创建Pane</h4><p><code>Tmux</code>可以将Window分割成多个Pane,每个Pane运行不同程序，默认上下划分当前Window：</p>
<pre><code>tmux split-window
</code></pre>
<p>左右划分当前Window：</p>
<pre><code>tmux split-window -h
</code></pre>
<h4 id="切换Pane"><a href="#切换Pane" class="headerlink" title="切换Pane"></a>切换Pane</h4><p>可以通过<code>select-pane</code>命令加方向来使光标切换不同Pane，上下左右(Up,Down,Left,Right):</p>
<pre><code>tmux select-pane -U
tmux select-pane -D
tmux select-pane -L
tmux select-pane -R
</code></pre>
<h4 id="交换Pane"><a href="#交换Pane" class="headerlink" title="交换Pane"></a>交换Pane</h4><p>可以通过<code>swap-pane</code>命令加方向来将当前Pane交换移动到不同位置，上下左右(Up,Down,Left,Right):</p>
<pre><code>tmux swap-pane -U
tmux swap-pane -D
tmux swap-pane -L
tmux swap-pane -R
</code></pre>
<h4 id="调整Pane"><a href="#调整Pane" class="headerlink" title="调整Pane"></a>调整Pane</h4><p>可以通过窗格编号来调整Pane大小，[-UDLR]表示上下左右，[M]表示使用鼠标调整，[Z]表示目标Pane放大到整个Window大小其他Pane隐藏，连续执行则恢复原来大小和位置这样Toggle操作，[target-pane]表示目标Pane，若没有表示当前Pane，<br>[-x width]和 [-y height]表示调整的绝对量，[adjustment]表示调整的相对量，默认为1</p>
<pre><code>tmux resize-pane [-DLMRUZ] [-t target-pane] [-x width] [-y height] [adjustment]
</code></pre>
<h4 id="罗列Pane"><a href="#罗列Pane" class="headerlink" title="罗列Pane"></a>罗列Pane</h4><p>查看Pane列表，不带<code>-as</code>表示列出当前Session当前Window的所有Pane，带<code>-a</code>表示列出所有Session所有Window所有Pane，不带<code>-a</code>带<code>-s</code>表示列出<code>target</code>指定Session的所有Pane：</p>
<pre><code>tmux list-panes [-as] [-t target]
</code></pre>
<h4 id="删除Pane"><a href="#删除Pane" class="headerlink" title="删除Pane"></a>删除Pane</h4><p>可以通过窗格编号或名称来删除Pane，若不带参数则删除当前Pane，带<code>-a</code>表示所有：</p>
<pre><code>tmux kill-pane 
tmux kill-pane -a 
tmux kill-pane -t &lt;pane-id&gt;
tmux kill-pane -t &lt;pane-name&gt;
</code></pre>
<h3 id="Pane操作快捷键"><a href="#Pane操作快捷键" class="headerlink" title="Pane操作快捷键"></a>Pane操作快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl-b + %</td>
<td align="center">水平分割当前窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + “</td>
<td align="center">竖直分割当前窗口</td>
</tr>
<tr>
<td align="center">Ctrl-b + {</td>
<td align="center">移动到当前Pane到左边</td>
</tr>
<tr>
<td align="center">Ctrl-b + }</td>
<td align="center">移动到当前Pane到右边</td>
</tr>
<tr>
<td align="center">Ctrl-b + Ctrl + o</td>
<td align="center">移动到当前Pane到上边</td>
</tr>
<tr>
<td align="center">Ctrl-b + Alt + o</td>
<td align="center">移动到当前Pane到下边</td>
</tr>
<tr>
<td align="center">Ctrl-b + Arrow</td>
<td align="center">切换Pane到指定方向</td>
</tr>
<tr>
<td align="center">Ctrl-b + o</td>
<td align="center">切换到下一个Pane</td>
</tr>
<tr>
<td align="center">Ctrl-b + q</td>
<td align="center">显示到Pane编号</td>
</tr>
<tr>
<td align="center">Ctrl-b + q + 0-9</td>
<td align="center">切换到指定编号Pane</td>
</tr>
<tr>
<td align="center">Ctrl-b + z</td>
<td align="center">Toogle Zoom当前Pane</td>
</tr>
<tr>
<td align="center">Ctrl-b + space</td>
<td align="center">切换Pane布局</td>
</tr>
<tr>
<td align="center">Ctrl-b + !</td>
<td align="center">转换当前Pane到Window</td>
</tr>
<tr>
<td align="center">Ctrl-b + x</td>
<td align="center">关闭当前Pane</td>
</tr>
</tbody></table>
<h3 id="其他命令使用"><a href="#其他命令使用" class="headerlink" title="其他命令使用"></a>其他命令使用</h3><hr>
<p>如果没有Session，Window，Pane在<code>Tmux</code>中，<code>Tmux</code> Server会退出，亦可以通过以下命令Kill整个<code>Tmux</code>：</p>
<pre><code>kill-server
</code></pre>
<p>列出所有快捷键及相应的命令：</p>
<pre><code>tmux list-keys
</code></pre>
<p>列出所有命令及参数：</p>
<pre><code>tmux list-commands
</code></pre>
<p>列出所有Session信息：</p>
<pre><code>tmux info
</code></pre>
<p>重新加载当前配置：</p>
<pre><code>tmux source-file ~/.tmux.conf
</code></pre>
<p>当前窗格中显示时间：</p>
<pre><code>tmux clock-mode
</code></pre>
<h3 id="其他命令快捷键"><a href="#其他命令快捷键" class="headerlink" title="其他命令快捷键"></a>其他命令快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl-b + :</td>
<td align="center">进入Tmux命令Mode</td>
</tr>
<tr>
<td align="center">Ctrl-b + ?</td>
<td align="center">帮助</td>
</tr>
<tr>
<td align="center">Ctrl-b + t</td>
<td align="center">显示时钟</td>
</tr>
</tbody></table>
<h3 id="复制黏贴"><a href="#复制黏贴" class="headerlink" title="复制黏贴"></a>复制黏贴</h3><hr>
<h4 id="复制黏贴操作"><a href="#复制黏贴操作" class="headerlink" title="复制黏贴操作"></a>复制黏贴操作</h4><p><code>Tmux</code>复制黏贴可以将终端的文本内容包括在屏幕之外可以通过键盘来前后翻动的文本内容复制到另一个程序或文件中，达到高效复用终端显示文本的效果。<br>主要步骤分以下三步：</p>
<ol>
<li><p>进入Copy Mode<br>通过<code>Ctrl + b + [</code>进入Copy Mode，可以通过<code>q</code>命令提前退出Copy Mode,</p>
</li>
<li><p>选中终端文本<br>移动光标选中文本可以使用vi模式，只需要在<code>Tmux</code>配置文件中增加：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">setw -g <span class="keyword">mode</span>-<span class="built_in">keys</span> <span class="keyword">vi</span></span><br></pre></td></tr></table></figure>
<p>设置完成后，可以通过Vi的快捷键来移动光标到需要复制的首位置，然后按下<code>Space</code>空格键开始文本选中，然后移动光标到文本尾部，选中完成后，按下<code>Enter</code>键将选中的文本复制到<code>Tmux</code>的复制黏贴缓冲区。</p>
</li>
<li><p>执行复制并退出Copy Mode<br>切换到需要黏贴的地方，通过<code>Ctrl + b + ]</code>执行Copy并退出Copy Mode</p>
</li>
</ol>
<h4 id="复制当前Pane可视化范围所有终端文本"><a href="#复制当前Pane可视化范围所有终端文本" class="headerlink" title="复制当前Pane可视化范围所有终端文本"></a>复制当前Pane可视化范围所有终端文本</h4><p>如果需要将Pane的可视化范围内容全部复制到一个黏贴缓冲区里，只需要待复制的Pane命令行中输入：</p>
<pre><code>tmux capture-pane
</code></pre>
<p>或者按下<code>Ctrl + b + :</code>进入<code>Tmux</code>命令模式输入<code>capture-pane</code></p>
<h4 id="复制选中内容保存到文件"><a href="#复制选中内容保存到文件" class="headerlink" title="复制选中内容保存到文件"></a>复制选中内容保存到文件</h4><p>如果需要将黏贴缓冲区的内容保存到文件，只需要在命令行中输入：</p>
<pre><code>tmux save-buffer [filename]
</code></pre>
<p>或者按下<code>Ctrl + b + :</code>进入<code>Tmux</code>命令模式输入<code>save-buffer [filename]</code></p>
<h4 id="复制黏贴其他操作"><a href="#复制黏贴其他操作" class="headerlink" title="复制黏贴其他操作"></a>复制黏贴其他操作</h4><p>可以通过以下命令进行查看黏贴缓冲区状态</p>
<pre><code>tmux show-buffer  // 显示当前缓存区内容
tmux list-buffers //列出所有的黏贴缓冲区
tmux delete-buffer -b id //删除buffer_id的黏贴缓冲区
</code></pre>
<h4 id="复制黏贴快捷键"><a href="#复制黏贴快捷键" class="headerlink" title="复制黏贴快捷键"></a>复制黏贴快捷键</h4><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl-b + [</td>
<td align="center">进入Copy Mode</td>
</tr>
<tr>
<td align="center">Ctrl-b + ]</td>
<td align="center">退出Copy Mode</td>
</tr>
<tr>
<td align="center">q</td>
<td align="center">退出模式</td>
</tr>
<tr>
<td align="center">Space</td>
<td align="center">开始选中文本</td>
</tr>
<tr>
<td align="center">Esc</td>
<td align="center">清除选中文本</td>
</tr>
<tr>
<td align="center">Enter</td>
<td align="center">复制选中文本到Buffer</td>
</tr>
</tbody></table>
<h3 id="Tmux配置"><a href="#Tmux配置" class="headerlink" title="Tmux配置"></a>Tmux配置</h3><hr>
<h4 id="Tmux配置文件"><a href="#Tmux配置文件" class="headerlink" title="Tmux配置文件"></a>Tmux配置文件</h4><p><code>Tmux</code>配置文件<code>.tmux.conf</code>一般存在于用户的home目录下，该文件包含了一系列的按顺序执行的<code>Tmux</code>命令, 只有在<code>Tmux</code>Server 启动的时候才会运行该文件，其他情况如新建Session等不会运行该文件<br>一般情况下，修改配置文件后，需要运行以下命令才能使配置文件生效:</p>
<pre><code>tmux source ~/.tmux.conf
</code></pre>
<blockquote>
<p>一些常用的<code>Tmux</code>执行命令和配置都可以在配置文件中完成，如一些<code>Tmux</code>Server启动时候需要执行的命令和常用的快捷键配置</p>
</blockquote>
<h3 id="Tmux-Plugin"><a href="#Tmux-Plugin" class="headerlink" title="Tmux Plugin"></a>Tmux Plugin</h3><hr>
<h4 id="安装TPM"><a href="#安装TPM" class="headerlink" title="安装TPM"></a>安装TPM</h4><p><code>Tmux</code>支持各种Plugin，增强其功能扩展性，其Plugin管理工具为<code>TPM</code>，全称Tmux Plugin Manager，<code>TPM</code>之于<code>Tmux</code>就如同<code>Vundle</code>之于<code>Vim</code>。</p>
<p>安装<code>TPM</code>以下几步骤：</p>
<ol>
<li><code>git clone</code>到<code>Tmux</code>plugins 目录：<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/tmux-plugins/</span>tpm ~<span class="regexp">/.tmux/</span>plugins/tpm</span><br></pre></td></tr></table></figure></li>
<li>更改配置文件<code>.tmux.conf</code>：<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"># List of plugins</span><br><span class="line"><span class="keyword">set</span> -g <span class="comment">@plugin</span> <span class="comment">&#x27;tmux-plugins/tpm&#x27;</span></span><br><span class="line"><span class="keyword">set</span> <span class="comment">-g @plugin</span> <span class="comment">&#x27;tmux-plugins/tmux-sensible&#x27;</span></span><br><span class="line"></span><br><span class="line"># Other <span class="comment">examples:</span></span><br><span class="line"># <span class="keyword">set</span> <span class="comment">-g @plugin</span> <span class="comment">&#x27;github_username/plugin_name&#x27;</span></span><br><span class="line"># <span class="keyword">set</span> <span class="comment">-g @plugin</span> <span class="comment">&#x27;github_username/plugin_name#branch&#x27;</span></span><br><span class="line"># <span class="keyword">set</span> <span class="comment">-g @plugin</span> <span class="comment">&#x27;git@github.com:user/plugin&#x27;</span></span><br><span class="line"># <span class="keyword">set</span> <span class="comment">-g @plugin</span> <span class="comment">&#x27;git@bitbucket.com:user/plugin&#x27;</span></span><br><span class="line"></span><br><span class="line"># Initialize <span class="comment">TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span></span><br><span class="line">run <span class="comment">&#x27;~/.tmux/plugins/tpm/tpm&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="常用Plugin"><a href="#常用Plugin" class="headerlink" title="常用Plugin"></a>常用Plugin</h4><p>安装完<code>Tmux</code>Plugin管理插件<code>TPM</code>后，可以安装其他插件，常用的插件有：</p>
<ol>
<li><p>tmux-sensible<br>一些常用的大家都觉得好用的配置，正如其官方所说：<code>basic tmux settings everyone can agree on</code>，主要是方便<code>Tmux</code>配置管理。<br>在配置文件中添加:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> -g <span class="meta">@plugin</span> <span class="string">&#x27;tmux-plugins/tmux-ensible&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tmux-resurrect<br>系统重启后，恢复<code>Tmux</code>配置，亦正如其官方所说：<code>Persists tmux environment across system restarts</code>，<code>Tmux</code>在计算机系统重启后，运行的程序，工作目录Pane布局都丢失了，该插件主要目的是保存尽可能多的<code>Tmux</code>环境细节，当机器重启后，仍然能重新保持之前的状态。<br>在配置文件中添加:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> -g <span class="meta">@plugin</span> <span class="string">&#x27;tmux-plugins/tmux-resurrect&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p> 快捷键为：保存环境(Ctrl + b Ctrl + s)，恢复环境(Ctrl + b Ctr + r)</p>
</blockquote>
<h4 id="Plugin操作"><a href="#Plugin操作" class="headerlink" title="Plugin操作"></a>Plugin操作</h4><ol>
<li><p>安装插件<br>直接输入以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">~<span class="regexp">/.tmux/</span>plugins<span class="regexp">/tpm/</span>bin/install_plugins</span><br></pre></td></tr></table></figure>
<p>或者快捷键<code>Ctrl + b + I(大写)</code></p>
</li>
<li><p>更新插件<br>直接输入以下命令，带<code>all</code>参数表示更新所有Plugin：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">~<span class="regexp">/.tmux/</span>plugins<span class="regexp">/tpm/</span>bin/update_plugins all</span><br><span class="line">~<span class="regexp">/.tmux/</span>plugins<span class="regexp">/tpm/</span>bin/update_plugins plugin-name</span><br></pre></td></tr></table></figure>
<p>或者快捷键<code>Ctrl + b + U(大写)</code></p>
</li>
<li><p>卸载插件<br>直接输入以下命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">~<span class="regexp">/.tmux/</span>plugins<span class="regexp">/tpm/</span>bin/clean_plugins</span><br></pre></td></tr></table></figure>
<p>或者快捷键<code>Ctrl + b + alt + u(小写)</code></p>
</li>
</ol>
<p>本人的<code>Tmux</code>配置如下:</p>
<pre><code># List of plugins
set -g @plugin &#39;tmux-plugins/tpm&#39;
set -g @plugin &#39;tmux-plugins/tmux-sensible&#39;

# Other plugins:
set -g @plugin &#39;tmux-plugins/tmux-resurrect&#39;

# Set Vim-like Copy Mode
setw -g mode-keys vi
# Vim-like pane-operation remap
# Vim-like pane resizing  
bind -r C-k resize-pane -U
bind -r C-j resize-pane -D
bind -r C-h resize-pane -L
bind -r C-l resize-pane -R

# Vim-like pane switching
bind -r k select-pane -U
bind -r j select-pane -D
bind -r h select-pane -L
bind -r l select-pane -R

# Reload tmux config file
bind r source-file ~/.tmux.conf

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run &#39;~/.tmux/plugins/tpm/tpm&#39;
</code></pre>
<p>附:<br>比较齐全的<code>Tmux</code>命令图解:<br><img src="http://www.taolingyang.com/2019/01/23/Tmux%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/tmux-cheatsheet1.png" alt="tmux-cheatsheet1"><br><img src="http://www.taolingyang.com/2019/01/23/Tmux%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/tmux-cheatsheet2.png" alt="tmux-cheatsheet2"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p><code>Tmux</code>能够在同一个虚拟终端下同时进行运行多个程序，并且支持多窗口操作。能在断网或关机情况下保持本地虚拟终端状态，对于命令行方式工作的连续性有很大的帮助，同时支持命令行下的复制黏贴操作也加快了文本复用操作。自定义配置和插件能根据个人习惯进行功能扩展和属性配置，可以说<code>Tmux</code>是和命令行文本编辑工具<code>Vim</code>配合的神器。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://github.com/tmux/tmux/wiki/Getting-Started">Tmux Wiki</a></p>
<p><a href="https://en.wikipedia.org/wiki/Tmux">Tmux wikipedia</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux使用教程</a></p>
<p><a href="http://linuxaria.com/article/tmux-the-terminal-multiplexer">Tmux- The Terminal multiplexer</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下GVim使用</title>
    <url>/2019/07/08/Windows%E4%B8%8BGVim%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>早些时候在文章<a href="/2017/07/08/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%80%BB%E7%BB%93/index.html">Vim编辑器总结</a>中总结Vim的常用用法和Linux下的安装和配置，虽然大部分时间是在Visual Studio + Viemu插件方式工作，但是有时候需要在Windows下使用Vim环境，因此有必要在Windows环境配置和Linux相似的Vim编辑环境，下面把Windows下<code>GVim</code>的安装和配置使用主要是与Linux环境下的不同地方进行分析总结。</p>
<span id="more"></span>

<h2 id="GVim安装"><a href="#GVim安装" class="headerlink" title="GVim安装"></a>GVim安装</h2><hr>
<p><code>GVim</code>由于需要安装一些Python依赖的插件，因此需要Windows系统先安装好Python环境，且Python和GVim都需要安装一样的位数，由于电脑是64bits，所以Python和<code>GVim</code>都安装64bits</p>
<h3 id="Python安装"><a href="#Python安装" class="headerlink" title="Python安装"></a>Python安装</h3><ol>
<li><p>下载链接：<a href="https://www.python.org/downloads/windows/">Python Windows</a>，注意选择最新的Python3版本安装</p>
<blockquote>
<p>安装过程，最好将Python加入系统环境变量，方便访问</p>
</blockquote>
</li>
<li><p>安装完成后，打开终端输入<code>Python</code>查看是否安装成功最新版本：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">python</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="GVim安装-1"><a href="#GVim安装-1" class="headerlink" title="GVim安装"></a>GVim安装</h3><ol>
<li>下载链接：<a href="https://github.com/vim/vim-win32-installer/releases">GVim-Release</a>，注意选择Release版本Assets部分的最新的GVim x64版本下载安装</li>
<li>安装完成后，打开终端查看<code>Vim</code>和<code>GVim</code>版本和相应的功能选项，关键是确认下是有支持Python选项：<br>Vim是Windows Console控制台版本，通过以下命令查看：<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> --<span class="keyword">version</span></span><br></pre></td></tr></table></figure>
GVim是Windows GUI用户界面版本，通过以下命令查看：<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">gvim</span> --<span class="keyword">version</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="GVim配置"><a href="#GVim配置" class="headerlink" title="GVim配置"></a>GVim配置</h2><hr>
<h3 id="GVim配置文件分类与优先级"><a href="#GVim配置文件分类与优先级" class="headerlink" title="GVim配置文件分类与优先级"></a>GVim配置文件分类与优先级</h3><p>GVim有Console控制台模式和GUI用户窗口界面模式，两者可以分别配置各自的配置文件，分别为<code>vimrc</code>, <code>_vimrc</code> 或<code>gvimrc</code>, <code>_gvimrc</code>，配置的优先级如下：</p>
<pre><code>系统 vimrc 文件: &quot;$VIM\vimrc&quot;
用户 vimrc 文件: &quot;$HOME\_vimrc&quot;
第二用户 vimrc 文件: &quot;$HOME\vimfiles\vimrc&quot;
第三用户 vimrc 文件: &quot;$VIM\_vimrc&quot;
系统 gvimrc 文件: &quot;$VIM\gvimrc&quot;
用户 gvimrc 文件: &quot;$HOME\_gvimrc&quot;
第二用户 gvimrc 文件: &quot;$HOME\vimfiles\gvimrc&quot;
第三用户 gvimrc 文件: &quot;$VIM\_gvimrc&quot;
defaults 文件: &quot;$VIMRUNTIME\defaults.vim&quot;
</code></pre>
<blockquote>
<p><code>$VIM</code>一般为<code>GVim</code>安装目录，<code>$HOME</code>是用户目录，类似于Linux下<code>~</code></p>
</blockquote>
<h3 id="GVim配置文件配置"><a href="#GVim配置文件配置" class="headerlink" title="GVim配置文件配置"></a>GVim配置文件配置</h3><p><code>GVim</code>在安装完成后一般会在<code>$HOME</code>目录下生成一个<code>vimfiles</code>文件，该文件用来配置<code>GVim</code>的插件和主题颜色，所以常用的做法是在<code>$HOME</code>目录下建立一个<code>_vimrc</code>文件,将<code>GVim</code>的配置放在该文件夹下，一般情况可以将控制台和GUI两种分开，也可以放在一个配置文件通过Vim脚本来区分，本人采用后一种方式，脚本判断OS版本和<code>GVim</code>类型如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">&quot;check os type </span></span><br><span class="line"><span class="comment">&quot; -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:windows</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">has</span>(<span class="string">&quot;win32&quot;</span>) || <span class="built_in">has</span>(<span class="string">&quot;win64&quot;</span>) || <span class="built_in">has</span>(<span class="string">&quot;win95&quot;</span>) || <span class="built_in">has</span>(<span class="string">&quot;win16   &quot;</span>))</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:windows</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:windows</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">&quot;  console or GUI</span></span><br><span class="line"><span class="comment">&quot; -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&quot;gui_running&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:gui</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g:gui</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装完<code>GVim</code>，默认情况下第一优先级<strong>系统vimrc</strong>文件是不存在的，只有第四优先级<strong>第三用户vimrc文件</strong>存在，所以通过在<code>$HOME</code>目录建立<code>_vimrc</code>方式建立第二优先级的配置文件会是最终的生效文件</p>
</blockquote>
<h3 id="GVim插件配置"><a href="#GVim插件配置" class="headerlink" title="GVim插件配置"></a>GVim插件配置</h3><h4 id="Vundle包管理插件安装"><a href="#Vundle包管理插件安装" class="headerlink" title="Vundle包管理插件安装"></a>Vundle包管理插件安装</h4><p>与Linux版本的Vundle包管理插件安装的路径不同，配置文件中Windows下为<code>vimfiles</code>，Linux下为<code>.vim</code>：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">g:windows</span></span><br><span class="line">    <span class="keyword">set</span> rtp+=$HOME/vimfiles/bundle/Vundle.<span class="keyword">vim</span>     <span class="comment">&quot; set the runtime path to include Vundle and initialize for windows</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">set</span> rtp+=$HOME/.<span class="keyword">vim</span>/bundle/Vundle.<span class="keyword">vim</span>     <span class="comment">&quot; set the runtime path to include Vundle and initialize for no_windows</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h4 id="其他插件安装"><a href="#其他插件安装" class="headerlink" title="其他插件安装"></a>其他插件安装</h4><p>之前写的文章<a href="/2017/07/08/Vim%E7%BC%96%E8%BE%91%E5%99%A8%E6%80%BB%E7%BB%93/index.html">Vim编辑器总结</a>中的各种插件基本上和Linux下安装步骤相同，只需要输入以下命令即可:</p>
<pre><code>PluginClean
PluginList
PluginInstall
</code></pre>
<blockquote>
<p>执行上述命令后，这些插件安装在<code>$HOME/.vim/bundle</code>目录下</p>
</blockquote>
<p>但是有几个插件Windows下处理方式有些差别：</p>
<ol>
<li><p><code>TagBar</code>函数类变量导航插件<br>该插件依赖于ctags,所以Windows上也要提前安装好Windows版本的ctags，下载链接: <a href="https://github.com/universal-ctags/ctags-win32/releases">Universal-Ctags-Windows</a>。注意需要下载64bit的ctags，下载完成后解压文件，最后将相应的exe文件拷贝到<code>GVim</code>的安装目录下即与<code>gvim.exe</code>或<code>vime.exe</code>同一目录下</p>
</li>
<li><p><code>fzf</code>模糊查找插件<br>该插件需要安装Windows下的二进制文件，在打开<code>fzf</code>时候<code>GVim</code>会自动提示是否安装，直接输入<code>y</code>安装即可,无需手动安装</p>
</li>
<li><p><code>solarized</code>主题插件<br>该插件在<code>GVim</code>的GUI用户可视化模式下需要配置，初次打开会提示无法找到该主题，解决方法为直接将该插件的下载目录($HOME&#x2F;.vim&#x2F;bundle&#x2F;)的<code>solarized.vim</code>拷贝到<code>vimfiles/colors</code>下即可:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cp <span class="variable">$HOME</span><span class="regexp">/.vim/</span>bundle<span class="regexp">/vim-colors-solarized/</span>colors<span class="regexp">/solarized.vim  $HOME/</span>vimfiles<span class="regexp">/colors/</span></span><br></pre></td></tr></table></figure>
<p>同时，为了防止该主题影响<code>GVim</code>的Console控制台模式下的效果，在配置文件中做相应的区分处理：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if ((<span class="name">g</span><span class="symbol">:windows</span> <span class="symbol">&amp;&amp;</span> g<span class="symbol">:gui</span>) || !g<span class="symbol">:windows</span>)</span><br><span class="line">    colorscheme solarized </span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>markdown-preview</code>markdown预览插件<br>该插件也需要安装相应的Windows下二进制文件，与<code>fzf</code>插件自动安装不同，需要手动输入以下命令安装：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:source</span> %</span><br><span class="line"><span class="symbol">:PluginInstall</span></span><br><span class="line"><span class="symbol">:call</span> mkdp<span class="comment">#util#install()</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>YouCompleteMe</code>自动补全插件<br>该插件不同平台下安装差异比较大，Windows下可以参考官方的步骤进行安装：<a href="https://github.com/ycm-core/YouCompleteMe#windows">YCM-Windows-Install</a></p>
</li>
<li><p>其他显示效果<br>如<code>GVim</code>GUI用户可视化模式下，字体设置相对大一些：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">g:gui</span> &amp;&amp; <span class="variable">g:windows</span>)</span><br><span class="line">    <span class="keyword">set</span> guifont=Courier_Ne<span class="variable">w:h14</span>:cANSI        <span class="comment">&quot; Set font </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">set</span> guifont=Courier_New\ <span class="number">12</span>              <span class="comment">&quot; Set font </span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>最终的效果<br>GVim GUI模式下：<br><img src="http://www.taolingyang.com/2019/07/08/Windows%E4%B8%8BGVim%E4%BD%BF%E7%94%A8/gvim-gui.png" alt="gvim-gui"></p>
<p>GVim Console模式下：<br><img src="http://www.taolingyang.com/2019/07/08/Windows%E4%B8%8BGVim%E4%BD%BF%E7%94%A8/gvim-console.png" alt="gvim-console"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>通过以上Windows下<code>GVim</code>的安装和配置操作，基本上Windows平台下GUI窗口用户界面模式和Console控制台模式的Vim效果和Linux下差不多了，这样不同平台下Vim的操作体验一致性也提高很多</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="www.vim.org">www.vim.org</a></p>
<p><a href="https://stackoverflow.com/questions/8804767/e185-cannot-find-color-scheme-solarized">cannot-find-color-scheme-solarized</a></p>
<p><a href="https://github.com/vim/vim-win32-installer">vim-win32-installer</a></p>
<p><a href="https://stackoverflow.com/questions/30691466/what-is-difference-between-vims-clipboard-unnamed-and-unnamedplus-settings">difference-between-vims-clipboard-unnamed-and-unnamedplus-settings</a></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>GVim</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04+CUDA8.0环境搭建</title>
    <url>/2017/07/16/ubuntu14.04-cuda8-0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在处理3D图像数据时候，由于图像数据量大，采用传统的CPU方式进行图像算法处理，速度和性能不能满足项目要求，需要借助并行计算的架构进行处理。现在比较流行的并行计算框架有cuda，opencl，openmp等等。cuda虽然没有opencl这样的异构编程模型通用，可以同时使用在cpu,gpu,fpga,dsp等硬件平台上，但是cuda相比于opencl等并行计算框架比较成熟，且资源也比较多，gpu硬件有多核处理的优势，因此cuda必然作为数据计算加速方案的第一选择。</p>
<span id="more"></span>

<h2 id="CUDA介绍"><a href="#CUDA介绍" class="headerlink" title="CUDA介绍"></a>CUDA介绍</h2><hr>
<p>wiki上关于CUDA的解释:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">CUDA <span class="keyword">is</span> a parallel computing platform <span class="keyword">and</span> <span class="built_in">application</span> programming interface (API) model created <span class="keyword">by</span> Nvidia. It allows software developers <span class="keyword">and</span> software engineers <span class="keyword">to</span> use a CUDA-enabled graphics processing unit (GPU) <span class="keyword">for</span> general purpose processing – an approach termed GPGPU (General-Purpose computing <span class="keyword">on</span> Graphics Processing Units). The CUDA platform <span class="keyword">is</span> a software layer <span class="keyword">that</span> gives direct access <span class="keyword">to</span> <span class="keyword">the</span> GPU&#x27;s virtual instruction <span class="keyword">set</span> <span class="keyword">and</span> parallel computational elements, <span class="keyword">for</span> <span class="keyword">the</span> execution <span class="keyword">of</span> compute kernels.</span><br><span class="line">The CUDA platform <span class="keyword">is</span> designed <span class="keyword">to</span> work <span class="keyword">with</span> programming languages such <span class="keyword">as</span> C, C++, <span class="keyword">and</span> Fortran. This accessibility makes <span class="keyword">it</span> easier <span class="keyword">for</span> specialists <span class="keyword">in</span> parallel programming <span class="keyword">to</span> use GPU resources, <span class="keyword">in</span> contrast <span class="keyword">to</span> prior APIs like Direct3D <span class="keyword">and</span> OpenGL, which required advanced skills <span class="keyword">in</span> graphics programming. Also, CUDA supports programming frameworks such <span class="keyword">as</span> OpenACC <span class="keyword">and</span> OpenCL. When <span class="keyword">it</span> was <span class="keyword">first</span> introduced <span class="keyword">by</span> Nvidia, <span class="keyword">the</span> <span class="built_in">name</span> CUDA was an acronym <span class="keyword">for</span> Compute Unified Device Architecture, <span class="keyword">but</span> Nvidia subsequently dropped <span class="keyword">the</span> use <span class="keyword">of</span> <span class="keyword">the</span> acronym.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cuda主要是nvidia公司开发的在nvidia GPU硬件上进行GPGPU(通用目的的图形卡计算)的并行计算框架， 支持C&#x2F;C++&#x2F;Fortran等计算语言。</p>
</blockquote>
<h2 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h2><hr>
<p>cuda支持windows,linux,macos等多种操作系统，由于本人使用的是ubuntu14.04LTS操作系统，因此这篇文章主要是在ubuntu操作系统上安装cuda8.0(截止2017.7.16,最新的cuda版本为8.0)的过程。</p>
<h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><hr>
<p>在使用CUDA在系统进行开发之前，需要满足以下几个条件:</p>
<ul>
<li>支持CUDA的GPU硬件，关于GPU支持情况可以去NV官网查看(<a href="https://developer.nvidia.com/cuda-gpus">https://developer.nvidia.com/cuda-gpus</a>)</li>
<li>支持CUDA运行的Linux Kernel Header和GCC等工具链</li>
<li>NVIDIA CUDA 工具包(<a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a>)</li>
</ul>
<h4 id="检查GPU是否是CUDA-capable"><a href="#检查GPU是否是CUDA-capable" class="headerlink" title="检查GPU是否是CUDA-capable"></a>检查GPU是否是CUDA-capable</h4><hr>
<p>shell终端输入以下命令：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">lspci <span class="string">| grep -i nvidia</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>会返回GPU版本信息，去NV官网查看是否在支持列表中(<a href="https://developer.nvidia.com/cuda-gpus">https://developer.nvidia.com/cuda-gpus</a>)</p>
</blockquote>
<p>本人笔记本返回:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">01</span>:<span class="number">00</span>.<span class="number">0</span> <span class="number">3</span>D controller: NVIDIA Corporation GK107M<span class="meta"> [GeForce GT 750M] (rev a1)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>本人电脑是GT750M型号的GPU硬件，GeForce系列Kepler架构的GPU，在支持列表中</p>
</blockquote>
<h4 id="检查Linux版本是否支持CUDA"><a href="#检查Linux版本是否支持CUDA" class="headerlink" title="检查Linux版本是否支持CUDA"></a>检查Linux版本是否支持CUDA</h4><hr>
<p>shell终端分别输入以下命令查看Ubuntu版本和基本软硬件信息：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">lsb_release -<span class="selector-tag">a</span></span><br><span class="line">uname -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般的Linux发行版均支持CUDA，通过查询系统信息确认系统操作系统版本和位数方便下载相应的软件开发包</p>
</blockquote>
<p>本人笔记本返回:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">No</span> LSB modules are available.</span><br><span class="line"><span class="attribute">Distributor</span> ID:	Ubuntu</span><br><span class="line"><span class="attribute">Description</span>:	Ubuntu <span class="number">14</span>.<span class="number">04</span>.<span class="number">5</span> LTS</span><br><span class="line"><span class="attribute">Release</span>:	<span class="number">14</span>.<span class="number">04</span></span><br><span class="line"><span class="attribute">Codename</span>:	trusty</span><br><span class="line"></span><br><span class="line"><span class="attribute">Linux</span> franktly <span class="number">3</span>.<span class="number">13</span>.<span class="number">0</span>-<span class="number">123</span>-generic #<span class="number">172</span>-Ubuntu SMP Mon Jun <span class="number">26</span> <span class="number">18</span>:<span class="number">04</span>:<span class="number">35</span> UTC <span class="number">2017</span> x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本人电脑是3.13 linux kernel版本，64位ubuntu14.04系统，支持CUDA8.0(CUDA8.0在ubuntu14.0上需要Kernel版本为3.13版本)</p>
</blockquote>
<h4 id="检查Gcc版本"><a href="#检查Gcc版本" class="headerlink" title="检查Gcc版本"></a>检查Gcc版本</h4><hr>
<p>shell终端输入以下命令查看Gcc版本：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">gcc <span class="comment">--version</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>CUDA8.0在ubuntu14.04上需要4.8.2及其以上的Gcc版本支持，若Gcc版本过低可以去<a href="http://gcc.gnu.org/">http://gcc.gnu.org/</a>下载比较新的</p>
</blockquote>
<p>本人笔记本返回:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">gcc</span> (Ubuntu <span class="number">4</span>.<span class="number">8</span>.<span class="number">4</span>-<span class="number">2</span>ubuntu1~<span class="number">14</span>.<span class="number">04</span>.<span class="number">3</span>) <span class="number">4</span>.<span class="number">8</span>.<span class="number">4</span></span><br><span class="line"><span class="attribute">Copyright</span> (C) <span class="number">2013</span> Free Software Foundation, Inc.</span><br><span class="line"><span class="attribute">This</span> is free software; see the source for copying conditions.  There is NO</span><br><span class="line"><span class="attribute">warranty</span>; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc版本是4.8.4,支持CUDA8.0</p>
</blockquote>
<h4 id="检查是否安装了Kernel-Header"><a href="#检查是否安装了Kernel-Header" class="headerlink" title="检查是否安装了Kernel Header"></a>检查是否安装了Kernel Header</h4><hr>
<p>shell终端输入以下命令查看Kernel版本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r </span><br></pre></td></tr></table></figure>
<p>shell终端输入以下命令安装对应Kernel版本的Kernel Header和Package Development:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">sudo apt-get install linux-headers-<span class="constructor">$(<span class="params">uname</span> -<span class="params">r</span>)</span></span><br></pre></td></tr></table></figure>
<p>至此，Ubuntu14.04上安装CUDA8.0的环境检查完成。</p>
<h3 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h3><hr>
<p>CUDA提供了Package Manager和runfile两种方式进行安装，此处介绍成功率比较高简单的runfile方式安装。</p>
<h4 id="下载最新runfile"><a href="#下载最新runfile" class="headerlink" title="下载最新runfile"></a>下载最新runfile</h4><hr>
<p>根据操作系统及位数在<a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a>选择合适的runfile安装文件下载安装。</p>
<h4 id="禁用nouveau"><a href="#禁用nouveau" class="headerlink" title="禁用nouveau"></a>禁用nouveau</h4><hr>
<p>shell终端输入以下命令查看nouveau是否在运行：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">lsmod <span class="string">| grep nouveau</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>若有输出表示在运行，否则表示没有运行</p>
</blockquote>
<p>若在运行，则需要通过以下方式禁用nouvea，首先在<code>/etc/modeprobe.d</code>路径中创建<code>blacklist-nouveau.config</code>文件，并在文件中加入以下内容：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">option nouveau <span class="attribute">modeset</span>=0</span><br></pre></td></tr></table></figure>
<p>然后在shell终端输入：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo update-initramfs -u</span></span><br></pre></td></tr></table></figure>

<p>再次运行<code>lsmode | grep nouveau</code>检查是否禁用成功</p>
<h4 id="关闭图形化界面进入字符界面安装CUDA"><a href="#关闭图形化界面进入字符界面安装CUDA" class="headerlink" title="关闭图形化界面进入字符界面安装CUDA"></a>关闭图形化界面进入字符界面安装CUDA</h4><hr>
<ol>
<li>重启电脑，在进入登录界面后，按下<code>alt+ctrl+F1</code>进入文本模式(text mode)，登录用户名和密码进入</li>
<li>输入以下命令关闭图形用户界面：<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">sudo service lightdm stop</span><br></pre></td></tr></table></figure></li>
<li>切换到下载的runfile文件路劲，运行：<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">sh</span> cuda_XXX_linux.<span class="keyword">run</span></span><br></pre></td></tr></table></figure></li>
<li>输入以下命令重启图形用户界面：<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">sudo service lightdm <span class="literal">start</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>按照安装提示一步一步的安装，选择yes or no或输入相关路径，最终安装成功会提示intalled, 否则failed。安装过程中注意以下几点:</p>
<ul>
<li>在进行是否安装OpenGL库时候，对于多显卡系统(包含独立NV GPU显卡和集成的Intel或AMD显卡)，<strong>最好选择NO</strong> ，否则会出现黑屏</li>
<li>在提示是否进行nvidia-xconfig替换时候，需要自定义的多显卡X系统配置，<strong>最好选择NO</strong></li>
</ul>
</blockquote>
</li>
</ol>
<p>按下<code>alt+ctrl+F7</code>返回图形界面登录，若登录成功一般表示CUDA安装成功</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><hr>
<p>编辑<code>/etc/profile</code>文件，添加以下两行将cuda相关工具和库加入系统路径：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">export PATH=<span class="regexp">/usr/</span>local<span class="regexp">/cuda-XXX/</span>bin:<span class="variable">$PATH</span>(XXX为安装CUDA版本号)</span><br><span class="line">export LD_LIBRARY_PATH=<span class="regexp">/usr/</span>local<span class="regexp">/cudaXXX/</span>lib64(根据相应的位数选择相应的lib文件)</span><br></pre></td></tr></table></figure>

<p>为了立即生效可以在shell终端输入：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>

<p>最后在shell终端输入：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">env <span class="string">| grep cuda</span></span><br></pre></td></tr></table></figure>

<p>查看环境变量是否设置成功</p>
<h3 id="安装后检查"><a href="#安装后检查" class="headerlink" title="安装后检查"></a>安装后检查</h3><hr>
<h4 id="检查NVIDIA设备驱动是否安装成功"><a href="#检查NVIDIA设备驱动是否安装成功" class="headerlink" title="检查NVIDIA设备驱动是否安装成功"></a>检查NVIDIA设备驱动是否安装成功</h4><hr>
<p>在shell终端输入以下命令查看nvidia设备驱动情况：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat <span class="regexp">/proc/</span>driver<span class="regexp">/nvidia/</span>version</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若返回显示NVIDIA设备驱动版本和Gcc版本则表示安装成功</p>
</blockquote>
<p>本人电脑返回：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">NVRM</span> version: NVIDIA UNIX x86_64 Kernel Module  <span class="number">375</span>.<span class="number">26</span>  Thu Dec  <span class="number">8</span> <span class="number">18</span>:<span class="number">36</span>:<span class="number">43</span> PST <span class="number">2016</span></span><br><span class="line"><span class="attribute">GCC</span> version:  gcc version <span class="number">4</span>.<span class="number">8</span>.<span class="number">4</span> (Ubuntu <span class="number">4</span>.<span class="number">8</span>.<span class="number">4</span>-<span class="number">2</span>ubuntu1~<span class="number">14</span>.<span class="number">04</span>.<span class="number">3</span>) </span><br></pre></td></tr></table></figure>

<p>在shell终端输入以下命令查看nvidia设备文件是否存在：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev | grep -i nvidia</span><br></pre></td></tr></table></figure>

<p>本人电脑返回：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvidia0</span></span><br><span class="line">nvidiactl</span><br><span class="line">nvidia-uvm</span><br><span class="line">nvidia-uvm-tools</span><br></pre></td></tr></table></figure>

<h4 id="检查CUDA-Toolkit是否安装成功"><a href="#检查CUDA-Toolkit是否安装成功" class="headerlink" title="检查CUDA Toolkit是否安装成功"></a>检查CUDA Toolkit是否安装成功</h4><hr>
<p>在shell终端输入以下命令,查看cuda版本： </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvcc -V</span></span><br></pre></td></tr></table></figure>

<p>本人电脑返回：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nvcc</span>: NVIDIA (R) Cuda compiler driver</span><br><span class="line"><span class="attribute">Copyright</span> (c) <span class="number">2005</span>-<span class="number">2016</span> NVIDIA Corporation</span><br><span class="line"><span class="attribute">Built</span> <span class="literal">on</span> Tue_Jan_10_13:<span class="number">22</span>:<span class="number">03</span>_CST_2017</span><br><span class="line"><span class="attribute">Cuda</span> compilation tools, release <span class="number">8</span>.<span class="number">0</span>, V8.<span class="number">0</span>.<span class="number">61</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>cuda版本为8.0 </p>
</blockquote>
<h4 id="检查CUDA-Sample是否可以正常运行"><a href="#检查CUDA-Sample是否可以正常运行" class="headerlink" title="检查CUDA Sample是否可以正常运行"></a>检查CUDA Sample是否可以正常运行</h4><hr>
<p>在CUDA Sample的路径下(默认是安装在用户目录下的NVIDIA_CUDA_XXX_Samples文件夹下),输入：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">make</span> -<span class="function"><span class="title">jX</span>(<span class="variable">X</span>表示系统<span class="variable">CPU</span>核数)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过<code>cat /proc/cpuinfo | grep &quot;processor&quot; | sort -u | wc -l</code>命令查看逻辑cpu数<br>通过<code>cat /proc/cpuinfo | grep &quot;physical id&quot; | sort -u | wc -l</code>命令查看物理cpu数</p>
</blockquote>
<p>在编译生成的<code>NVIDIA_CUDA_XXX_Samples/bin/x86_64/linux/release/</code>目录下运行其中一个sample，如设备查询sample：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若有查询结果打印说明sample运行正常</p>
</blockquote>
<p>本人电脑运行结果为:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/home/franktly/NVIDIA_CUDA-8.0_Samples/bin/x86_64/linux/release/deviceQuery</span> <span class="string">Starting...</span></span><br><span class="line"></span><br><span class="line"> <span class="string">CUDA</span> <span class="string">Device</span> <span class="string">Query</span> <span class="string">(Runtime</span> <span class="string">API)</span> <span class="string">version</span> <span class="string">(CUDART</span> <span class="string">static</span> <span class="string">linking)</span></span><br><span class="line"></span><br><span class="line"><span class="string">Detected</span> <span class="number">1</span> <span class="string">CUDA</span> <span class="string">Capable</span> <span class="string">device(s)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Device 0:</span> <span class="string">&quot;GeForce GT 750M&quot;</span></span><br><span class="line">  <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">Version</span> <span class="string">/</span> <span class="string">Runtime</span> <span class="string">Version</span>          <span class="number">8.0</span> <span class="string">/</span> <span class="number">8.0</span></span><br><span class="line">  <span class="attr">CUDA Capability Major/Minor version number:</span>    <span class="number">3.0</span></span><br><span class="line">  <span class="attr">Total amount of global memory:</span>                 <span class="number">4038 </span><span class="string">MBytes</span> <span class="string">(4233953280</span> <span class="string">bytes)</span></span><br><span class="line">  <span class="string">(</span> <span class="number">2</span><span class="string">)</span> <span class="string">Multiprocessors,</span> <span class="string">(192)</span> <span class="attr">CUDA Cores/MP:</span>     <span class="number">384</span> <span class="string">CUDA</span> <span class="string">Cores</span></span><br><span class="line">  <span class="attr">GPU Max Clock rate:</span>                            <span class="number">1085 </span><span class="string">MHz</span> <span class="string">(1.09</span> <span class="string">GHz)</span></span><br><span class="line">  <span class="attr">Memory Clock rate:</span>                             <span class="number">900</span> <span class="string">Mhz</span></span><br><span class="line">  <span class="attr">Memory Bus Width:</span>                              <span class="number">128</span><span class="string">-bit</span></span><br><span class="line">  <span class="attr">L2 Cache Size:</span>                                 <span class="number">262144</span> <span class="string">bytes</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Texture</span> <span class="string">Dimension</span> <span class="string">Size</span> <span class="string">(x,y,z)</span>         <span class="string">1D=(65536),</span> <span class="string">2D=(65536,</span> <span class="number">65536</span><span class="string">),</span> <span class="string">3D=(4096,</span> <span class="number">4096</span><span class="string">,</span> <span class="number">4096</span><span class="string">)</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Layered</span> <span class="string">1D</span> <span class="string">Texture</span> <span class="string">Size,</span> <span class="string">(num)</span> <span class="string">layers</span>  <span class="string">1D=(16384),</span> <span class="number">2048 </span><span class="string">layers</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Layered</span> <span class="string">2D</span> <span class="string">Texture</span> <span class="string">Size,</span> <span class="string">(num)</span> <span class="string">layers</span>  <span class="string">2D=(16384,</span> <span class="number">16384</span><span class="string">),</span> <span class="number">2048 </span><span class="string">layers</span></span><br><span class="line">  <span class="attr">Total amount of constant memory:</span>               <span class="number">65536</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Total amount of shared memory per block:</span>       <span class="number">49152</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Total number of registers available per block:</span> <span class="number">65536</span></span><br><span class="line">  <span class="attr">Warp size:</span>                                     <span class="number">32</span></span><br><span class="line">  <span class="attr">Maximum number of threads per multiprocessor:</span>  <span class="number">2048</span></span><br><span class="line">  <span class="attr">Maximum number of threads per block:</span>           <span class="number">1024</span></span><br><span class="line">  <span class="string">Max</span> <span class="string">dimension</span> <span class="string">size</span> <span class="string">of</span> <span class="string">a</span> <span class="string">thread</span> <span class="string">block</span> <span class="string">(x,y,z):</span> <span class="string">(1024,</span> <span class="number">1024</span><span class="string">,</span> <span class="number">64</span><span class="string">)</span></span><br><span class="line">  <span class="string">Max</span> <span class="string">dimension</span> <span class="string">size</span> <span class="string">of</span> <span class="string">a</span> <span class="string">grid</span> <span class="string">size</span>    <span class="string">(x,y,z):</span> <span class="string">(2147483647,</span> <span class="number">65535</span><span class="string">,</span> <span class="number">65535</span><span class="string">)</span></span><br><span class="line">  <span class="attr">Maximum memory pitch:</span>                          <span class="number">2147483647</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Texture alignment:</span>                             <span class="number">512</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Concurrent copy and kernel execution:</span>          <span class="literal">Yes</span> <span class="string">with</span> <span class="number">1</span> <span class="string">copy</span> <span class="string">engine(s)</span></span><br><span class="line">  <span class="attr">Run time limit on kernels:</span>                     <span class="literal">No</span></span><br><span class="line">  <span class="attr">Integrated GPU sharing Host Memory:</span>            <span class="literal">No</span></span><br><span class="line">  <span class="attr">Support host page-locked memory mapping:</span>       <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Alignment requirement for Surfaces:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device has ECC support:</span>                        <span class="string">Disabled</span></span><br><span class="line">  <span class="string">Device</span> <span class="string">supports</span> <span class="string">Unified</span> <span class="string">Addressing</span> <span class="string">(UVA):</span>      <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device PCI Domain ID / Bus ID / location ID:</span>   <span class="number">0</span> <span class="string">/</span> <span class="number">1</span> <span class="string">/</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">Compute Mode:</span></span><br><span class="line">     <span class="string">&lt;</span> <span class="string">Default</span> <span class="string">(multiple</span> <span class="string">host</span> <span class="string">threads</span> <span class="string">can</span> <span class="string">use</span> <span class="string">::cudaSetDevice()</span> <span class="string">with</span> <span class="string">device</span> <span class="string">simultaneously)</span> <span class="string">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">deviceQuery,</span> <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">=</span> <span class="string">CUDART,</span> <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">Version</span> <span class="string">=</span> <span class="number">8.0</span><span class="string">,</span> <span class="string">CUDA</span> <span class="string">Runtime</span> <span class="string">Version</span> <span class="string">=</span> <span class="number">8.0</span><span class="string">,</span> <span class="string">NumDevs</span> <span class="string">=</span> <span class="number">1</span><span class="string">,</span> <span class="string">Device0</span> <span class="string">=</span> <span class="string">GeForce</span> <span class="string">GT</span> <span class="string">750M</span></span><br><span class="line"><span class="string">Result</span> <span class="string">=</span> <span class="string">PASS</span></span><br></pre></td></tr></table></figure>
<p>可以看到，通过以上步骤，CUDA Sample运行成功， deviceQuery检测到一个CUDA设备，并打印出其相关属性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>至此CUDA8.0在Ubuntu14.04系统上安装成功，并成功运行CUDA Samples, 后续会陆续具体的介绍CUDA的使用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://developer.nvidia.com/compute/cuda/8.0/Prod2/docs/sidebar/CUDA_Installation_Guide_Linux-pdf">https://developer.nvidia.com/compute/cuda/8.0/Prod2/docs/sidebar/CUDA_Installation_Guide_Linux-pdf</a><br><a href="https://en.wikipedia.org/wiki/CUDA">https://en.wikipedia.org/wiki/CUDA</a><br><a href="https://blog.csdn.net/masa_fish/article/details/51882183">https://blog.csdn.net/masa_fish/article/details/51882183</a></p>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CUDA</tag>
        <tag>HPC</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式(行为型)</title>
    <url>/2017/11/20/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在互联网通信高度发达的今天，大家在过节的时候都是通过QQ或微信来发祝福短信，有时候，由于朋友太多，一个一个的发送消息比较麻烦。幸亏QQ和微信有群发的功能，你只需要选择发送的对象，编辑发送一次信息，其他的所有群里的朋友都可以收到祝福了。通过引入群的机制，将极大减少系统中用户之间的两两通信，用户与用户之间的联系可以通过群来实现。这样的类似“群”一样的中间类来协调这些类&#x2F;对象之间的复杂关系，以降低系统的耦合度的模式就是本篇将要介绍的中介者模式。</p>
<span id="more"></span>

<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><hr>
<p>面向对象设计鼓励将行为分布到各个对象中。这种分布可能会导致对象间有许多连接。在最坏的情况下,每一个对象都知道其他所有对象。可以通过将集体行为封装在一个单独的<strong>中介者</strong>对象中以避免这个问题。中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组中的对象不再相互显式引用。这些对象仅知道中介者, 从而减少了相互连接的数目,符合迪米特法则(最少知道原则)</p>
<blockquote>
<p>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Mediator<br>抽象中介者，定义了一个接口，该接口用于与个同事对象之间进行通信</p>
</li>
<li><p>ConcreteMediator<br>具体中介者，是抽象中介者的子类，通过协调各个同事对象来实现协作行为<br>维持了对个同事对象的引用</p>
</li>
<li><p>Colleague<br>抽象同事类，定义了各个同事类的共有方法，并声明了一些抽象方法来供子类实现<br>维持了一个对抽象中介者的引用，其子类可以通过该引用与中介者通信</p>
</li>
<li><p>ConcreteColleague<br>具体同事类，是抽象同事类的子类，实现了在抽象同事类中声明的抽象方法<br>每个同事对象在需要与其他同事对象通信时候，首先通过中介者通信，再通过中介者间接完成与其他同事类的通信</p>
</li>
</ul>
<blockquote>
<p>中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责:</p>
<ol>
<li>中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用</li>
<li>协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装</li>
</ol>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/11/20/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/Mediator_Abstract.jpg" alt="mediator_common"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象的中介这类<code>Mediator</code>,并提供<code>Notify()</code>接口用于各个同事之间进行通信：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Mediator </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colleague</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mediator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    list&lt;Colleague*&gt; m_listColleague;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AttachColleague</span><span class="params">(Colleague* pColleague)</span>     </span>= <span class="number">0</span>; </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Notify</span><span class="params">(Colleague *pColleague, string msg)</span>  </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义具体中介者类<code>ConcreteMediator</code>，并实现相应的接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Mediator</span></span><br><span class="line"><span class="keyword">class</span> ConcreteMediator : public Mediator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">AttachColleague(Colleague<span class="operator">*</span> <span class="params">pColleague</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_listColleague.push<span class="constructor">_back(<span class="params">pColleague</span>)</span>;  <span class="comment">// 加入需要通信的同事对象</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 指定的Colleague pColleague发送消息（通过Mediator），其他的Colleague接受消息</span></span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Notify(Colleague <span class="operator">*</span><span class="params">pColleague</span>, <span class="params">string</span> <span class="params">msg</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Colleague*&gt;::iterator it = m_listColleague.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != m_listColleague.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">            ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) != pColleague)</span><br><span class="line">            &#123;</span><br><span class="line">                (*it)-&gt;<span class="constructor">RecvMsg(<span class="params">msg</span>)</span>; <span class="comment">// 调用其他同事类的RecvMsg方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.再定义抽象的同事类<code>Colleague</code>，该同事类具有抽象中介者对象的引用，并声明了各个同事子类需要实现的方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Colleague</span></span><br><span class="line"><span class="keyword">class</span> Colleague</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    Mediator* m_pMediator;</span><br><span class="line">    <span class="built_in">string</span> m_Name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Colleague(Mediator<span class="operator">*</span> <span class="params">pMediator</span>, <span class="params">string</span> <span class="params">name</span>)</span>: m<span class="constructor">_pMediator(<span class="params">pMediator</span>)</span>,m<span class="constructor">_Name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">SendMsg(<span class="params">string</span> <span class="params">msg</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RecvMsg(<span class="params">string</span> <span class="params">msg</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="constructor">GetName()</span>         = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.定义两个具体的同事类<code>ConcreteColleagueA</code>及<code>ConcreteColleagueB</code>,实现抽象同事类的相应接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Colleague A</span></span><br><span class="line"><span class="keyword">class</span> ConcreteColleagueA : public Colleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteColleagueA(Mediator<span class="operator">*</span> <span class="params">pMediator</span>, <span class="params">string</span> <span class="params">name</span>)</span>: <span class="constructor">Colleague(<span class="params">pMediator</span>, <span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">SendMsg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot;[CCA] Send Msg: &quot;</span>&lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        m_pMediator-&gt;<span class="constructor">Notify(<span class="params">this</span>, <span class="params">msg</span>)</span>;</span><br><span class="line">        <span class="comment">//(依赖方法)调用中介者的方法，与其他具体同事通信</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RecvMsg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot;[CCA] Recv Msg: &quot;</span>&lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">         <span class="comment">//(自身方法) 处理自己的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="constructor">GetName()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Colleague B</span></span><br><span class="line"><span class="keyword">class</span> ConcreteColleagueB : public Colleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteColleagueB(Mediator<span class="operator">*</span> <span class="params">pMediator</span>, <span class="params">string</span> <span class="params">name</span>)</span>: <span class="constructor">Colleague(<span class="params">pMediator</span>, <span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">SendMsg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot;[CCB] Send Msg: &quot;</span>&lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        m_pMediator-&gt;<span class="constructor">Notify(<span class="params">this</span>, <span class="params">msg</span>)</span>; </span><br><span class="line">        <span class="comment">//(依赖方法)调用中介者的方法，与其他具体同事通信</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">RecvMsg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot;[CCB] Recv Msg: &quot;</span>&lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//(自身方法) 处理自己的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="constructor">GetName()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试中介者模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">MediatorTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    Mediator *pM = <span class="keyword">new</span> <span class="constructor">ConcreteMediator()</span>;</span><br><span class="line"></span><br><span class="line">    Colleague *pCA  = <span class="keyword">new</span> <span class="constructor">ConcreteColleagueA(<span class="params">pM</span>, <span class="string">&quot;Monitor1&quot;</span>)</span>;</span><br><span class="line">    Colleague *pCA2 = <span class="keyword">new</span> <span class="constructor">ConcreteColleagueA(<span class="params">pM</span>, <span class="string">&quot;Monitor2&quot;</span>)</span>;</span><br><span class="line">    Colleague *pCB  = <span class="keyword">new</span> <span class="constructor">ConcreteColleagueB(<span class="params">pM</span>, <span class="string">&quot;Student1&quot;</span>)</span>;</span><br><span class="line">    Colleague *pCB2 = <span class="keyword">new</span> <span class="constructor">ConcreteColleagueB(<span class="params">pM</span>, <span class="string">&quot;Student2&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pM-&gt;<span class="constructor">AttachColleague(<span class="params">pCA</span>)</span>;</span><br><span class="line">    pM-&gt;<span class="constructor">AttachColleague(<span class="params">pCA2</span>)</span>;</span><br><span class="line">    pM-&gt;<span class="constructor">AttachColleague(<span class="params">pCB</span>)</span>;</span><br><span class="line">    pM-&gt;<span class="constructor">AttachColleague(<span class="params">pCB2</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Monitor 1 Send Msg</span></span><br><span class="line">    pCA-&gt;<span class="constructor">SendMsg(<span class="string">&quot;Hello Everyone I am Monitor 1 &quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Monitor 2 Send Msg</span></span><br><span class="line">    pCA2-&gt;<span class="constructor">SendMsg(<span class="string">&quot;Hello Everyone I am Monitor 2 &quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Student 2 Send Msg</span></span><br><span class="line">    pCB-&gt;<span class="constructor">SendMsg(<span class="string">&quot;Hello Everyone I am Student 1&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pM</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCA2</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCB</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCB2</span>)</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6.运行结果：</p>
<pre><code>Monitor1[CCA] Send Msg: Hello Everyone I am Monitor 1
Monitor2[CCA] Recv Msg: Hello Everyone I am Monitor 1
Student1[CCB] Recv Msg: Hello Everyone I am Monitor 1
Student2[CCB] Recv Msg: Hello Everyone I am Monitor 1
Monitor2[CCA] Send Msg: Hello Everyone I am Monitor 2
Monitor1[CCA] Recv Msg: Hello Everyone I am Monitor 2
Student1[CCB] Recv Msg: Hello Everyone I am Monitor 2
Student2[CCB] Recv Msg: Hello Everyone I am Monitor 2
Student1[CCB] Send Msg: Hello Everyone I am Student 1
Monitor1[CCA] Recv Msg: Hello Everyone I am Student 1
Monitor2[CCA] Recv Msg: Hello Everyone I am Student 1
Student2[CCB] Recv Msg: Hello Everyone I am Student 1
</code></pre>
<blockquote>
<ol>
<li>如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现</li>
<li>如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用</li>
</ol>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解</li>
<li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>减少了子类生成，Mediator将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成Meditator的子类即可。这样各个Colleague类可被重用</li>
<li>它将各Colleague解耦，Mediator有利于各Colleague间的松耦合。你可以独立的改变和复用各Colleague类和Mediator类</li>
<li>简化了对象协议，用Mediator和Colleague间的一对多的交互来代替多对多的交互。一对多的关系更容易理解、维护和扩展</li>
<li>对对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的</li>
</ul>
</li>
<li>缺点<ul>
<li>使控制集中化，中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议，它可能变得比任一个Colleague都复杂这可能使得中介者自身成为一个难于维护的庞然大物</li>
</ul>
</li>
</ul>
<h3 id="与外观模式和代理模式及适配器模式及观察者模式的区别"><a href="#与外观模式和代理模式及适配器模式及观察者模式的区别" class="headerlink" title="与外观模式和代理模式及适配器模式及观察者模式的区别"></a>与外观模式和代理模式及适配器模式及观察者模式的区别</h3><p>1.各自定义：</p>
<ul>
<li>中介者模式(行为型)：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</li>
<li>外观模式(结构型)：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</li>
<li>代理模式(结构型)：为其他对象提供一个代理以控制对这个对象的访问</li>
<li>适配器模式(结构型)：将一个类的接口转换成客户希望的另外一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</li>
<li>观察者模式(行为型): 定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并被自动更新</li>
</ul>
<p>2.区别和联系：</p>
<ul>
<li>外观模式与中介者的不同之处在于外观模式是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。它的协议是单向的，即外观对象对这个子系统类提出请求，但反之则不行。相反，中介者提供了各同事对象不支持或不能支持的协作行为，而且协议是多向的</li>
<li>外观模式是对已有的子系统的所有对象的封装，对子系统提供统一的接口是根本目的。</li>
<li>代理模式是一对一，一个代理只能代表一个对象，对已有对象的封装，控制访问是根本目的。中介者模式则是多对多，中介者的功能多样，客户也可以多个</li>
<li>适配器模式也是一对一的，对已有对象的封装，适配是根本目的</li>
<li>观察者模式涉及到两个概念：观察者和目标，解决的是观察者和众多目标之间通信的问题，不是目标之间的通信的问题，应用场景如手机应用给客户推送消息，注意手机应用是目标，顾客是观察者，而不是反之；而中介者模式也设计两个概念：中介和客户，它解决的是客户之间消息传递问题，应用场景如群组和中介所</li>
</ul>
<h2 id="中介者模式具体实例"><a href="#中介者模式具体实例" class="headerlink" title="中介者模式具体实例"></a>中介者模式具体实例</h2><hr>
<h3 id="即时通信群发消息问题"><a href="#即时通信群发消息问题" class="headerlink" title="即时通信群发消息问题"></a>即时通信群发消息问题</h3><p><strong>使用中介者模式简单实现前言所述的群发消息功能</strong></p>
<p><strong>代码实现</strong><br>1.定义抽象中介者类<code>IMGroup</code>,声明同事之间通信的<code>notify()</code>接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IMColleague</span>;</span><br><span class="line"><span class="comment">// instance message abstract mediator class: IMGroup</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IMGroup</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    list&lt;IMColleague*&gt; _listColleague; <span class="comment">// 子类使用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attachColleague</span><span class="params">(IMColleague* colleague)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 关联同事对象，子类不需要重写</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _listColleague.<span class="built_in">push_back</span>(colleague);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">(IMColleague* sender, string msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别定义两个具体的中介者类<code>WeiXinIMGroup</code>和<code>QQIMGroup</code>,并实现同事之间通信的<code>notify()</code>接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instance message weixin mediator class: WeiXinIMGroup</span></span><br><span class="line"><span class="keyword">class</span> WeiXinIMGroup : public IMGroup</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void notify(IMColleague* sender, <span class="built_in">string</span> msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;IMColleague*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listColleague</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != <span class="module-access"><span class="module"><span class="identifier">_listColleague</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sender != *it) <span class="comment">// 发送者不需要接收消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;[Wei Xin Notify:] &quot;</span>;</span><br><span class="line">                (*it)-&gt;recv<span class="constructor">Msg(<span class="params">msg</span>)</span>;</span><br><span class="line">                <span class="comment">//调用其他同事类的接收消息方法，通过中介者（群）来通知其他同事接收消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance message qq mediator class: QQIMGroup</span></span><br><span class="line"><span class="keyword">class</span> QQIMGroup : public IMGroup</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void notify(IMColleague* sender, <span class="built_in">string</span> msg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;IMColleague*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listColleague</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != <span class="module-access"><span class="module"><span class="identifier">_listColleague</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sender != *it) <span class="comment">// 发送者不需要接收消息</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;[QQ Notify:] &quot;</span>;</span><br><span class="line">                (*it)-&gt;recv<span class="constructor">Msg(<span class="params">msg</span>)</span>; </span><br><span class="line">                <span class="comment">//调用其他同事类的接收消息方法，通过中介者（群）来通知其他同事接收消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.定义抽象的同事类<code>IMColleague</code>,声明发送接口<code>sendMsg()</code>和接受消息接口<code>recvMsg()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instance message abstract colleage class: IMColleague</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">IMColleague</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    IMGroup *_groupMediator; <span class="comment">// 子类使用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    IMColleague(IMGroup *mediator) : _groupMediator(mediator) &#123;&#125;; </span><br><span class="line">    <span class="comment">//构造注入中介者对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">setIMGroup</span>(<span class="params">IMGroup *mediator</span>) </span></span><br><span class="line"><span class="function">    <span class="comment">//客户端手动注入中介者对象，子类不需要重写</span></span></span><br><span class="line">    &#123; </span><br><span class="line">        _groupMediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sendMsg</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span> = <span class="number">0</span>; <span class="comment">//dependon method</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">recvMsg</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span> = <span class="number">0</span>; <span class="comment">// self method</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.分别定义具体的朋友类<code>FriendIMColleage</code>及亲戚类<code>RelativeIMColleage</code>,实现发送接口<code>sendMsg()</code>和接受消息接口<code>recvMsg()</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instance message friend colleage class: FriendIMColleage</span></span><br><span class="line"><span class="keyword">class</span> FriendIMColleage : public IMColleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">FriendIMColleage(IMGroup <span class="operator">*</span><span class="params">mediator</span>)</span> : <span class="constructor">IMColleague(<span class="params">mediator</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void send<span class="constructor">Msg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Friend IM Colleage send msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        _groupMediator-&gt;notify(this, msg); <span class="comment">//  调用中介者对象通知其他同事</span></span><br><span class="line">    &#125;</span><br><span class="line">    void recv<span class="constructor">Msg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Friend IM Colleage recv msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// instance message friend colleage class: RelativeIMColleage</span></span><br><span class="line"><span class="keyword">class</span> RelativeIMColleage : public IMColleague</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">RelativeIMColleage(IMGroup <span class="operator">*</span><span class="params">mediator</span>)</span> : <span class="constructor">IMColleague(<span class="params">mediator</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void send<span class="constructor">Msg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Relative IM Colleage send msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        _groupMediator-&gt;notify(this, msg); <span class="comment">//  调用中介者对象通知其他同事</span></span><br><span class="line">    &#125;</span><br><span class="line">    void recv<span class="constructor">Msg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Relative IM Colleage recv msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试中介者器模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">MediatorTest_IMCommunication()</span></span><br><span class="line">&#123;</span><br><span class="line">    IMGroup *weixin_mediator = <span class="keyword">new</span> <span class="constructor">WeiXinIMGroup()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化设置im_friend_a,im_friend_b,im_relative同事类的中介者为weixin</span></span><br><span class="line">    IMColleague *im_friend_a = <span class="keyword">new</span> <span class="constructor">FriendIMColleage(<span class="params">weixin_mediator</span>)</span>;</span><br><span class="line">    IMColleague *im_friend_b = <span class="keyword">new</span> <span class="constructor">FriendIMColleage(<span class="params">weixin_mediator</span>)</span>;</span><br><span class="line">    IMColleague *im_relative = <span class="keyword">new</span> <span class="constructor">RelativeIMColleage(<span class="params">weixin_mediator</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将im_friend_a,im_friend_b,im_relative加入到weixin_mediator的list中：</span></span><br><span class="line">    weixin_mediator-&gt;attach<span class="constructor">Colleague(<span class="params">im_friend_a</span>)</span>;</span><br><span class="line">    weixin_mediator-&gt;attach<span class="constructor">Colleague(<span class="params">im_friend_b</span>)</span>;</span><br><span class="line">    weixin_mediator-&gt;attach<span class="constructor">Colleague(<span class="params">im_relative</span>)</span>;</span><br><span class="line"></span><br><span class="line">    im_relative-&gt;send<span class="constructor">Msg(<span class="string">&quot;happy new year!!!&quot;</span>)</span>; <span class="comment">// im_friend_a、im_friend_b均能收到</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设置im_friend_a,im_relative同事类的中介者为qq,而im_friend_b中介者仍为weixin</span></span><br><span class="line">    IMGroup *qq_mediator = <span class="keyword">new</span> <span class="constructor">QQIMGroup()</span>;</span><br><span class="line">    im_friend_a-&gt;set<span class="constructor">IMGroup(<span class="params">qq_mediator</span>)</span>;</span><br><span class="line">    im_relative-&gt;set<span class="constructor">IMGroup(<span class="params">qq_mediator</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将im_friend_a,im_relative加入到qq_mediator的list中：</span></span><br><span class="line">    qq_mediator-&gt;attach<span class="constructor">Colleague(<span class="params">im_friend_a</span>)</span>;</span><br><span class="line">    qq_mediator-&gt;attach<span class="constructor">Colleague(<span class="params">im_relative</span>)</span>;</span><br><span class="line">    im_relative-&gt;send<span class="constructor">Msg(<span class="string">&quot;happy birthday!!!&quot;</span>)</span>;  <span class="comment">// 只有im_friend_a能收到</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6.运行结果:</p>
<pre><code>Relative IM Colleage send msg: happy new year!!!
[Wei Xin Notify:] Friend IM Colleage recv msg: happy new year!!!
[Wei Xin Notify:] Friend IM Colleage recv msg: happy new year!!!
Relative IM Colleage send msg: happy birthday!!!
[QQ Notify:] Friend IM Colleage recv msg: happy birthday!!!
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式(结构型)</title>
    <url>/2018/05/15/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>最近的Google AlphaGo大战李世石的围棋人机大战很火，虽然人类最终败北，但是正如Google执行董事施密特所说：“不管输赢，都是人类的巨大的胜利”。如果想自己设计一个围棋软件程序，你会发现,围棋中存在着大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需内存空间较大，为了解决这个问题，可以考虑使用对象共享复用模式—享元模式来设计该围棋软件的棋子对象。</p>
<span id="more"></span>

<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><hr>
<p>享元模式,该模式通过共享技术实现相同或相似对象的重用。如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用较多的内存空间，那么我们如何去避免系统中出现大量相同或相似的对象呢？享元模式正为解决这一类问题而诞生。<strong>在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例</strong>。在享元模式中，存储这些共享实例对象的地方称为<strong>享元池</strong>。我们可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，需要时再从享元池取出</p>
<blockquote>
<p>享元模式以共享的方式支持大量细粒度对象的重用，享元对象使用的关键是区分对象内部状态和外部状态<br><strong>内部状态</strong>是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享<br><strong>外部状态</strong>是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入到享元对象内部<br>区分了内部状态和外部状态，我们可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p>
<blockquote>
<p>由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Flyweight<br>描述一个接口，通过这个接口flyweight可以接受并作用于外部状态</p>
</li>
<li><p>ConcreteFlyweight<br>实现Flyweight接口，并为内部状态(如果有的话)增加存储空间<br>ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的，即必须独立于ConcreteFlyweight对象的场景</p>
</li>
<li><p>UnsharedConcreteFlyweight<br>并非所有的Flyweight子类都需要被共享。Flyweight接口使共享成为可能，但它并不强制共享<br>在Flyweight对象结构的某些层次，UnsharedConcreteFlyweight对象通常将ConcreteFlyweight对象作为子节点</p>
</li>
<li><p>FlyweightFactory<br>创建并管理flyweight对象<br>确保合理地共享flyweight。当用户请求一个flyweight时，FlyweightFactory对象提供一个已创建的实例或者创建一个(如果不存在的话)</p>
</li>
<li><p>Client<br>维持一个对flyweight的引用<br>计算或存储一个或多个Flyweight的外部状态</p>
</li>
</ul>
<blockquote>
<p>flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于<code>ConcreteFlyweight</code>对象之中;而外部对象则由client对象存储或计算。当用户调用<code>Flyweight</code>对象的操作时，将该状态传递给它<br>用户不应直接对<code>ConcreteFlyweight</code>类进行实例化，而只能从<code>FlyweightFactory</code>对象得到<br><code>ConcreteFlyweight</code>对象，这可以保证对它们适当地进行共享</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/05/15/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/Flyweight.jpg" alt="flyweight"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义抽象的<code>Flyweight</code>,并提供<code>Operate()</code>接口，接受外部状态：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Flyweight抽象类</span></span><br><span class="line"><span class="keyword">class</span> Flyweight</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 内部状态，也可以放在ConcreteFlyweight中</span></span><br><span class="line">    <span class="built_in">string</span> _intraState;</span><br><span class="line">protected:</span><br><span class="line">    <span class="constructor">Flyweight(<span class="params">string</span> <span class="params">intraState</span>)</span> : <span class="constructor">_intraState(<span class="params">intraState</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//操作外部状态extraState</span></span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Operate(<span class="params">const</span> <span class="params">string</span>&amp; <span class="params">extraState</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Flyweight()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 内部状态回读接口，也可以放在ConcreteFlyweight中</span></span><br><span class="line">    <span class="built_in">string</span> get<span class="constructor">IntraState(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _intraState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再分别定义<code>Flyweight</code>类的两个子类，共享的<code>ConcreteFlyweight</code>类和非共享的 <code>UnsharedConcreteFlyweight</code>类，并分别实现其<code>Operate()</code>接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共享Flyweight的具体子类</span></span><br><span class="line"><span class="keyword">class</span> ConcreteFlyweight : public Flyweight</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteFlyweight(<span class="params">string</span> <span class="params">intraState</span>)</span> : <span class="constructor">Flyweight(<span class="params">intraState</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Operate(<span class="params">const</span> <span class="params">string</span>&amp; <span class="params">extraState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;concrete flyweight intraState: &quot;</span> &lt;&lt;  get<span class="constructor">IntraState()</span> &lt;&lt; endl; <span class="comment">// intra state &amp; extra state</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;concrete flyweight extraState: &quot;</span> &lt;&lt;  extraState &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">ConcreteFlyweight()</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非共享Flyweight的具体子类</span></span><br><span class="line"><span class="keyword">class</span> UnsharedConcreteFlyweight : public Flyweight</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">UnsharedConcreteFlyweight(<span class="params">string</span> <span class="params">intraState</span>)</span> : <span class="constructor">Flyweight(<span class="params">intraState</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Operate(<span class="params">const</span> <span class="params">string</span>&amp; <span class="params">extraState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;UnsharedConcrete flyweight extraState: &quot;</span> &lt;&lt; extraState &lt;&lt; endl; <span class="comment">// only extra state</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">UnsharedConcreteFlyweight()</span> &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>Flyweight</code>的工厂类，对于共享和非共享分别提供一个获取对象实例的接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flyweight工厂类，若该对象已存在，直接返回该对象，否则新建一个对象，存入容器中，再返回</span></span><br><span class="line"><span class="keyword">class</span> FlyweightFactory</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//保存内部状态的flyweight对象容器</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Flyweight*&gt; _vecFlyweight;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">FlyweightFactory()</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 获取可共享的flyweight，从共享pool中获取</span></span><br><span class="line">    Flyweight* get<span class="constructor">ConcreteFlyweight(<span class="params">const</span> <span class="params">string</span>&amp; <span class="params">key</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Flyweight*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_vecFlyweight</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span> (; it != <span class="module-access"><span class="module"><span class="identifier">_vecFlyweight</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it)-&gt;get<span class="constructor">IntraState()</span><span class="operator"> == </span>key) <span class="comment">//根据内部状态索引,若存在，直接返回该对象</span></span><br><span class="line">            &#123;</span><br><span class="line">                return *it; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Flyweight* newFlyweight = <span class="keyword">new</span> <span class="constructor">ConcreteFlyweight(<span class="params">key</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_vecFlyweight</span>.</span></span>push<span class="constructor">_back(<span class="params">newFlyweight</span>)</span>;</span><br><span class="line">        return newFlyweight;           <span class="comment">//若不存在，则创建之并存入flyweight容器，返回该对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">ConcreteFlyweightCount(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">_vecFlyweight</span>.</span></span>size<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取不可共享的flyweight，直接创建并返回</span></span><br><span class="line">    Flyweight* get<span class="constructor">UnsharedConcreteFlyweight(<span class="params">const</span> <span class="params">string</span>&amp; <span class="params">key</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">UnsharedConcreteFlyweight(<span class="params">key</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试享元模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">FlyweightAbstractTest()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// factory</span></span><br><span class="line">    FlyweightFactory *factory = <span class="keyword">new</span> <span class="constructor">FlyweightFactory()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//shared flyweight</span></span><br><span class="line">    Flyweight *concreteFlyweight = factory-&gt;get<span class="constructor">ConcreteFlyweight(<span class="string">&quot;shared intra state&quot;</span>)</span>;</span><br><span class="line">    Flyweight *concreteFlyweight2 = factory-&gt;get<span class="constructor">ConcreteFlyweight(<span class="string">&quot;shared intra state&quot;</span>)</span>; <span class="comment">// the same, return obj directly                                                                                        // extra state</span></span><br><span class="line">    const <span class="built_in">string</span> extraState1 = <span class="string">&quot;extra1&quot;</span>;</span><br><span class="line">    const <span class="built_in">string</span> extraState2 = <span class="string">&quot;extra2&quot;</span>;</span><br><span class="line">    concreteFlyweight-&gt;<span class="constructor">Operate(<span class="params">extraState1</span>)</span>;</span><br><span class="line">    concreteFlyweight2-&gt;<span class="constructor">Operate(<span class="params">extraState2</span>)</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;flyweight container size :&quot;</span> &lt;&lt; factory-&gt;get<span class="constructor">ConcreteFlyweightCount()</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unshared flyweight</span></span><br><span class="line">    const <span class="built_in">string</span> extraState3 = <span class="string">&quot;extra3&quot;</span>;</span><br><span class="line">    Flyweight *unsharedConcreteFlyweight = factory-&gt;get<span class="constructor">UnsharedConcreteFlyweight(<span class="string">&quot;no shared intra state&quot;</span>)</span>;</span><br><span class="line">    unsharedConcreteFlyweight-&gt;<span class="constructor">Operate(<span class="params">extraState3</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>concrete flyweight intraState: shared intra state
concrete flyweight extraState: extra1
concrete flyweight intraState: shared intra state
concrete flyweight extraState: extra2
flyweight container size :1
UnsharedConcrete flyweight extraState: extra3
</code></pre>
<h3 id="享元模式的分类"><a href="#享元模式的分类" class="headerlink" title="享元模式的分类"></a>享元模式的分类</h3><p>标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式。</p>
<h4 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h4><p>在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。模式图如：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FSimple_Flyweight.PNG" alt="simple_flyweight"></p>
<h4 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h4><p>将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。模式图如：<br><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FComposite_Flyweight.PNG" alt="composite_flyweight"></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中</li>
<li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式</li>
<li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li>
</ul>
<blockquote>
<p>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象<br>在一个系统中，通常只有唯一一个享元工厂，因此可以使用单例模式进行享元工厂类的设计<br>享元模式可以结合组合模式形成复合享元模式，统一对多个享元对象设置外部状态</p>
</blockquote>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享</li>
<li>如果能发现这些实例数据除了几个参数外基本都是相同的，使用享元模式就可以大幅度地减少对象的数量</li>
</ul>
</li>
<li>缺点<ul>
<li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长</li>
</ul>
</li>
</ul>
<h2 id="享元模式具体实例"><a href="#享元模式具体实例" class="headerlink" title="享元模式具体实例"></a>享元模式具体实例</h2><hr>
<h3 id="围棋程序"><a href="#围棋程序" class="headerlink" title="围棋程序"></a>围棋程序</h3><p><strong>使用享元模式简单的实现前言说描述的围棋棋子</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>首先分别定义棋子的外部属性(Position)和内部属性(Color):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 棋子位置 (extra state)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Position</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Position</span>(<span class="type">int</span> a, <span class="type">int</span> b): <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Position</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//棋子的颜色(intra state) Key</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">tag_Color</span></span><br><span class="line">&#123;</span><br><span class="line">    BLACK,</span><br><span class="line">    WHITE</span><br><span class="line">&#125;COLOR;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义抽象棋子类,包含内部属性(Color),和操作<code>DrawPiece(Position &amp;pos)</code>,传入外部状态对象引用:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象棋子类(Abstract Flyweight)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Piece</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    COLOR    m_Color;  <span class="comment">// intra state</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Piece(COLOR color): m_Color(color) &#123;&#125;; <span class="comment">// only color </span></span><br><span class="line">    <span class="keyword">virtual</span> ~Piece() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> COLOR <span class="title">GetColor</span>()  <span class="comment">// intra state</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_Color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawPiece</span>(<span class="params">Position &amp;pos</span>)</span> = <span class="number">0</span>; <span class="comment">// operate(extra state)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别定义具体的黑棋子和白棋子类，分别实现其操作：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体黑棋子类(Concrete Flyweight)</span></span><br><span class="line"><span class="keyword">class</span> BlackPiece : public Piece</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">BlackPiece()</span> : <span class="constructor">Piece(BLACK)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">BlackPiece()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">DrawPiece(Position &amp;<span class="params">pos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Draw A Black Piece, Position is:&quot;</span> &lt;&lt; <span class="string">&quot;X:&quot;</span> &lt;&lt; pos.get<span class="constructor">X()</span> &lt;&lt; <span class="string">&quot; Y:&quot;</span> &lt;&lt; pos.get<span class="constructor">Y()</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体白棋子类(Concrete Flyweight)</span></span><br><span class="line"><span class="keyword">class</span> WhitePiece : public Piece</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">WhitePiece()</span> : <span class="constructor">Piece(WHITE)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">WhitePiece()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">DrawPiece(Position &amp;<span class="params">pos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Draw A White Piece, Position is:&quot;</span> &lt;&lt; <span class="string">&quot;X:&quot;</span> &lt;&lt; pos.get<span class="constructor">X()</span> &lt;&lt; <span class="string">&quot; Y:&quot;</span> &lt;&lt; pos.get<span class="constructor">Y()</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义棋子工厂类，来提供黑和白棋子</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 棋子工厂类，提供生产白色、黑色棋子 (Flyweight Factory)</span></span><br><span class="line"><span class="keyword">class</span> PieceFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 棋子容器（享元池）</span></span><br><span class="line">    vector&lt;Piece*&gt; m_vecPiece;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">PieceFactory()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">PieceFactory()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;Piece*&gt;::iterator it = m_vecPiece.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_vecPiece.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NULL != (*it))</span><br><span class="line">            &#123;</span><br><span class="line">                delete *it;</span><br><span class="line">                *it = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Piece* <span class="constructor">CreateAndAddPiece(COLOR <span class="params">color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Piece *pRes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WHITE<span class="operator"> ==  </span>color)</span><br><span class="line">        &#123;</span><br><span class="line">            pRes = <span class="keyword">new</span> <span class="constructor">WhitePiece()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (BLACK<span class="operator"> == </span>color)</span><br><span class="line">        &#123;</span><br><span class="line">            pRes = <span class="keyword">new</span> <span class="constructor">BlackPiece()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_vecPiece.push<span class="constructor">_back(<span class="params">pRes</span>)</span>;</span><br><span class="line"></span><br><span class="line">        return pRes;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    Piece* <span class="constructor">GetPiece(COLOR <span class="params">color</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">// 若不为空，则判断vector容器里面是否有给定颜色的Piece</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;Piece*&gt;::iterator it = m_vecPiece.<span class="keyword">begin</span><span class="literal">()</span>; </span><br><span class="line">             it != m_vecPiece.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (color<span class="operator"> == </span>(*it)-&gt;<span class="constructor">GetColor()</span>) <span class="comment">// 找到了给定颜色的Piece</span></span><br><span class="line">            &#123;</span><br><span class="line">                return (*it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  若未空，则new一个Piece， 并添加Piece</span></span><br><span class="line">        return <span class="constructor">CreateAndAddPiece(<span class="params">color</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试棋子享元模式：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void FlyweightPieceTest()</span><br><span class="line">&#123;</span><br><span class="line">    PieceFactory *pPF = new PieceFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Player 1 get a white piece from the pieces bowl</span></span><br><span class="line">    P<span class="function"><span class="title">iece</span>       *pWP_1 = pPF-&gt;</span>GetPiece(WHITE);</span><br><span class="line">    <span class="function"><span class="title">pWP_1</span>-&gt;</span>DrawPiece(Position(<span class="number">1</span>,<span class="number">10</span>)); <span class="comment">// new a white piece, set pos = 1,10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Player 2 get a black piece from the pieces bowl</span></span><br><span class="line">    P<span class="function"><span class="title">iece</span>       *pBP_1 = pPF-&gt;</span>GetPiece(BLACK); <span class="comment">// new a black piece , set pos = 1,20</span></span><br><span class="line">    <span class="function"><span class="title">pBP_1</span>-&gt;</span>DrawPiece(Position(<span class="number">1</span>,<span class="number">20</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Player 1 get a white piece from the pieces bowl</span></span><br><span class="line">    P<span class="function"><span class="title">iece</span>       *pWP_2 = pPF-&gt;</span>GetPiece(WHITE); <span class="comment">// get the existing white piece, but set pos = 2,10</span></span><br><span class="line">    <span class="function"><span class="title">pWP_2</span>-&gt;</span>DrawPiece(Position(<span class="number">2</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Player 2 get a black piece from the pieces bowl</span></span><br><span class="line">    P<span class="function"><span class="title">iece</span>       *pBP_2 = pPF-&gt;</span>GetPiece(BLACK); <span class="comment">// get the existing a black piece , but set pos = 2,20</span></span><br><span class="line">    <span class="function"><span class="title">pBP_2</span>-&gt;</span>DrawPiece(Position(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NULL != pPF)</span><br><span class="line">    &#123;</span><br><span class="line">        delete pPF; pPF = NULL;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果：</p>
<p> Draw A White Piece, Position is:X:1 Y:10<br> Draw A Black Piece, Position is:X:1 Y:20<br> Draw A White Piece, Position is:X:2 Y:10<br> Draw A Black Piece, Position is:X:2 Y:20</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式(结构型)</title>
    <url>/2018/06/01/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在一个陌生的城市找房子住的时候，一般都需要通过房产中介或者熟人介绍的方式来找房子。这个第三方的角色相当于代理的角色，负责代理真实的房东或业主来给我们提供相关的租房信息，而不需要我们直接与房东接触。同时，而为了安全性，一般代理还会让我们进行身份验证，同时为了方便租户管理，他们还会记录相关的租户信息。这里的第三方角色就是本文将要介绍的代理模式中的代理对象。</p>
<span id="more"></span>

<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><hr>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>为其他对象提供一种代理以控制对这个对象的访问</p>
<blockquote>
<p>常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Proxy<br>保存一个引用使得代理可以访问实体，若RealSubject和Subject的接口相同，Proxy会引用Subject<br>提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体<br>控制对实体的存取，并可能负责创建和删除它</p>
</li>
<li><p>Subject<br>定义RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。</p>
</li>
<li><p>RealSubject<br>定义Proxy所代表的实体</p>
</li>
</ul>
<blockquote>
<p>代理根据其种类，在适当的时候向RealSubject转发请求</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/06/01/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/Proxy.jpg" alt="proxy"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象的<code>Subject</code>,并提供<code>Request()</code>接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base Common Interface of RealSubject &amp; Proxy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Subject() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Subject() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再分别定义<code>Subject</code>类的两个子类，真实的被代理的对象类<code>RealSubject</code>和代理类<code>Proxy</code>类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RealSubject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RealSubject</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">RealSubject</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Real Subject Request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> : <span class="keyword">public</span> Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RealSubject *m_pRealSubject;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Proxy</span>(Subject *pSubject) : <span class="built_in">m_pRealSubject</span>(pSubject) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Proxy</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != m_pRealSubject)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Proxy Request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            m_pRealSubject-&gt;<span class="built_in">Request</span>(); <span class="comment">// 调用真实对象类RealSubject的方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试代理模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProxyTest_General</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subject *pRS = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();</span><br><span class="line">    Subject *pPS = <span class="keyword">new</span> <span class="built_in">Proxy</span>(pRS);</span><br><span class="line">    pPS-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pRS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pRS; pRS = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pPS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pPS; pPS = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果：</p>
<pre><code>Proxy Request !
Real Subject Request !
</code></pre>
<h3 id="代理模式的分类"><a href="#代理模式的分类" class="headerlink" title="代理模式的分类"></a>代理模式的分类</h3><p>代理模式根据其使用场景可以分为以下几类：</p>
<h4 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h4><p>可以隐藏一个对象存在于不同地址空间的事实，负责对请求及其参数进行编码，并向不同地址空间中的实体发送已编码的请求<br>它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用</p>
<blockquote>
<p>为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率</p>
</blockquote>
<h4 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h4><p>可以缓存实体的附加信息，以便延迟对它的访问<br>对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象</p>
<blockquote>
<p>通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</p>
</blockquote>
<h4 id="缓冲代理"><a href="#缓冲代理" class="headerlink" title="缓冲代理"></a>缓冲代理</h4><p>为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间</p>
<h4 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h4><p>检查调用者是否具有实现一个请求所必需的访问权限</p>
<blockquote>
<p>可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限</p>
</blockquote>
<h4 id="引用计数代理"><a href="#引用计数代理" class="headerlink" title="引用计数代理"></a>引用计数代理</h4><p>允许在访问一个对象时有一些附加的内务处理</p>
<blockquote>
<p>可以对一个对象的访问(引用)提供一些额外的操作</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>当客户端对象需要访问远程主机中的对象时可以使用<strong>远程代理</strong></li>
<li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用<strong>虚拟代理</strong>，例如一个对象需要很长时间才能完成加载时</li>
<li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用<strong>缓冲代理</strong>。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可</li>
<li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用<strong>保护代理</strong></li>
<li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用<strong>智能引用代理</strong></li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>
<li>不同类型的代理模式也具有其特有的优点</li>
</ul>
</li>
</ul>
<h3 id="与适配器模式-amp-装饰器模式的区别"><a href="#与适配器模式-amp-装饰器模式的区别" class="headerlink" title="与适配器模式&amp;装饰器模式的区别"></a>与适配器模式&amp;装饰器模式的区别</h3><ul>
<li>适配器Adapter为它所适配的对象提供了一个不同的接口。相反，代理提供了与它的实体相同的接口。然而，用于访问保护的代理可能会拒绝执行实体会执行的操作，因此，它的接口实际上可能只是实体接口的一个子集</li>
<li>尽管Decorator的实现部分与代理相似，但Decorator的目的不一样。Decorator为对象添加一个或多个功能，而代理则控制对对象的访问</li>
</ul>
<h2 id="代理模式具体实例"><a href="#代理模式具体实例" class="headerlink" title="代理模式具体实例"></a>代理模式具体实例</h2><hr>
<h3 id="租房问题"><a href="#租房问题" class="headerlink" title="租房问题"></a>租房问题</h3><p><strong>使用代理模式简单实现前言所述的过程</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>1.定义抽象的<code>AbstractRenter</code>类，并提供<code>rent</code>接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract rent class </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractRenter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">rent</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别实现<code>AbstractRenter</code>的子类<code>RealRenter</code>及<code>ProxyRenter</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// real renter == house owner</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealRenter</span> : <span class="keyword">public</span> <span class="title class_">AbstractRenter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">rent</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i have a house to rent, please contact me if you need!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy renter == house proxy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyRenter</span> : <span class="keyword">public</span> <span class="title class_">AbstractRenter</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="title class_">RealRenter</span> _renter;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">ProxyRenter</span>(<span class="title class_">RealRenter</span> &amp;renter) : <span class="title function_">_renter</span>(<span class="params">renter</span>) &#123;&#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">rent</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">validId</span>();</span><br><span class="line">        _renter.<span class="title function_">rent</span>();</span><br><span class="line">        <span class="title function_">logHouseUser</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">validId</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;please valid your identification&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">logHouseUser</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;log the house user information&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.测试代理模式:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Proxy_Test_Renter</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RealRenter  realRenter;</span><br><span class="line">    <span class="function">ProxyRenter <span class="title">proxyRenter</span><span class="params">(realRenter)</span></span>;</span><br><span class="line">    AbstractRenter &amp;pR = proxyRenter;</span><br><span class="line">    pR.<span class="built_in">rent</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果:</p>
<pre><code>please valid your identification
i have a house to rent, please contact me if you need!
log the house user information
</code></pre>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p><strong>使用智能引用计数代理模式实现智能指针功能</strong></p>
<blockquote>
<p>作用: 为了解决“被异常抛出时发生资源泄漏”的问题<br>原理：资源在局部对象构造时分配，在局部对象析构时释放。这样即使在函数执行过程时发生异常退出，也会因为异常能保证局部对象被析构从而保证资源被释放</p>
</blockquote>
<blockquote>
<p>auto_ptr析构的时候肯定会删除他所拥有的那个对象，所有我们就要注意了，一个萝卜一个坑，两个auto_ptr不能同时拥有同一个对象,在析构时都试图删除p两次删除同一个对象的行为在C++标准中是未定义的<br>不能用auto_ptr来管理一个数组指针，因为auto_ptr的析构函数中删除指针用的是delete,而不是delete []<br>构造函数的explicit关键词有效阻止从一个“裸”指针隐式转换成auto_ptr类型<br>auto_ptr只是一种简单的智能指针，如有特殊需求，需要使用其他智能指针，比如share_ptr<br>auto_ptr不能作为容器对象，STL容器中的元素经常要支持拷贝，赋值等操作，在这过程中auto_ptr会传递所有权，那么source与sink元素之间就不等价了</p>
</blockquote>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>1.C++ STL智能指针（auto_ptr)的简单实现Smart_Ptr:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//Smart_Ptr类就是一个代理，客户只需操作Smart_Ptr的对象，而不需要与被代理的指针m_ptr打交道</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Smart_Ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Construction </span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Smart_Ptr</span><span class="params">(T* ptr = <span class="number">0</span>)</span> : m_ptr(ptr) &#123;</span>&#125;;  <span class="comment">// forbide implict convert</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Smart_Ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reset</span>(); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Copy Construction </span></span><br><span class="line">    <span class="comment">// not const input para , for its m_ptr changed</span></span><br><span class="line">    <span class="comment">// release rhs&#x27;s proxy control </span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Smart_Ptr</span>(Smart_Ptr &amp;rhs) : <span class="built_in">m_ptr</span>(rhs.<span class="built_in">release</span>()) &#123;&#125;; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//Assignment</span></span><br><span class="line">    Smart_Ptr&amp; <span class="keyword">operator</span> = (Smart_Ptr &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// first release rhs&#x27;s proxy control; secode reset to this&#x27;s proxy control; thirdly return this</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">reset</span>(rhs.<span class="built_in">release</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T* <span class="keyword">operator</span> -&gt;() <span class="type">const</span> <span class="comment">// 类成员函数为const ，防止更改类成员</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span> *() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Release Ownership</span></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T* <span class="title">tmp</span><span class="params">(m_ptr)</span></span>; <span class="comment">// tmp = m_ptr;</span></span><br><span class="line">        m_ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Reset Ownership: copy ptr to m_ptr,</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(T* ptr = <span class="number">0</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_ptr != ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_ptr;</span><br><span class="line">            m_ptr = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.测试Smart_Ptr代理模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">Proxy_Test_SmartPtr()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// UD-SmartPtr Test:</span></span><br><span class="line">    <span class="built_in">int</span> *p =  <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//  Smart_Ptr&lt;int&gt; sp_int_1(p); //  构造int(10)返回指针的代理sp_int</span></span><br><span class="line">    Smart_Ptr&lt;<span class="built_in">int</span>&gt; sp<span class="constructor">_int_2(<span class="params">p</span>)</span>;  <span class="comment">// sp_int_1 失去p控制权</span></span><br><span class="line">    Smart_Ptr&lt;<span class="built_in">int</span>&gt; sp_int_3 = sp_int_2; <span class="comment">//  sp_int_1,2 均失去p控制权</span></span><br><span class="line">    Smart_Ptr&lt;<span class="built_in">int</span>&gt; sp<span class="constructor">_int_4(<span class="params">sp_int_3</span>)</span>; <span class="comment">//  sp_int_1,2,3 均失去p控制权</span></span><br><span class="line"><span class="comment">//  cout &lt;&lt; &quot;User Defined Smart_Ptr: sp_int1 value is &quot; &lt;&lt; *sp_int_1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//  cout &lt;&lt; &quot;User Defined Smart_Ptr: sp_int2 value is &quot; &lt;&lt; *sp_int_2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//  cout &lt;&lt; &quot;User Defined Smart_Ptr: sp_int3 value is &quot; &lt;&lt; *sp_int_3 &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;User Defined Smart_Ptr: sp_int4 value is &quot;</span> &lt;&lt; *sp_int_4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL-AutoPtr Test:</span></span><br><span class="line">    <span class="built_in">string</span> *p2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>);   </span><br><span class="line">    auto_ptr&lt;<span class="built_in">string</span>&gt; ap<span class="constructor">_string_1(<span class="params">p2</span>)</span>;;  <span class="comment">// STL 标准库 auto_ptr</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;STL Smart_Ptr: ap_string_1 value is &quot;</span> &lt;&lt; *ap_string_1 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.运行结果：</p>
<pre><code>User Defined Smart_Ptr: sp_int4 value is 10
STL Smart_Ptr: ap_string_1 value is Hello
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式(创建型)</title>
    <url>/2017/11/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>有很多时候，为了节约系统资源需要确保系统中某个类只有一个实例存在，当这个实例被创建成功后，无法再创建一个同类型的其他实例，如系统的日志输出，GUI应用必须是单鼠标，操作系统只能有一个窗口管理器，一台PC只能连一个键盘等等，为了确保对象的唯一性可以使用单例模式来实现。</p>
<span id="more"></span>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><hr>
<p>单例模式有许多种实现方法，在C++中，甚至可以直接用一个全局变量做到这一点，但这样的代码显的很不优雅。 使用全局对象能够保证方便地访问实例，但是不能保证只声明一个对象——也就是说除了一个全局实例外，仍然能创建相同类的本地实例,单例模式有三个要点：</p>
<ul>
<li>某个类只能有一个实例；</li>
<li>它必须自行创建这个实例；</li>
<li>它必须自行向整个系统提供这个实例</li>
</ul>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>Singleton<br>定义一个Instance操作，允许客户访问它的唯一实例。Instance是一个类操作(C++中是一个静态成员函数);<br>负责创建它自己的唯一实例</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/11/05/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/Singleton.jpg" alt="singleton"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="一般场景下单例模式"><a href="#一般场景下单例模式" class="headerlink" title="一般场景下单例模式"></a>一般场景下单例模式</h4><p>定义一个Singleton类，包含一个静态的私有实例对象，并提供访问该唯一实例对象的全局访问静态方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> Singleton* m_pSingleton; <span class="comment">// 静态对象指针</span></span><br><span class="line">    <span class="keyword">private</span>:    <span class="comment">// 构造，拷贝构造，赋值函数均为私有</span></span><br><span class="line">        <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> <span class="comment">// 静态全局访问点</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pSingleton)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">return</span> m_pSingleton;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户访问唯一实例的方法只有<code>GetInstance()</code>函数，如果不通过这个函数，任何创建实例的尝试都将失败，因为类的构造函数是私有的;<br>GetInstance()使用懒惰初始化，也就是说它的返回值是当这个函数首次被访问时被创建的,这是一种防弹设计——所有<code>GetInstance()</code>之后的调用都返回相同实例的指针:<br><code>CSingleton* p1 = CSingleton :: GetInstance();</code><br><code>CSingleton* p2 = p1-&gt;GetInstance();</code><br><code>CSingleton &amp; ref = * CSingleton :: GetInstance();</code></p>
</blockquote>
<blockquote>
<p>对<code>GetInstance()</code>稍加修改，这个设计模板便可以适用于可变多实例情况，如一个类允许最多五个实例：在<code>GetInstance()</code>函数添加入参，根据入参决定实例化那种类型的实例</p>
</blockquote>
<h4 id="多线程场景下单例模式-改进1"><a href="#多线程场景下单例模式-改进1" class="headerlink" title="多线程场景下单例模式(改进1)"></a>多线程场景下单例模式(改进1)</h4><p>上面是一个简单的单例模式，但是还存在缺陷，对于多线程的情况需要考虑线程安全问题，可以考虑上锁和类的静态变量初始化两种方式解决：</p>
<ol>
<li>上锁(懒汉式单例)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> Singleton* m_pSingleton; <span class="comment">// 静态对象指针</span></span><br><span class="line">    <span class="keyword">private</span>:    <span class="comment">// 构造，拷贝构造，赋值函数均为private或protected(有子类)</span></span><br><span class="line">        <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> <span class="comment">// 静态全局访问点</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pSingleton)</span><br><span class="line">            &#123;</span><br><span class="line">                m_CS.<span class="built_in">Lock</span>(); <span class="comment">// 上锁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pSingleton)</span><br><span class="line">                &#123;</span><br><span class="line">                    m_pSingleton = <span class="keyword">new</span> <span class="built_in">Singleton</span>();           </span><br><span class="line">                &#125;</span><br><span class="line">                m_CS.<span class="built_in">UnLock</span>(); <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m_pSingleton;         </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:   <span class="comment">// 上锁</span></span><br><span class="line">        <span class="type">static</span> CCriticalSection m_CS;</span><br><span class="line">&#125;</span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>此处进行了两次<code>m_Instance == NULL</code> 的判断，使用了的“双检锁”机制。因为进行一次加锁和解锁是需要付出对应的代价的，而进行两次判断，性能降低就可以避免多次加锁与解锁操作，同时也保证了线程安全</p>
</blockquote>
<ol start="2">
<li>静态变量初始化(饿汉式单例)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> Singleton* m_pSingleton; <span class="comment">// 静态对象指针</span></span><br><span class="line">    <span class="keyword">private</span>:    <span class="comment">// 构造，拷贝构造，赋值函数均为private或protected(有子类)</span></span><br><span class="line">        <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> <span class="comment">// 静态全局访问点</span></span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> m_pSingleton;   <span class="comment">// 此处直接返回单一实例对象指针</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处进行静态变量初始化</span></span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="keyword">new</span> Singleton;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>因为静态初始化在程序开始时，也就是<strong>进入主函数之前，由主线程以单线程方式完成了初始化</strong>，所以静态初始化实例保证了线程安全性。在性能要求比较高时，就可以使用这种方式，从而避免频繁的加锁和解锁造成的资源浪费</p>
</blockquote>
<h4 id="唯一对象指针内存释放场景下单例模式-改进2"><a href="#唯一对象指针内存释放场景下单例模式-改进2" class="headerlink" title="唯一对象指针内存释放场景下单例模式(改进2)"></a>唯一对象指针内存释放场景下单例模式(改进2)</h4><p>在有些场景的类中，有一些文件锁了，文件句柄，数据库连接等等，这些随着程序的关闭而不会立即关闭的资源，必须要在程序关闭前，进行手动释放，一般情况下有下面几种解决方案：</p>
<ol>
<li><p>在程序结束时候调用<code>GetInstance()</code>并对返回的指针用<code>delete</code>操作</p>
</li>
<li><p>可以在类中添加静态成员比那里，因为程序结束的时候，系统会自动析构所有的全局变量(调用其析构函数)，事实上，系统也会析构所有的类的静态成员变量，就像这些静态成员也是全局变量一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">static</span> Singleton* m_pSingleton; <span class="comment">// 静态对象指针</span></span><br><span class="line">    <span class="keyword">private</span>:    <span class="comment">// 构造，拷贝构造，赋值函数均为private或protected(有子类)</span></span><br><span class="line">        <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> <span class="comment">// 静态全局访问点</span></span></span><br><span class="line"><span class="function">        </span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> m_pSingleton;   <span class="comment">// 此处直接返回单一实例对象指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//嵌套类CGarbo它的唯一工作就是在其析构函数中删除CSingleton的实例 ,</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">CGarbo</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                ~<span class="built_in">CGarbo</span>()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//为了访问Singleton类的private类型变量Singleton::m_pSingleton，可以将其声明为友元或改为Singleton::GetInstance();</span></span><br><span class="line">                    <span class="keyword">if</span> (Singleton::<span class="built_in">GetInstance</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">delete</span> <span class="title">Singleton::GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//// 声明静态变量，如果不定义成static，Garbo就是*m_pSingleton实例的一部分，只有当这个析构的时候，Garbo才能析构。而本意是要用Garbo去析构前面那个实例</span></span><br><span class="line">        <span class="type">static</span> CGarbo m_Garbo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此处进行静态变量初始化</span></span><br><span class="line">Singleton* Singleton::m_pSingleton = <span class="keyword">new</span> Singleton;</span><br><span class="line"><span class="comment">//定义用于析构单例而添加的类静态变量成员，但未初始化</span></span><br><span class="line">Singleton::CGarbo Singleton::m_Garbo;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用局部静态变量(也可以解决多线程安全问题)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:    <span class="comment">// 构造，拷贝构造，赋值函数均为private或protected(有子类)</span></span><br><span class="line">        <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">        <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">        Singleton&amp; <span class="keyword">operator</span> = (<span class="type">const</span> Singleton&amp;) &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> Singleton* <span class="title">GetInstance</span><span class="params">()</span> <span class="comment">// 静态全局访问点</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">static</span> Singleton singleton;  </span><br><span class="line">            <span class="keyword">return</span> &amp;singleton;   <span class="comment">// 此处直接返回局部静态变量的引用</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>但使用此种方法也会出现问题，当不满足bitwise拷贝时候，编译器会为类生成一个默认的构造函数，来支持类的拷贝，这可以通过显式的声明类拷贝的构造函数，和重载&#x3D;操作符来解决，只声明，实现为空。</p>
</blockquote>
<ol start="4">
<li>测试单例模式<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">void</span> SingletonTest()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">Singleton</span> *pS1 = Singleton::GetInstance();</span><br><span class="line">    <span class="attribute">Singleton</span> *pS2 = Singleton::GetInstance();</span><br><span class="line">    <span class="attribute">if</span> (pS1 == pS2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">cout</span> &lt;&lt; <span class="string">&quot;the same object&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">cout</span> &lt;&lt; <span class="string">&quot;not the same object&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>the same object
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li>
<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展实例时</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：<ul>
<li>对唯一实例的受控访问</li>
<li>缩小名空间，是对全局变量的一种改进</li>
<li>允许对操作和表示的精化；单例模式类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用</li>
<li>允许可变数目的实例</li>
</ul>
</li>
<li>缺点：<br>  使用泛滥？？？</li>
</ul>
<h2 id="单例模式具体实例"><a href="#单例模式具体实例" class="headerlink" title="单例模式具体实例"></a>单例模式具体实例</h2><hr>
<p><strong>使用单例模式创建一个简单的类似于Windows系统的任务管理器类，包含简单的显示进程和服务</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>TaskManager类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">TaskManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// 私有构造函数</span></span><br><span class="line">    TaskManager()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// 私有的唯一实例</span></span><br><span class="line">    <span class="keyword">static</span> TaskManager* m_ptaskmgr;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 公有的唯一实例访问点</span></span><br><span class="line">    <span class="keyword">static</span> TaskManager* getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> TaskManager  taskmgr;  <span class="comment">// 局部静态变量</span></span><br><span class="line">        <span class="keyword">return</span> &amp;taskmgr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayProcesses</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Task Mgr Process&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayServices</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Task Mgr Services&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
<li><p>测试Task Manager:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">TaskMgrTest()</span></span><br><span class="line">&#123;</span><br><span class="line">    TaskManager* ptm1 = TaskManager::get<span class="constructor">Instance()</span>;</span><br><span class="line">    TaskManager* ptm2 = TaskManager::get<span class="constructor">Instance()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptm1<span class="operator"> == </span>ptm2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Single Task Mgr&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ptm1-&gt;display<span class="constructor">Processes()</span>;</span><br><span class="line">        ptm1-&gt;display<span class="constructor">Services()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not Single Task Mgr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Single Task     
MgrTask Mgr 
ProcessTask Mgr Services
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Construction Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式(创建型)</title>
    <url>/2017/10/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在公司上班时候，每周都需要写工作周报，而写周报的时候，每次的格式都差不多，有时候想偷懒，就想自己弄个周报的模板，然后每次填充模板的内容，这样既提高了工作效率，又保证了格式的一致性，上级领导每次浏览周报的时候也一目了然了，真是一石二鸟–)，这种可以看成原型模式的应用，即每次周报对象内容都大概相同，仅需要复制粘贴，然后修改下每周的差异内容即可。</p>
<span id="more"></span>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><hr>
<p>原型模式，顾名思义，就是有个对象的原型，然后再通过此原型对象来创建新的对象。而这些新的对象，可以内容相同，也可以不同。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>AbstractPrototype<br>抽象原型类，声明一个克隆自身的接口</p>
</li>
<li><p>ConcretePrototype<br>具体原型类，实现一个克隆自身的操作</p>
</li>
<li><p>Client<br>让一个原型克隆自身从而创建一个新的对象</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/10/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/Prototype.png" alt="prototype"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先声明一个抽象的原型类<code>AbstractPrototype</code>，原型类中必须有<code>clone()</code>接口(虚函数):</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> AbstractPrototype</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">AbstractPrototype()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">AbstractPrototype()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> AbstractPrototype* <span class="constructor">Clone()</span> = <span class="number">0</span>; <span class="comment">// 克隆接口,返回自身的类型</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
</li>
<li><p>然后分别实现两个具体的原型对象，实现其中的<code>clone()</code>接口(一般通过拷贝构造函数来实现)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体原型对象1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Prototype1</span>: <span class="keyword">public</span> AbstractPrototype</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> m_ValueTest;         <span class="comment">//浅拷贝 测试值</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Prototype1</span>(<span class="type">int</span> value): <span class="built_in">m_ValueTest</span>(value) &#123;&#125;;</span><br><span class="line">     <span class="built_in">Prototype1</span>(<span class="type">const</span> Prototype1&amp; rhs) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">     &#123;</span><br><span class="line">         m_ValueTest = rhs.m_ValueTest;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function">Prototype1* <span class="title">Clone</span><span class="params">()</span> <span class="comment">// 返回自己类类型</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Prototype1</span>(*<span class="keyword">this</span>); <span class="comment">// 通过调用拷贝构造函数来Clone对象</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">ShowValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         cout &lt;&lt; m_ValueTest &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Prototype2</span>: <span class="keyword">public</span> AbstractPrototype</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> m_ValueTest;     <span class="comment">// 浅拷贝，一般的拷贝</span></span><br><span class="line">     <span class="type">char</span> *m_pName;      <span class="comment">// 涉及到深拷贝</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Prototype2</span>(<span class="type">int</span> value, <span class="type">const</span> <span class="type">char</span>* pname)</span><br><span class="line">     &#123;</span><br><span class="line">         m_ValueTest = value;</span><br><span class="line">         <span class="keyword">if</span> (<span class="literal">NULL</span> == pname)</span><br><span class="line">         &#123;</span><br><span class="line">             m_pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">             m_pName[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             m_pName = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(pname) + <span class="number">1</span>]; </span><br><span class="line">             <span class="built_in">strcpy</span>(m_pName, pname);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">Prototype2</span>()</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">delete</span> m_pName; <span class="comment">// 释放内存</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">Prototype2</span>(<span class="type">const</span> Prototype2&amp; rhs) <span class="comment">// 拷贝构造函数</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//浅拷贝：只会拷贝对象中的基本的数据类型 </span></span><br><span class="line">         m_ValueTest = rhs.m_ValueTest;  </span><br><span class="line"></span><br><span class="line">         <span class="comment">//深拷贝：需要手动申请内存，对于数组、容器对象、引用（指针）对象       </span></span><br><span class="line">         m_pName = <span class="keyword">new</span>  <span class="type">char</span>[<span class="built_in">strlen</span>(rhs.m_pName) + <span class="number">1</span>];     </span><br><span class="line">         <span class="built_in">strcpy</span>(m_pName, rhs.m_pName);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function">Prototype2* <span class="title">Clone</span><span class="params">()</span> <span class="comment">// 返回自己类类型</span></span></span><br><span class="line"><span class="function">     </span>&#123; </span><br><span class="line">          <span class="comment">// 通过调用拷贝构造函数来Clone对象</span></span><br><span class="line">         Prototype2 *pP2 = <span class="keyword">new</span> <span class="built_in">Prototype2</span>(*<span class="keyword">this</span>);</span><br><span class="line">         pP2-&gt;m_ValueTest++; <span class="comment">//改变克隆的对象内部成员，克隆出不同m_ValueTest的对象</span></span><br><span class="line">         <span class="keyword">return</span> pP2; </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">ShowValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         cout &lt;&lt; m_ValueTest &lt;&lt; endl;</span><br><span class="line">         cout &lt;&lt; m_pName &lt;&lt; endl;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试原型模式：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrototypeTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 返回子类型的类指针，抽象类没有ShowValue方法</span></span><br><span class="line">    Prototype1 *pP1= <span class="keyword">new</span> <span class="built_in">Prototype1</span>(<span class="number">10</span>); </span><br><span class="line"></span><br><span class="line">    Prototype1 *pPcopy= pP1-&gt;<span class="built_in">Clone</span>(); <span class="comment">// 克隆出新对象pPcopy</span></span><br><span class="line">    pP1-&gt;<span class="built_in">ShowValue</span>();      <span class="comment">//  10</span></span><br><span class="line">    pPcopy-&gt;<span class="built_in">ShowValue</span>();   <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    Prototype2 *pP2= <span class="keyword">new</span> <span class="built_in">Prototype2</span>(<span class="number">20</span>, <span class="string">&quot;Tly&quot;</span>);</span><br><span class="line">    Prototype2 *pPcopy2= pP2-&gt;<span class="built_in">Clone</span>();</span><br><span class="line">    pP2-&gt;<span class="built_in">ShowValue</span>();        <span class="comment">// 20, &quot;Tly&quot;</span></span><br><span class="line">    pPcopy2-&gt;<span class="built_in">ShowValue</span>();    <span class="comment">// 21  &quot;Tly&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pP1; pP1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pPcopy; pPcopy = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pP2; pP2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pPcopy2; pPcopy2 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>10
10
20
Tly
21
Tly
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>创建新对象成本较大，如初始化需要占用较长的时间、内存资源、网络资源等等，新的对象可以通过已有对象的复制得来，如是相似，则更改相应的属性成员变量即可</li>
<li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现</li>
<li>当我们的对象类型不是开始就能确定的，而这个类型是在运行期确定的话，那么我们通过这个类型的对象克隆出一个新的对象比较容易一些</li>
<li>重复地创建相似对象时可以考虑使用原型模式</li>
<li>创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率</li>
<li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响</li>
<li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作</li>
</ul>
</li>
<li>缺点<ul>
<li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”</li>
<li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦</li>
</ul>
</li>
</ul>
<h3 id="与其他创建型模型区别"><a href="#与其他创建型模型区别" class="headerlink" title="与其他创建型模型区别"></a>与其他创建型模型区别</h3><ul>
<li>工厂方法模式、抽象工厂模式、建造者模式和原型模式都是创建型模式</li>
<li>工厂方法模式适用于生产较复杂，一个工厂生产单一的一种产品的时候</li>
<li>抽象工厂模式适用于一个工厂生产多个相互依赖的产品；</li>
<li>建造者模式着重于复杂对象的一步一步创建，组装产品的过程，并在创建的过程中，可以控制每一个简单对象的创建；</li>
<li>原型模式则更强调的是从自身复制自己，创建要给和自己一模一样的对象</li>
</ul>
<h2 id="原型模式具体实例"><a href="#原型模式具体实例" class="headerlink" title="原型模式具体实例"></a>原型模式具体实例</h2><hr>
<p><strong>实现前言所描述的简单工作周报和工作月报原型，增加一个原型管理器来管理这两种原型</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>声明一个抽象的原型类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象原型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractReport</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AbstractReport</span>()&#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractReport</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractReport* <span class="title">Clone</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 抽象克隆方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;&#125;; <span class="comment">//用来显示</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">setReportTitle</span><span class="params">(string title)</span> </span>&#123;&#125;; <span class="comment">//用来修改title</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别实现两个具体的原型类：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 周报具体原型</span></span><br><span class="line">class WeeklyReport : public AbstractReport</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string <span class="variable">_reportTitle</span>;</span><br><span class="line">    int <span class="variable">_weekNo</span>;</span><br><span class="line">    string <span class="variable">_name</span>;</span><br><span class="line">    string <span class="variable">_description</span>;</span><br><span class="line">    char* <span class="variable">_accessory</span>;</span><br><span class="line">public:</span><br><span class="line">    WeeklyReport(string title, int no, string <span class="built_in">name</span>, string description, \</span><br><span class="line">        const char* accessory): <span class="variable">_reportTitle</span>(title), <span class="variable">_weekNo</span>(no), <span class="variable">_name</span>(<span class="built_in">name</span>), <span class="variable">_description</span>(description)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL == accessory)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">_accessory</span>  = new char[<span class="number">0</span>];</span><br><span class="line">            <span class="variable">_accessory</span>[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">_accessory</span> = new char[strlen(accessory) + <span class="number">1</span>];</span><br><span class="line">            strcpy(<span class="variable">_accessory</span>, accessory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~WeeklyReport()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL != <span class="variable">_accessory</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            delete <span class="variable">_accessory</span>;</span><br><span class="line">            <span class="variable">_accessory</span> = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    WeeklyReport(WeeklyReport &amp;rhs) <span class="comment">//拷贝构造函数，浅拷贝 + 深拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_reportTitle</span> = rhs.<span class="variable">_reportTitle</span>; </span><br><span class="line">        <span class="variable">_weekNo</span> = rhs.<span class="variable">_weekNo</span>;</span><br><span class="line">        <span class="variable">_name</span> =  rhs.<span class="variable">_name</span>;</span><br><span class="line">        <span class="variable">_description</span> = rhs.<span class="variable">_description</span>;</span><br><span class="line">        <span class="variable">_accessory</span> = new char[strlen(rhs.<span class="variable">_accessory</span>) + <span class="number">1</span>]; <span class="comment">// 深拷贝</span></span><br><span class="line">        memmove(<span class="variable">_accessory</span>, rhs.<span class="variable">_accessory</span>, (strlen(rhs.<span class="variable">_accessory</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WeeklyReport* Clone() <span class="comment">// 克隆接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        WeeklyReport *report = new WeeklyReport(*this);</span><br><span class="line">        return report;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setReportTitle(string reportTitle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_reportTitle</span> = reportTitle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void display(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;weekly report title: &quot;</span> &lt;&lt; <span class="variable">_reportTitle</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;weekly no: &quot;</span> &lt;&lt; <span class="variable">_weekNo</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;reporter: &quot;</span> &lt;&lt; <span class="variable">_name</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;description: &quot;</span> &lt;&lt; <span class="variable">_description</span>  &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;accessory: &quot;</span> &lt;&lt; <span class="variable">_accessory</span>  &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 月报具体原型</span></span><br><span class="line">class MonthlyReport : public AbstractReport</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string <span class="variable">_reportTitle</span>;</span><br><span class="line">    int <span class="variable">_monthNo</span>;</span><br><span class="line">    string <span class="variable">_name</span>;</span><br><span class="line">    string <span class="variable">_description</span>;</span><br><span class="line">    char* <span class="variable">_accessory</span>;</span><br><span class="line">public:</span><br><span class="line">    MonthlyReport(string title, int no, string <span class="built_in">name</span>, string description, \</span><br><span class="line">        const char* accessory): <span class="variable">_reportTitle</span>(title), <span class="variable">_monthNo</span>(no), <span class="variable">_name</span>(<span class="built_in">name</span>), <span class="variable">_description</span>(description)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL == accessory)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">_accessory</span>  = new char[<span class="number">0</span>];</span><br><span class="line">            <span class="variable">_accessory</span>[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">_accessory</span> = new char[strlen(accessory) + <span class="number">1</span>];</span><br><span class="line">            strcpy(<span class="variable">_accessory</span>, accessory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~MonthlyReport()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL != <span class="variable">_accessory</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            delete <span class="variable">_accessory</span>;</span><br><span class="line">            <span class="variable">_accessory</span> = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    MonthlyReport(MonthlyReport &amp;rhs) <span class="comment">//拷贝构造函数，浅拷贝 + 深拷贝</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_reportTitle</span> = rhs.<span class="variable">_reportTitle</span>; </span><br><span class="line">        <span class="variable">_monthNo</span> = rhs.<span class="variable">_monthNo</span>;</span><br><span class="line">        <span class="variable">_name</span> =  rhs.<span class="variable">_name</span>;</span><br><span class="line">        <span class="variable">_description</span> = rhs.<span class="variable">_description</span>;</span><br><span class="line">        <span class="variable">_accessory</span> = new char[strlen(rhs.<span class="variable">_accessory</span>) + <span class="number">1</span>]; <span class="comment">// 深拷贝</span></span><br><span class="line">        memmove(<span class="variable">_accessory</span>, rhs.<span class="variable">_accessory</span>, (strlen(rhs.<span class="variable">_accessory</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MonthlyReport* Clone() <span class="comment">// 克隆接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        MonthlyReport *report = new MonthlyReport(*this);</span><br><span class="line">        return report;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setReportTitle(string reportTitle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_reportTitle</span> = reportTitle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void display(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;monthly report title: &quot;</span> &lt;&lt; <span class="variable">_reportTitle</span> &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;monthly no: &quot;</span> &lt;&lt; <span class="variable">_monthNo</span> &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;reporter: &quot;</span> &lt;&lt; <span class="variable">_name</span> &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;description: &quot;</span> &lt;&lt; <span class="variable">_description</span> &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;accessory: &quot;</span> &lt;&lt; <span class="variable">_accessory</span> &lt;&lt;<span class="literal">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个原型管理器类，使用单例模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Report Manager</span></span><br><span class="line"><span class="keyword">class</span> ReportManager</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="built_in">string</span>, AbstractReport*&gt; reportMap;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="constructor">ReportManager()</span>&#123;&#125;;</span><br><span class="line">    <span class="constructor">ReportManager(<span class="params">const</span> ReportManager &amp;<span class="params">rhs</span>)</span> &#123;&#125;;</span><br><span class="line">    ReportManager&amp; operator = (const ReportManager &amp;rhs) &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    static ReportManager* get<span class="constructor">Instance(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        static ReportManager reportMgr;</span><br><span class="line">        return &amp;reportMgr;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 增加新的report</span></span><br><span class="line">    void add<span class="constructor">Report(<span class="params">string</span> <span class="params">name</span>, AbstractReport<span class="operator">*</span> <span class="params">report</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        reportMap.insert(make<span class="constructor">_pair(<span class="params">name</span>, <span class="params">report</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractReport* get<span class="constructor">Report(<span class="params">string</span> <span class="params">name</span>)</span> <span class="comment">// 返回一个report副本</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (map&lt;<span class="built_in">string</span>, AbstractReport*&gt;::iterator it = reportMap.<span class="keyword">begin</span><span class="literal">()</span>; \</span><br><span class="line">             it  != reportMap.<span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;first<span class="operator"> == </span>name)</span><br><span class="line">            &#123;</span><br><span class="line">                return (it-&gt;second)-&gt;<span class="constructor">Clone()</span>; <span class="comment">// clone方法返回副本</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试实例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">void ReportPrototypeTest()</span><br><span class="line">&#123;</span><br><span class="line">    ReportManager *<span class="built_in">rm</span> = ReportManager::getInstance();</span><br><span class="line"></span><br><span class="line">    WeeklyReport  *wr =new WeeklyReport (<span class="string">&quot;design model&quot;</span>, <span class="number">1</span>, <span class="string">&quot;tly&quot;</span>, <span class="string">&quot;design domain object model&quot;</span>,<span class="string">&quot;no accessory&quot;</span>);</span><br><span class="line">    MonthlyReport *mr =new MonthlyReport(<span class="string">&quot;complete design all model&quot;</span>, <span class="number">3</span>, <span class="string">&quot;tly&quot;</span>, <span class="string">&quot;complte design all domain object model&quot;</span>,<span class="string">&quot;month accessory&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;<span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$origin</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span>&quot;</span> &lt;&lt; endl;</span><br><span class="line">    wr-&gt;display();</span><br><span class="line">    mr-&gt;display();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rm</span>-&gt;addReport(<span class="string">&quot;week&quot;</span>, wr);</span><br><span class="line">    <span class="built_in">rm</span>-&gt;addReport(<span class="string">&quot;month&quot;</span>, mr);</span><br><span class="line"></span><br><span class="line">    AbstractReport *wrCopy = <span class="built_in">rm</span>-&gt;getReport(<span class="string">&quot;week&quot;</span>);</span><br><span class="line">    AbstractReport *mrCopy = <span class="built_in">rm</span>-&gt;getReport(<span class="string">&quot;month&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;<span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$copy</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span><span class="variable">$</span>&quot;</span> &lt;&lt; endl;</span><br><span class="line">    wrCopy-&gt;setReportTitle(<span class="string">&quot;change weekly report title&quot;</span>); //修改title</span><br><span class="line">    wrCopy-&gt;display();</span><br><span class="line">    mrCopy-&gt;display();</span><br><span class="line"></span><br><span class="line">    delete wr; wr = NULL;</span><br><span class="line">    delete mr; mr = NULL;</span><br><span class="line">    delete wrCopy; wrCopy = NULL;</span><br><span class="line">    delete mrCopy; mrCopy = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>$$$$$$$$$$origin$$$$$$$$$$
weekly report title: design model
weekly no: 1
reporter: tly
description: design domain object model
accessory: no accessory
monthly report title: complete design all model
monthly no: 3
reporter: tly
description: complte design all domain object model
accessory: month accessory
$$$$$$$$$$copy$$$$$$$$$$
weekly report title: change weekly report title
weekly no: 1
reporter: tly
description: design domain object model
accessory: no accessory
monthly report title: complete design all model
monthly no: 3
reporter: tly
description: complte design all domain object model
accessory: month accessory
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Construction Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式(行为型)</title>
    <url>/2017/12/21/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>一般的文档编辑器都会提供一个主菜单(Menu),主菜单中包含一些菜单项(MenuItem),每个菜单项包含很多的命令操作，包括打开命令，创建命令，编辑命令等等，要设计这样的文档编辑系统，可以考虑使用命令模式。</p>
<span id="more"></span>

<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><hr>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作,别名为动作(Action)模式或事务(Transaction)模式</p>
<blockquote>
<p>命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求<br>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开<br>命令模式是回调机制的一个面向对象替代品，所谓回调函数是指函数现在某处注册，而它将在稍后某个需要的时候被调用</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Command<br>抽象命令类，在其中执行请求的execute()方法，通过这些方法可以调用请求接收者的相关操作</p>
</li>
<li><p>ConcreteCommand<br>具体命令类，抽象命令类的子类,处理用户请求,实现抽象命令类的方法<br>一般持有接收者对象的引用。它对应具体的接收者对象,将接收者对象的动作绑定其中,在实现execute()方法时，将调用接收者对象的相关操作(Action)</p>
</li>
<li><p>Invoker<br>调用者即请求发送者，持有抽象命令对象的引用.它通过命令对象来执行请求。<br>一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系<br>在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作</p>
</li>
<li><p>Receiver<br>接收者，接收者执行与请求相关的操作，它具体实现对请求的业务处理</p>
</li>
<li><p>Client<br>创建一个ConcreteCommand命令对象，并指定它的Receiver对象</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/12/21/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/Command.jpg" alt="command"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义接收者<code>Receiver</code>,并提供<code>Action()</code>接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Receiver 接收者 ：具体命令内容的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Receiver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Action</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Receiver: Action!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义抽象命令类<code>Command</code>，并提供公共接口<code>Execute()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Command 抽象命令 ：定义公共接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.再定义<code>Command</code>类的一个具体命令子类，并实现其中的<code>Execute()</code>接口，持有命令接收者的对象，该接口主要作用是调用不同接收者<code>Receiver</code>的<code>Action()</code>方法：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteCommand 具体命令：封装的一层</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ConcreteCommand</span> : <span class="symbol">public</span> <span class="symbol">Command</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Receiver *m_pReceiver;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteCommand(Receiver *prec) : m_pReceiver(prec) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pReceiver-&gt;Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.定义一个命令调用者，持有抽象命令对象，并提供一个<code>Invoke()</code>接口，供客户端调用:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invoker 命令调用者 ：调用命令</span></span><br><span class="line"><span class="keyword">class</span> Invoker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Command *m_pCommand;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Invoker(Command <span class="operator">*</span><span class="params">pcmd</span>)</span>: m<span class="constructor">_pCommand(<span class="params">pcmd</span>)</span> &#123;&#125;; </span><br><span class="line">    <span class="comment">// 通过构造注入具体命令，也可以通过提供set方法来注入不同的具体命令对象</span></span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Invoke()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pCommand-&gt;<span class="constructor">Execute()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试命令模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">CommandTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 命令实现</span></span><br><span class="line">    Receiver *pR = <span class="keyword">new</span> <span class="constructor">Receiver()</span>;</span><br><span class="line">    <span class="comment">// 命令 中间层</span></span><br><span class="line">    Command  *pC = <span class="keyword">new</span> <span class="constructor">ConcreteCommand(<span class="params">pR</span>)</span>;</span><br><span class="line">    <span class="comment">// 命令调用</span></span><br><span class="line">    Invoker *pI  = <span class="keyword">new</span> <span class="constructor">Invoker(<span class="params">pC</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    pI-&gt;<span class="constructor">Invoke()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pR</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pC</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pI</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果：</p>
<pre><code>Receiver: Action!
</code></pre>
<h3 id="命令模式的分类"><a href="#命令模式的分类" class="headerlink" title="命令模式的分类"></a>命令模式的分类</h3><p>命令模式根据应用的使用场景，可以分为以下几类：</p>
<h4 id="一般场景命令模式"><a href="#一般场景命令模式" class="headerlink" title="一般场景命令模式"></a>一般场景命令模式</h4><p>即一般场景下的请求发送者和请求接收处理者解耦，一般一个请求对应于一个请求处理</p>
<h4 id="命令队列"><a href="#命令队列" class="headerlink" title="命令队列"></a>命令队列</h4><p>将多个请求排队，当一个请求发送者发送一个请求时,将不止一个请求接收者产生响应,这些请求接收者将逐个执行业务方法,完成对请求的处理<br>一般实现方法是增加一个<code>CommandQueue</code>类,由该类来负责存储多个命令对象,而不同的命令对象可以对应不同的请求接收者,代码实现如下:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令队列</span></span><br><span class="line"><span class="keyword">class</span> CommandQueue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;Command*&gt; _listCommand;</span><br><span class="line">public:</span><br><span class="line">    void add<span class="constructor">Command(Command &amp;<span class="params">cmd</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_listCommand</span>.</span></span>push<span class="constructor">_back(&amp;<span class="params">cmd</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void remove<span class="constructor">Command(Command &amp;<span class="params">cmd</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_listCommand</span>.</span></span>remove(&amp;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">Execute()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Command*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listCommand</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it!= <span class="module-access"><span class="module"><span class="identifier">_listCommand</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="constructor">Execute()</span>; <span class="comment">// 遍历命令集合中每个命令，并执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令队列调用者</span></span><br><span class="line"><span class="keyword">class</span> CommandQueueInvoker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CommandQueue *_commandQueue;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">CommandQueueInvoker(CommandQueue &amp;<span class="params">cmdQueue</span>)</span> :<span class="constructor">_commandQueue(&amp;<span class="params">cmdQueue</span>)</span> &#123;&#125;;</span><br><span class="line">    void set<span class="constructor">CommandQueue(CommandQueue &amp;<span class="params">cmdQueue</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _commandQueue = &amp;cmdQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">Invoke()</span></span><br><span class="line">    &#123;</span><br><span class="line">        _commandQueue-&gt;<span class="constructor">Execute()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令队列与“批处理”有点类似。批处理—可以对一组对象（命令）进行批量处理，当一个发送者发送请求后，将有一系列接收者对请求作出响应</p>
</blockquote>
<h4 id="带有撤销操作的命令模式"><a href="#带有撤销操作的命令模式" class="headerlink" title="带有撤销操作的命令模式"></a>带有撤销操作的命令模式</h4><p>在命令模式中，我们可以通过调用一个命令对象的execute()方法来实现对请求的处理，如果需要撤销(Undo)请求，可通过在命令类中增加一个逆向操作来实现,</p>
<p><strong>实现计算机加减乘除操作，并带有撤销操作</strong></p>
<p>1.首先定义命令接受者,即各种操作业务的具体实现者:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令接受者，具体的业务实现者 Adder</span></span><br><span class="line"><span class="keyword">class</span>  <span class="symbol">Adder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">float</span> add(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightoperand)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; leftOperand &lt;&lt; <span class="string">&quot; add &quot;</span> &lt;&lt; rightoperand &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (leftOperand + rightoperand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接受者，具体的业务实现者 Minuser</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Minuser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">float</span> minus(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightoperand)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; leftOperand &lt;&lt; <span class="string">&quot; minus &quot;</span> &lt;&lt; rightoperand &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (leftOperand - rightoperand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接受者，具体的业务实现者 Multiplater</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Multiplater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">float</span> multiplate(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightoperand)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; leftOperand &lt;&lt; <span class="string">&quot; multiplate &quot;</span> &lt;&lt; rightoperand &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>  (leftOperand * rightoperand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令接受者，具体的业务实现者 Diviser</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Diviser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">float</span> dive(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightoperand)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(<span class="number">0</span> != rightoperand);</span><br><span class="line">        cout &lt;&lt; leftOperand &lt;&lt; <span class="string">&quot; dive &quot;</span> &lt;&lt; rightoperand &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> (leftOperand / rightoperand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.定义抽象命令对象，和具体的命令对象,分别提供和实现<code>compute()</code>和<code>unCompute()</code>两种方法：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象计算命令ComputerCommand</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ComputerCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">float</span> compute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand) = <span class="number">0</span>;</span><br><span class="line">    virtual <span class="built_in">float</span> unCompute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体add计算命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">AddCommand</span> : <span class="symbol">public</span> <span class="symbol">ComputerCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Adder *_adder;</span><br><span class="line">    <span class="built_in">float</span> _result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AddCommand(Adder *adder) : _adder(adder), _result(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">float</span> compute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _adder-&gt;add(leftOperand, rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="built_in">float</span> unCompute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _adder-&gt;add(leftOperand, -rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体minus计算命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MinusCommand</span> : <span class="symbol">public</span> <span class="symbol">ComputerCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Minuser *_minuser;</span><br><span class="line">    <span class="built_in">float</span> _result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinusCommand(Minuser *minuser) : _minuser(minuser), _result(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">float</span> compute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _minuser-&gt;minus(leftOperand, rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="built_in">float</span> unCompute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _minuser-&gt;minus(leftOperand, -rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体multiplate计算命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MultiplateCommand</span> : <span class="symbol">public</span> <span class="symbol">ComputerCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Multiplater *_multiplater;</span><br><span class="line">    <span class="built_in">float</span> _result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MultiplateCommand(Multiplater *multiplater) : _multiplater(multiplater) , _result(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">float</span> compute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _multiplater-&gt;multiplate(leftOperand, rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="built_in">float</span> unCompute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _multiplater-&gt;multiplate(leftOperand, <span class="number">1</span>/rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体dive计算命令</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">DiveCommand</span> : <span class="symbol">public</span> <span class="symbol">ComputerCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Diviser *_diviser;</span><br><span class="line">    <span class="built_in">float</span> _result;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DiveCommand(Diviser *diviser) : _diviser(diviser), _result(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">float</span> compute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _diviser-&gt;dive(leftOperand, rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual <span class="built_in">float</span> unCompute(<span class="built_in">float</span> leftOperand, <span class="built_in">float</span> rightOperand)</span><br><span class="line">    &#123;</span><br><span class="line">        _result = _diviser-&gt;dive(leftOperand, <span class="number">1</span>/rightOperand);</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.命令的调用者，持有两个stack，分别为撤销操作命令和恢复撤销操作命令：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">class ComputerInvoker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ComputerCommand *<span class="variable">_currentComputerCommand</span>;  <span class="comment">// 当前操作</span></span><br><span class="line">    stack&lt;ComputerCommand*&gt; <span class="variable">_stackUndoCommand</span>; <span class="comment">// 撤销操作堆栈(FILO)</span></span><br><span class="line">    stack&lt;ComputerCommand*&gt; <span class="variable">_stackRedoCommand</span>; <span class="comment">// 恢复撤销操作堆栈(FILO)</span></span><br><span class="line">    float <span class="variable">_computeResult</span>;        <span class="comment">// 计算结果</span></span><br><span class="line">public:</span><br><span class="line">    ComputerInvoker(ComputerCommand *cmd) : <span class="variable">_currentComputerCommand</span>(cmd), <span class="variable">_computeResult</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void setComputerCommand(ComputerCommand *cmd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_currentComputerCommand</span> = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    void invokeCompute(float operand) <span class="comment">// 正常顺序操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">_computeResult</span> = <span class="variable">_currentComputerCommand</span>-&gt;compute(<span class="variable">_computeResult</span>, operand); <span class="comment">//执行 正常操作 </span></span><br><span class="line">        <span class="variable">_stackUndoCommand</span>.push(<span class="variable">_currentComputerCommand</span>);  <span class="comment">// 压入正常操作命令到 撤销操作的stack</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;normal compute: result is : &quot;</span> &lt;&lt; <span class="variable">_computeResult</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void invokeUncompute(float operand)  <span class="comment">// 撤销操作</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_stackUndoCommand</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;undo command stack is empty!&quot;</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">_currentComputerCommand</span> = <span class="variable">_stackUndoCommand</span>.top(); <span class="comment">// 先取 撤销操作的stack顶元素</span></span><br><span class="line">        <span class="variable">_stackUndoCommand</span>.pop();      <span class="comment">// 弹出 撤销操作的stack顶元素</span></span><br><span class="line">        <span class="variable">_computeResult</span> = <span class="variable">_currentComputerCommand</span>-&gt;unCompute(<span class="variable">_computeResult</span>, operand); <span class="comment">//执行 撤销操作</span></span><br><span class="line">        <span class="variable">_stackRedoCommand</span>.push(<span class="variable">_currentComputerCommand</span>); <span class="comment">// 压入撤销操作命令到 恢复操作的stack</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;undo compute: result is : &quot;</span> &lt;&lt; <span class="variable">_computeResult</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void invokeRecompute(float operand) <span class="comment">// 恢复撤销操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">_stackRedoCommand</span>.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;resume do command stack is empty!&quot;</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">_currentComputerCommand</span> = <span class="variable">_stackRedoCommand</span>.top();  <span class="comment">// 先取 恢复撤销操作的stack顶元素</span></span><br><span class="line">        <span class="variable">_stackRedoCommand</span>.pop();  <span class="comment">// 弹出 恢复撤销操作的stack顶元素</span></span><br><span class="line">        <span class="variable">_computeResult</span> = <span class="variable">_currentComputerCommand</span>-&gt;compute(<span class="variable">_computeResult</span>, operand); <span class="comment">//执行 恢复撤销操作 </span></span><br><span class="line">        <span class="variable">_stackUndoCommand</span>.push(<span class="variable">_currentComputerCommand</span>); <span class="comment">// 压入恢复撤销操作命令到 撤销操作的stack</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;redo compute: result is : &quot;</span> &lt;&lt; <span class="variable">_computeResult</span> &lt;&lt; <span class="literal">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    float getComputeResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="variable">_computeResult</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试带有撤销操作的命令模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">CommandTest_Compute()</span></span><br><span class="line">&#123;</span><br><span class="line">    Adder *adder = <span class="keyword">new</span> <span class="constructor">Adder()</span>;</span><br><span class="line">    ComputerCommand *addCmd = <span class="keyword">new</span> <span class="constructor">AddCommand(<span class="params">adder</span>)</span>;</span><br><span class="line">    Minuser *minuser = <span class="keyword">new</span> <span class="constructor">Minuser()</span>;</span><br><span class="line">    ComputerCommand *minusCmd = <span class="keyword">new</span> <span class="constructor">MinusCommand(<span class="params">minuser</span>)</span>;</span><br><span class="line">    Multiplater *multiplater = <span class="keyword">new</span> <span class="constructor">Multiplater()</span>;</span><br><span class="line">    ComputerCommand *multiplateCmd = <span class="keyword">new</span> <span class="constructor">MultiplateCommand(<span class="params">multiplater</span>)</span>;</span><br><span class="line">    Diviser *diviser = <span class="keyword">new</span> <span class="constructor">Diviser()</span>;</span><br><span class="line">    ComputerCommand *diveCmd = <span class="keyword">new</span> <span class="constructor">DiveCommand(<span class="params">diviser</span>)</span>;</span><br><span class="line"></span><br><span class="line">    ComputerInvoker *computeInvoke = <span class="keyword">new</span> <span class="constructor">ComputerInvoker(<span class="params">addCmd</span>)</span>; <span class="comment">// 初始化为add 且 + 50</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Compute(50)</span>; <span class="comment">// 0 + 50</span></span><br><span class="line">    computeInvoke-&gt;set<span class="constructor">ComputerCommand(<span class="params">minusCmd</span>)</span>; <span class="comment">// -20</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Compute(20)</span>; </span><br><span class="line">    computeInvoke-&gt;set<span class="constructor">ComputerCommand(<span class="params">multiplateCmd</span>)</span>; <span class="comment">// *3</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Compute(3)</span>; </span><br><span class="line">    computeInvoke-&gt;set<span class="constructor">ComputerCommand(<span class="params">diveCmd</span>)</span>; <span class="comment">//  /9</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Compute(9)</span>; </span><br><span class="line">    computeInvoke-&gt;set<span class="constructor">ComputerCommand(<span class="params">addCmd</span>)</span>; <span class="comment">//  + 10</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Compute(10)</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** last normal compute result is : &quot;</span> &lt;&lt; computeInvoke-&gt;get<span class="constructor">ComputeResult()</span> &lt;&lt; <span class="string">&quot; ***&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Uncompute(10)</span>; <span class="comment">//  撤销 +10</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Uncompute(9)</span>;<span class="comment">//   撤销 /9</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Uncompute(3)</span>; <span class="comment">//   撤销 *3</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Uncompute(20)</span>; <span class="comment">//  撤销 -20</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Uncompute(50)</span>; <span class="comment">//  撤销 +50</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** last undo compute result is : &quot;</span> &lt;&lt; computeInvoke-&gt;get<span class="constructor">ComputeResult()</span> &lt;&lt; <span class="string">&quot; ***&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Recompute(50)</span>; <span class="comment">//  恢复撤销 +50</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Recompute(20)</span>; <span class="comment">//  恢复撤销 -20</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Recompute(3)</span>; <span class="comment">//   恢复撤销 *3</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Recompute(9)</span>; <span class="comment">//   恢复撤销 /9</span></span><br><span class="line">    computeInvoke-&gt;invoke<span class="constructor">Recompute(10)</span>; <span class="comment">//  恢复撤销 +10</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** last redo compute result is : &quot;</span> &lt;&lt; computeInvoke-&gt;get<span class="constructor">ComputeResult()</span> &lt;&lt; <span class="string">&quot; ***&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="built_in">float</span> finalResult = computeInvoke-&gt;get<span class="constructor">ComputeResult()</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*** final compute result is &quot;</span> &lt;&lt; finalResult &lt;&lt; <span class="string">&quot; ***&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">adder</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">minuser</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">multiplater</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">diviser</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">addCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">minusCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">multiplateCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">diveCmd</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">computeInvoke</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果：</p>
<pre><code>0 add 50
normal compute: result is : 50
50 minus 20
normal compute: result is : 30
30 multiplate 3
normal compute: result is : 90
90 dive 9
normal compute: result is : 10
10 add 10
normal compute: result is : 20
\*\*\* last normal compute result is : 20 \*\*\*
20 add -10
undo compute: result is : 10
10 dive 0.111111
undo compute: result is : 90
90 multiplate 0.333333
undo compute: result is : 30
30 minus -20
undo compute: result is : 50
50 add -50
undo compute: result is : 0
\*\*\* last undo compute result is : 0 \*\*\*
0 add 50
redo compute: result is : 50
50 minus 20
redo compute: result is : 30
30 multiplate 3
redo compute: result is : 90
90 dive 9
redo compute: result is : 10
10 add 10
redo compute: result is : 20
\*\*\* last redo compute result is : 20 \*\*\*
\*\*\* final compute result is 20 \*\*\*
</code></pre>
<h4 id="请求日志的命令模式"><a href="#请求日志的命令模式" class="headerlink" title="请求日志的命令模式"></a>请求日志的命令模式</h4><p>请求日志就是将请求的历史记录保存下来，通常以日志文件(Log File)的形式永久存储在计算机中</p>
<blockquote>
<p>1.可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利恢复到某一个特定的状态<br>2.用于实现批处理，在一个请求日志文件中可以存储一系列命令对象,如一个命令队列</p>
</blockquote>
<p><strong>在上面带恢复功能的简易计算器基础上增加请求日志功能</strong></p>
<p>1.增加操作命令日志的list:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tag_computeLog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//typedef float(*pComputeFunc)(float, float);</span></span><br><span class="line">    <span class="comment">//pComputeFunc compute;</span></span><br><span class="line">    ComputerCommand* cmd;</span><br><span class="line">    <span class="type">float</span> leftOperand;</span><br><span class="line">    <span class="type">float</span> rightOperand;</span><br><span class="line">&#125;computeLog;</span><br><span class="line"></span><br><span class="line">list&lt;computeLog&gt; _listComputeLogCommand; <span class="comment">// 执行操作记录的list</span></span><br></pre></td></tr></table></figure>

<p>2.修改调用执行计算的方法，在其中添加command到list:</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">void invokeCompute(float operand) <span class="comment">// 正常顺序操作</span></span><br><span class="line">&#123;</span><br><span class="line">    computeLog <span class="built_in">log</span>;</span><br><span class="line">    <span class="built_in">log</span>.cmd = <span class="variable">_currentComputerCommand</span>;</span><br><span class="line">    <span class="built_in">log</span>.leftOperand = <span class="variable">_computeResult</span>;</span><br><span class="line">    <span class="built_in">log</span>.rightOperand = operand;</span><br><span class="line">    <span class="variable">_listComputeLogCommand</span>.push_back(<span class="built_in">log</span>); <span class="comment">// 添加操作command记录到list</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">_computeResult</span> = <span class="variable">_currentComputerCommand</span>-&gt;compute(<span class="variable">_computeResult</span>, operand); <span class="comment">//执行 正常操作 </span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.增加新的日志命令操作，循环调用操作command记录list中的命令:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="literal">void</span> invokeLogCommand(<span class="literal">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _computeResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">list</span>&lt;computeLog&gt;::iterator <span class="literal">it</span> = _listComputeLogCommand.begin();</span><br><span class="line">        <span class="literal">it</span> != _listComputeLogCommand.end(); ++<span class="literal">it</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _computeResult =((*<span class="literal">it</span>).cmd-&gt;compute((*<span class="literal">it</span>).leftOperand, (*<span class="literal">it</span>).rightOperand));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h4><p>宏命令(Macro Command)又称为组合命令，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合属性，在该集合中包含了对其他命令对象的引用。通常宏命令不直接与请求接收者交互，而是通过它的集合成员来调用接收者的方法</p>
<blockquote>
<p>宏命令的execute()方法时，将递归调用它所包含的每个成员命令的execute()方法<br>执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理</p>
</blockquote>
<p><strong>在上面带恢复和日志功能的简易计算器基础上增加宏命令(批处理，依次调用各个命令)</strong></p>
<p>1.修改抽象命令类<code>ComputerCommand</code>，增加增加和删除命令集合元素的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象计算命令ComputerCommand</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComputerCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">compute</span><span class="params">(<span class="type">float</span> leftOperand, <span class="type">float</span> rightOperand)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">unCompute</span><span class="params">(<span class="type">float</span> leftOperand, <span class="type">float</span> rightOperand)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">// for Macro Command:</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">insertCommand</span><span class="params">(ComputerCommand *cmd)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeCommand</span><span class="params">(ComputerCommand *cmd)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function">ComputerCommand* <span class="title">getCommand</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.增加宏命令具体类<code>MacroCommand</code>，继承于抽象命令类<code>ComputerCommand</code>，并实现其各个方法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批计算处理：计算给定的两个操作数的四种操作(+ - * /)结果的和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacroCommand</span> : <span class="keyword">public</span> ComputerCommand</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ComputerCommand*&gt; _vecCmd;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MacroCommand</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertCommand</span><span class="params">(ComputerCommand *cmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _vecCmd.<span class="built_in">push_back</span>(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeCommand</span><span class="params">(ComputerCommand *cmd)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;ComputerCommand*&gt;::iterator it = _vecCmd.<span class="built_in">begin</span>();</span><br><span class="line">             it != _vecCmd.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*it == cmd)</span><br><span class="line">            &#123;</span><br><span class="line">                _vecCmd.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ComputerCommand* <span class="title">getCommand</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(i &lt; _vecCmd.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> _vecCmd[i];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次执行集合中的命令</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">compute</span><span class="params">(<span class="type">float</span> leftOperand, <span class="type">float</span> rightOperand)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;ComputerCommand*&gt;::iterator it = _vecCmd.<span class="built_in">begin</span>();</span><br><span class="line">            it != _vecCmd.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            result += (*it)-&gt;<span class="built_in">compute</span>(leftOperand, rightOperand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">unCompute</span><span class="params">(<span class="type">float</span> leftOperand, <span class="type">float</span> rightOperand)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">float</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;ComputerCommand*&gt;::iterator it = _vecCmd.<span class="built_in">begin</span>();</span><br><span class="line">            it != _vecCmd.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            result += (*it)-&gt;<span class="built_in">unCompute</span>(leftOperand, rightOperand);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.使用宏命令,与使用简单命令类似，只是使用前，先添加命令元素:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Adder *adder = <span class="keyword">new</span> <span class="constructor">Adder()</span>;</span><br><span class="line">ComputerCommand *addCmd = <span class="keyword">new</span> <span class="constructor">AddCommand(<span class="params">adder</span>)</span>;</span><br><span class="line">Minuser *minuser = <span class="keyword">new</span> <span class="constructor">Minuser()</span>;</span><br><span class="line">ComputerCommand *minusCmd = <span class="keyword">new</span> <span class="constructor">MinusCommand(<span class="params">minuser</span>)</span>;</span><br><span class="line">Multiplater *multiplater = <span class="keyword">new</span> <span class="constructor">Multiplater()</span>;</span><br><span class="line">ComputerCommand *multiplateCmd = <span class="keyword">new</span> <span class="constructor">MultiplateCommand(<span class="params">multiplater</span>)</span>;</span><br><span class="line">Diviser *diviser = <span class="keyword">new</span> <span class="constructor">Diviser()</span>;</span><br><span class="line">ComputerCommand *diveCmd = <span class="keyword">new</span> <span class="constructor">DiveCommand(<span class="params">diviser</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add simple command to Macro Command;</span></span><br><span class="line">ComputerCommand *macroCmd = <span class="keyword">new</span> <span class="constructor">MacroCommand()</span>;</span><br><span class="line">macroCmd-&gt;insert<span class="constructor">Command(<span class="params">addCmd</span>)</span>;</span><br><span class="line">macroCmd-&gt;insert<span class="constructor">Command(<span class="params">minusCmd</span>)</span>;</span><br><span class="line">macroCmd-&gt;insert<span class="constructor">Command(<span class="params">multiplateCmd</span>)</span>;</span><br><span class="line">macroCmd-&gt;insert<span class="constructor">Command(<span class="params">diveCmd</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke Macro Command just like Simple Command;</span></span><br><span class="line">computeInvoke-&gt;set<span class="constructor">ComputerCommand(<span class="params">macroCmd</span>)</span>; <span class="comment">// 批计算处理</span></span><br><span class="line">computeInvoke-&gt;invoke<span class="constructor">Compute(2)</span>; </span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li>
<li>系统需要将一组操作组合在一起形成宏命令</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦</li>
<li>新的命令可以很容易地加入到系统中</li>
</ul>
</li>
<li>缺点<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类</li>
</ul>
</li>
</ul>
<h2 id="命令模式具体实例"><a href="#命令模式具体实例" class="headerlink" title="命令模式具体实例"></a>命令模式具体实例</h2><hr>
<h3 id="编辑器操作问题"><a href="#编辑器操作问题" class="headerlink" title="编辑器操作问题"></a>编辑器操作问题</h3><p><strong>使用命令模式简单实现前言所述的文档编辑器简单操作功能</strong></p>
<ul>
<li>支持撤销</li>
<li>支持宏命令</li>
<li>支持操作日志恢复</li>
</ul>
<p><strong>代码实现</strong><br>1.定义抽象的命令类<code>DocCommand</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// command</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DocCommand</span>() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DocCommand</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">execute</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">unexecute</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addDocCommand</span><span class="params">(DocCommand* doc)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeDocCommand</span><span class="params">(DocCommand* doc)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Document* <span class="title">getCurrentOpenDoc</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别定义命令类<code>DocCommand</code>的子类<code>OpenDocCommand</code>和<code>EditDocCommand</code>和<code>SaveDocCommand</code>和<code>CloseDocCommand</code>及宏命令<code>MacroDocCommand</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// open </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenDocCommand</span> : <span class="keyword">public</span> <span class="title class_">DocCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">OpenDocCommand</span>(<span class="title class_">Application</span> *app) : <span class="title function_">_app</span>(app), <span class="title function_">_currentOpenDoc</span>(<span class="variable constant_">NULL</span>), <span class="title function_">_response</span>(<span class="params"><span class="string">&quot;&quot;</span></span>) &#123;&#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">execute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">askUser</span>();</span><br><span class="line">        <span class="keyword">if</span> (!_response.<span class="title function_">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            _currentOpenDoc = _app-&gt;<span class="title function_">getDocByName</span>(_response);</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable constant_">NULL</span> != _currentOpenDoc)</span><br><span class="line">            &#123;</span><br><span class="line">                _currentOpenDoc-&gt;<span class="title function_">open</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">unexecute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can not unexecute open operate!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">askUser</span>(<span class="params"></span>) </span><br><span class="line">    &#123;</span><br><span class="line">        char confirm;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;please input a name for the doc: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin  &gt;&gt; _response;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you have enter a doc named: &quot;</span> &lt;&lt; _response &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;confirm? (Y/N)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin  &gt;&gt; confirm;</span><br><span class="line">        <span class="keyword">switch</span> (confirm)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                _response = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">Document</span>* <span class="title function_">getCurrentOpenDoc</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _currentOpenDoc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="title class_">Application</span> *_app;</span><br><span class="line">    <span class="title class_">Document</span> *_currentOpenDoc;</span><br><span class="line">    <span class="built_in">string</span> _response;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//edit</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EditDocCommand</span> : <span class="keyword">public</span> <span class="title class_">DocCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">EditDocCommand</span>(<span class="title class_">Document</span>* doc) : <span class="title function_">_doc</span>(<span class="params">doc</span>) &#123;&#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">execute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NULL</span> != _doc)</span><br><span class="line">        &#123;</span><br><span class="line">            _doc-&gt;<span class="title function_">edit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">unexecute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NULL</span> != _doc)</span><br><span class="line">        &#123;</span><br><span class="line">            _doc-&gt;<span class="title function_">unedit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Document</span>* <span class="title function_">getCurrentOpenDoc</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _doc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="title class_">Document</span> *_doc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//save</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaveDocCommand</span> : <span class="keyword">public</span> <span class="title class_">DocCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">SaveDocCommand</span>(<span class="title class_">Document</span>* doc) : <span class="title function_">_doc</span>(<span class="params">doc</span>) &#123;&#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">execute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NULL</span> != _doc)</span><br><span class="line">        &#123;</span><br><span class="line">            _doc-&gt;<span class="title function_">save</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">unexecute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NULL</span> != _doc)</span><br><span class="line">        &#123;</span><br><span class="line">            _doc-&gt;<span class="title function_">unsave</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Document</span>* <span class="title function_">getCurrentOpenDoc</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _doc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="title class_">Document</span> *_doc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// close</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CloseDocCommand</span> : <span class="keyword">public</span> <span class="title class_">DocCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">CloseDocCommand</span>(<span class="title class_">Document</span>* doc) : <span class="title function_">_doc</span>(<span class="params">doc</span>) &#123;&#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">execute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable constant_">NULL</span> != _doc)</span><br><span class="line">        &#123;</span><br><span class="line">            _doc-&gt;<span class="title function_">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">unexecute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;can not unexecute close operate!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Document</span>* <span class="title function_">getCurrentOpenDoc</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _doc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="title class_">Document</span> *_doc;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// macro</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MacroDocCommand</span> : <span class="keyword">public</span> <span class="title class_">DocCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">MacroDocCommand</span>() &#123;&#125;;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">execute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (list&lt;<span class="title class_">DocCommand</span>*&gt;::iterator it = _listDoc.<span class="title function_">begin</span>();</span><br><span class="line">            it != _listDoc.<span class="title function_">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="title function_">execute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">unexecute</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (list&lt;<span class="title class_">DocCommand</span>*&gt;::iterator it = _listDoc.<span class="title function_">begin</span>();</span><br><span class="line">            it != _listDoc.<span class="title function_">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="title function_">unexecute</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">addDocCommand</span>(<span class="params">DocCommand* doc</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _listDoc.<span class="title function_">push_back</span>(doc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">void</span> <span class="title function_">removeDocCommand</span>(<span class="params">DocCommand* doc</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _listDoc.<span class="title function_">remove</span>(doc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    list&lt;<span class="title class_">DocCommand</span>*&gt; _listDoc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义命令的接收者即，实际业务的实现者<code>Document</code>和<code>Application</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// receiver</span></span><br><span class="line"><span class="keyword">class</span> Document</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Document(<span class="params">string</span> <span class="params">name</span>)</span> :<span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="keyword">open</span>(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;open document &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void edit(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;edit document &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void save(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;save document &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void close(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;close document &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void unedit(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unedit document &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    void unsave(void)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsave document &quot;</span> &lt;&lt; _name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> get<span class="constructor">Name(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// application contains docs and act as docs factory as well</span></span><br><span class="line"><span class="keyword">class</span> Application</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;Document*&gt; _listDoc;</span><br><span class="line">    <span class="built_in">string</span> _appName;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Application(<span class="params">string</span> <span class="params">name</span>)</span>: <span class="constructor">_appName(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Application()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Document*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            delete *it;</span><br><span class="line">            *it = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">bool</span> is<span class="constructor">ExitDocByName(<span class="params">string</span> <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Document*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span><span class="operator"> == </span>((*it)-&gt;get<span class="constructor">Name()</span>.compare(name)))</span><br><span class="line">            &#123;</span><br><span class="line">                return <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Document* get<span class="constructor">DocByName(<span class="params">string</span> <span class="params">name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Document*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span><span class="operator"> == </span>((*it)-&gt;get<span class="constructor">Name()</span>.compare(name)))</span><br><span class="line">            &#123;</span><br><span class="line">                return *it;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if not exit , new one &amp; add &amp; return it</span></span><br><span class="line">        Document *doc = <span class="keyword">new</span> <span class="constructor">Document(<span class="params">name</span>)</span>;</span><br><span class="line">        add<span class="constructor">Doc(<span class="params">doc</span>)</span>;</span><br><span class="line">        return doc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> get<span class="constructor">Name(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _appName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    void add<span class="constructor">Doc(Document<span class="operator">*</span> <span class="params">doc</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_listDoc</span>.</span></span>push<span class="constructor">_back(<span class="params">doc</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.最后定义命令请求的调用者<code>Writer</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invoker</span></span><br><span class="line"><span class="keyword">class</span> Writer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Writer(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Writer()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;DocCommandLog*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listHistoryCmdLog</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != <span class="module-access"><span class="module"><span class="identifier">_listHistoryCmdLog</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            delete *it;</span><br><span class="line">            *it = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">class</span> DocCommandLog</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        DocCommand *docCmd;</span><br><span class="line">        <span class="built_in">bool</span> isexecute;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    void set<span class="constructor">DocCommand(DocCommand <span class="operator">*</span><span class="params">cmd</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _currentCmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="keyword">do</span><span class="constructor">Work(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _currentCmd-&gt;execute<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        DocCommandLog *cmdLog = <span class="keyword">new</span> <span class="constructor">DocCommandLog()</span>;</span><br><span class="line">        cmdLog-&gt;docCmd = _currentCmd;</span><br><span class="line">        cmdLog-&gt;isexecute = <span class="literal">true</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_listHistoryCmdLog</span>.</span></span>push<span class="constructor">_back(<span class="params">cmdLog</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void undo<span class="constructor">Work(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _currentCmd-&gt;unexecute<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        DocCommandLog *cmdLog = <span class="keyword">new</span> <span class="constructor">DocCommandLog()</span>;</span><br><span class="line">        cmdLog-&gt;docCmd = _currentCmd;</span><br><span class="line">        cmdLog-&gt;isexecute = <span class="literal">false</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">_listHistoryCmdLog</span>.</span></span>push<span class="constructor">_back(<span class="params">cmdLog</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void bat<span class="constructor">WorkByHistoryCmdLog(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;DocCommandLog*&gt;::iterator it = <span class="module-access"><span class="module"><span class="identifier">_listHistoryCmdLog</span>.</span></span><span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != <span class="module-access"><span class="module"><span class="identifier">_listHistoryCmdLog</span>.</span></span><span class="keyword">end</span><span class="literal">()</span>; ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it)-&gt;isexecute)</span><br><span class="line">            &#123;</span><br><span class="line">                (*it)-&gt;docCmd-&gt;execute<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                (*it)-&gt;docCmd-&gt;unexecute<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> get<span class="constructor">Name(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    DocCommand *_currentCmd;</span><br><span class="line">    <span class="built_in">list</span>&lt;DocCommandLog*&gt; _listHistoryCmdLog;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试命令模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void <span class="constructor">CommandTest_Doc()</span></span><br><span class="line">&#123;</span><br><span class="line">    Application *app = <span class="keyword">new</span> <span class="constructor">Application(<span class="string">&quot;VS 2015&quot;</span>)</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;app name is : &quot;</span> &lt;&lt; app-&gt;get<span class="constructor">Name()</span> &lt;&lt; endl;</span><br><span class="line">    Writer *writer = <span class="keyword">new</span> <span class="constructor">Writer(<span class="string">&quot;tly&quot;</span>)</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;writer name is: &quot;</span> &lt;&lt; writer-&gt;get<span class="constructor">Name()</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. open doc</span></span><br><span class="line">    DocCommand *openCmd = <span class="keyword">new</span> <span class="constructor">OpenDocCommand(<span class="params">app</span>)</span>;</span><br><span class="line">    writer-&gt;set<span class="constructor">DocCommand(<span class="params">openCmd</span>)</span>;</span><br><span class="line">    writer-&gt;<span class="keyword">do</span><span class="constructor">Work()</span>;</span><br><span class="line">    Document *currentOpenDoc = openCmd-&gt;get<span class="constructor">CurrentOpenDoc()</span>;</span><br><span class="line">    <span class="keyword">if</span> (NULL<span class="operator"> == </span>currentOpenDoc)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;not open any doc !!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">openCmd</span>)</span>;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">writer</span>)</span>;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">app</span>)</span>;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. edit doc</span></span><br><span class="line">    DocCommand *editCmd = <span class="keyword">new</span> <span class="constructor">EditDocCommand(<span class="params">currentOpenDoc</span>)</span>;</span><br><span class="line">    writer-&gt;set<span class="constructor">DocCommand(<span class="params">editCmd</span>)</span>;</span><br><span class="line">    writer-&gt;<span class="keyword">do</span><span class="constructor">Work()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. unedit doc</span></span><br><span class="line">    writer-&gt;undo<span class="constructor">Work()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. save &amp; close doc</span></span><br><span class="line">    DocCommand *macroCmd = <span class="keyword">new</span> <span class="constructor">MacroDocCommand()</span>;</span><br><span class="line">    DocCommand *saveCmd = <span class="keyword">new</span> <span class="constructor">SaveDocCommand(<span class="params">currentOpenDoc</span>)</span>;</span><br><span class="line">    macroCmd-&gt;add<span class="constructor">DocCommand(<span class="params">saveCmd</span>)</span>;</span><br><span class="line">    DocCommand *closeCmd = <span class="keyword">new</span> <span class="constructor">CloseDocCommand(<span class="params">currentOpenDoc</span>)</span>;</span><br><span class="line">    macroCmd-&gt;add<span class="constructor">DocCommand(<span class="params">closeCmd</span>)</span>;</span><br><span class="line">    writer-&gt;set<span class="constructor">DocCommand(<span class="params">macroCmd</span>)</span>;</span><br><span class="line">    writer-&gt;<span class="keyword">do</span><span class="constructor">Work()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. bat just doc operate:</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bat history log: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    writer-&gt;bat<span class="constructor">WorkByHistoryCmdLog()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">openCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">editCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">saveCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">closeCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">macroCmd</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">writer</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">app</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行结果:</p>
<pre><code>app name is : VS 2015
writer name is: tly
please input a name for the doc:
design_pattern
you have enter a doc named: design_pattern
confirm? (Y/N)
y
open document design_pattern
edit document design_pattern
unedit document design_pattern
save document design_pattern
close document design_pattern
bat history log:
please input a name for the doc:
design_pattern
you have enter a doc named: design_pattern
confirm? (Y/N)
y
open document design_pattern
edit document design_pattern
unedit document design_pattern
save document design_pattern
close document design_pattern
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式(行为型)</title>
    <url>/2018/04/25/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在玩RPG之类游戏的时候，每次通过一次游戏关卡的时候，一般我们都会把游戏的角色状态保存一下，继续通下一关，如果下一关难度比较大很难通过失败后，又懒得从第一关开始重新。幸亏有关卡的保存功能，我们可以直接从上次保存的关卡中重新开始即可，提高了通关的效率。这里的游戏角色的保存和恢复功能就是本文将要介绍的备忘录模式。</p>
<span id="more"></span>

<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><hr>
<p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件用到的撤销功能就是基于此模式的</p>
<blockquote>
<p>一个备忘录是一个对象，它存储另一个对象在某个瞬间的内部状态，而后者称为备忘录的原发器(Originator)。当需要设置原发器的检查点时, 取消操作机制会向原发器请求一个备忘录。原发器用描述当前状态的信息初始化该备忘录。只有原发器可以向备忘录中存取信息，备忘录对其他的对象“不可见”</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Memento<br>备忘录，存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态<br>防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口:<br>1.管理者(Caretaker)只能看到备忘录的窄接口—它只能将备忘录传递给其他对象;<br>2.相反,原发器能够看到一个宽接口,允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态</p>
</li>
<li><p>Originator<br>原发器，创建一个备忘录,用以记录当前时刻它的内部状态<br>使用备忘录恢复内部状态</p>
</li>
<li><p>Caretaker<br>负责人，负责保存好备忘录<br>不能对备忘录的内容进行操作或检查</p>
</li>
</ul>
<blockquote>
<p>管理器向原发器请求一个备忘录, 保留一段时间后,将其送回给原发器<br>备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/04/25/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/Memento.jpg" alt="memento"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义备忘录类<code>Memento</code>,备忘录类内部状态成员是私有的为了保证封装性,只有原发器能看到,声明原发器类为<code>friend</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//状态信息类</span></span><br><span class="line"><span class="keyword">struct</span> MementoState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_stateinformation;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">MementoState(<span class="params">string</span> <span class="params">state</span>)</span>: m<span class="constructor">_stateinformation(<span class="params">state</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="constructor">GetStateInform()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_stateinformation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">class</span> Originator;</span><br><span class="line"><span class="keyword">class</span> Memento</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MementoState m_state;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Memento(MementoState <span class="params">state</span>)</span> : m<span class="constructor">_state(<span class="params">state</span>)</span> &#123;&#125;;</span><br><span class="line">    friend <span class="keyword">class</span> Originator; <span class="comment">// Originator为友元类，只有Originator才能访问Memento成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义原发器类<code>Originator</code>，并提供创建备忘录的接口<code>SaveStateToCreatedMemento()</code>和恢复备忘录的接口<code>LoadStateFromMemento()</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原发器</span></span><br><span class="line"><span class="keyword">class</span> Originator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MementoState m_state;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Originator(MementoState <span class="params">state</span>)</span> : m<span class="constructor">_state(<span class="params">state</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    Memento* <span class="constructor">SaveStateToCreatedMemento()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Memento *pMemento = <span class="keyword">new</span> <span class="constructor">Memento(<span class="params">m_state</span>)</span>;  <span class="comment">// 生成备忘录</span></span><br><span class="line">        return pMemento;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">LoadStateFromMemento(Memento <span class="operator">*</span><span class="params">pMemento</span>)</span> <span class="comment">// 恢复备忘录</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_state = pMemento-&gt;m_state;   <span class="comment">// 只有Originator才能访问Memento的私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">ChangeState(MementoState <span class="params">state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">ShowState()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;State Information Is: &quot;</span> &lt;&lt; m_state.<span class="constructor">GetStateInform()</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.再定义备忘录的管理者类<code>Caretaker</code>，该类负责管理<code>Mememto</code>，负责保存备忘录，但是不能对备忘录的内容进行操作或检查，不能修改对象，也无须知道对象的实现细节：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 备忘录管理</span></span><br><span class="line"><span class="keyword">class</span> Caretaker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Memento*&gt; m_vecMemento;  <span class="comment">// vector 支持随机存取，list不支持,保存多个备忘录对象，可以支持多次撤销和恢复</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Caretaker()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Caretaker()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;Memento*&gt;::iterator it = m_vecMemento.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_vecMemento.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="constructor">SAFE_RELASE_POINTER(<span class="operator">*</span><span class="params">it</span>)</span>;  <span class="comment">// 备忘录管理者负责释放备忘录对象内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_vecMemento.clear<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">SaveMemento(Memento <span class="operator">*</span><span class="params">pMemento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_vecMemento.push<span class="constructor">_back(<span class="params">pMemento</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Memento* <span class="constructor">LoadMementoByIndex(<span class="params">int</span> MementoIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_vecMemento<span class="literal">[M<span class="identifier">ementoIndex</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试备忘录模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">MementoTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    Caretaker *pCT = <span class="keyword">new</span> <span class="constructor">Caretaker()</span>;</span><br><span class="line">    MementoState state1(<span class="string">&quot;First Step&quot;</span>);</span><br><span class="line">    MementoState state2(<span class="string">&quot;Second Step&quot;</span>);</span><br><span class="line">    MementoState state3(<span class="string">&quot;Third Step&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Originator *pO = <span class="keyword">new</span> <span class="constructor">Originator(<span class="params">state1</span>)</span>;</span><br><span class="line">    pO-&gt;<span class="constructor">ShowState()</span>;</span><br><span class="line"></span><br><span class="line">    pCT-&gt;<span class="constructor">SaveMemento(<span class="params">pO</span>-&gt;SaveStateToCreatedMemento()</span>); <span class="comment">// Caretaker 管理添加新建的第一个Memento</span></span><br><span class="line">    pO-&gt;<span class="constructor">ChangeState(<span class="params">state2</span>)</span>;</span><br><span class="line">    pO-&gt;<span class="constructor">ShowState()</span>;</span><br><span class="line"></span><br><span class="line">    pCT-&gt;<span class="constructor">SaveMemento(<span class="params">pO</span>-&gt;SaveStateToCreatedMemento()</span>); <span class="comment">// Caretaker 管理添加新建的第二个Memento</span></span><br><span class="line">    pO-&gt;<span class="constructor">ChangeState(<span class="params">state3</span>)</span>;</span><br><span class="line">    pO-&gt;<span class="constructor">ShowState()</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Restore State 1: &quot;</span>;</span><br><span class="line">    pO-&gt;<span class="constructor">LoadStateFromMemento(<span class="params">pCT</span>-&gt;LoadMementoByIndex(1)</span>); <span class="comment">// 从Caretaker中取第二个Memento保存的状态</span></span><br><span class="line">    pO-&gt;<span class="constructor">ShowState()</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Restore State 0: &quot;</span>;</span><br><span class="line">    pO-&gt;<span class="constructor">LoadStateFromMemento(<span class="params">pCT</span>-&gt;LoadMementoByIndex(0)</span>); <span class="comment">// 从Caretaker中取第一个Memento保存的状态</span></span><br><span class="line">    pO-&gt;<span class="constructor">ShowState()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pO</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCT</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果：</p>
<pre><code>State Information Is: First Step
State Information Is: Second Step
State Information Is: Third Step
Restore State 1: State Information Is: Second Step
Restore State 0: State Information Is: First Step
</code></pre>
<blockquote>
<p>备忘录的封装：<br>备忘录是一个很特殊的对象，只有原发器对它拥有控制的权力，负责人只负责管理，而其他类无法访问到备忘录,它只需要从负责人处取出备忘录对象并将原发器对象的状态恢复，而无须关心备忘录的保存细节。理想的情况是只允许生成该备忘录的那个原发器访问备忘录的内部状态，<br>在C++中可以使用friend关键字，让原发器类和备忘录类成为友元类，互相之间可以访问对象的一些私有的属性；在Java语言中可以将原发器类和备忘录类放在一个包中，让它们之间满足默认的包内可见性；也可以将备忘录类作为原发器类的内部类，使得只有原发器才可以访问备忘录中的数据</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>必须保存一个对象在某一个时刻的(部分)状态, 这样以后需要时它才能恢复到先前的状态</li>
<li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤</li>
<li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作</li>
</ul>
</li>
<li>缺点<ul>
<li>如果原发器在生成备忘录时必须拷贝并存储大量的信息或者客户非常频繁地创建备忘录和恢复原发器状态，可能会导致非常大的开销</li>
</ul>
</li>
</ul>
<blockquote>
<p>存储增量式改变：如果备忘录的创建及其返回（给它们的原发器）的顺序是可预测的，备忘录可以仅存储原发器内部状态的增量改变</p>
</blockquote>
<h2 id="备忘录模式具体实例"><a href="#备忘录模式具体实例" class="headerlink" title="备忘录模式具体实例"></a>备忘录模式具体实例</h2><hr>
<h3 id="游戏角色状态保存恢复问题"><a href="#游戏角色状态保存恢复问题" class="headerlink" title="游戏角色状态保存恢复问题"></a>游戏角色状态保存恢复问题</h3><p><strong>使用备忘录模式简单实现前言所述的游戏角色保存和恢复功能</strong></p>
<p><strong>代码实现</strong><br>1.定义游戏角色备忘录类<code>GameRoleMemento</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏角色备忘录</span></span><br><span class="line"><span class="keyword">class</span> GameRole;</span><br><span class="line"><span class="keyword">class</span> GameRoleMemento</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_RoleAgileValue;</span><br><span class="line">    <span class="built_in">int</span> m_RolePowerValue;</span><br><span class="line">    <span class="built_in">int</span> m_RoleIntelligenceValue;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">GameRoleMemento(<span class="params">int</span> <span class="params">agile</span>, <span class="params">int</span> <span class="params">powr</span>, <span class="params">int</span> <span class="params">intelligence</span>)</span></span><br><span class="line">        : m<span class="constructor">_RoleAgileValue(<span class="params">agile</span>)</span>, m<span class="constructor">_RolePowerValue(<span class="params">powr</span>)</span>, m<span class="constructor">_RoleIntelligenceValue(<span class="params">intelligence</span>)</span> &#123;&#125;;</span><br><span class="line">    friend <span class="keyword">class</span> GameRole;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.定义游戏角色原发器类<code>GameRole</code>,包含创建和恢复游戏角色备忘录的接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏角色(原发器)</span></span><br><span class="line"><span class="keyword">class</span> GameRole</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_RoleAgileValue;</span><br><span class="line">    <span class="built_in">int</span> m_RolePowerValue;</span><br><span class="line">    <span class="built_in">int</span> m_RoleIntelligenceValue;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">GameRole(<span class="params">int</span> <span class="params">agile</span>, <span class="params">int</span> <span class="params">powr</span>, <span class="params">int</span> <span class="params">intelligence</span>)</span></span><br><span class="line">        : m<span class="constructor">_RoleAgileValue(<span class="params">agile</span>)</span>, m<span class="constructor">_RolePowerValue(<span class="params">powr</span>)</span>, m<span class="constructor">_RoleIntelligenceValue(<span class="params">intelligence</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    GameRoleMemento* <span class="constructor">CreateMemento()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">GameRoleMemento(<span class="params">m_RoleAgileValue</span>, <span class="params">m_RolePowerValue</span>, <span class="params">m_RoleIntelligenceValue</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">SetMemento(GameRoleMemento <span class="operator">*</span><span class="params">pGameRoleMemento</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_RoleAgileValue = pGameRoleMemento-&gt;m_RoleAgileValue;</span><br><span class="line">        m_RolePowerValue = pGameRoleMemento-&gt;m_RolePowerValue;</span><br><span class="line">        m_RoleIntelligenceValue = pGameRoleMemento-&gt;m_RoleIntelligenceValue;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">Attack()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_RolePowerValue-= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">ShowAttribute()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Hero Attribution: [Agile]:&quot;</span> &lt;&lt; m_RoleAgileValue &lt;&lt; <span class="string">&quot; [Power]:&quot;</span> &lt;&lt; m_RolePowerValue &lt;&lt; </span><br><span class="line">        <span class="string">&quot; [Intelligence]:&quot;</span> &lt;&lt; m_RoleIntelligenceValue &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义游戏角色备忘录管理者类<code>GameRoleCaretaker</code>,负责管理游戏角色备忘录:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏角色备忘录管理者</span></span><br><span class="line"><span class="keyword">class</span> GameRoleCaretaker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;GameRoleMemento*&gt; m_vecGameRoleMemento;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">GameRoleCaretaker()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">GameRoleCaretaker()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;GameRoleMemento*&gt;::iterator it = m_vecGameRoleMemento.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_vecGameRoleMemento.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="constructor">SAFE_RELASE_POINTER(<span class="operator">*</span><span class="params">it</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_vecGameRoleMemento.clear<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">SaveGameRoleMemento(GameRoleMemento <span class="operator">*</span><span class="params">pGRM</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_vecGameRoleMemento.push<span class="constructor">_back(<span class="params">pGRM</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GameRoleMemento* <span class="constructor">LoadGameRoleMementoByIndex(<span class="params">int</span> GameRoleMementoIndex)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_vecGameRoleMemento<span class="literal">[G<span class="identifier">ameRoleMementoIndex</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试备忘录模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">MementoTest_GameRole()</span></span><br><span class="line">&#123;</span><br><span class="line">    GameRoleCaretaker *pGRCT = <span class="keyword">new</span> <span class="constructor">GameRoleCaretaker()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始属性状态</span></span><br><span class="line">    GameRole  *pGR = <span class="keyword">new</span> <span class="constructor">GameRole(50,50,50)</span>;</span><br><span class="line">    pGR-&gt;<span class="constructor">ShowAttribute()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//攻击一次后的状态，先保存,并显示属性</span></span><br><span class="line">    pGRCT-&gt;<span class="constructor">SaveGameRoleMemento(<span class="params">pGR</span>-&gt;CreateMemento()</span>);</span><br><span class="line">    pGR-&gt;<span class="constructor">Attack()</span>;</span><br><span class="line">    pGR-&gt;<span class="constructor">ShowAttribute()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//再攻击一次后的状态，先保存,并显示属性</span></span><br><span class="line">    pGRCT-&gt;<span class="constructor">SaveGameRoleMemento(<span class="params">pGR</span>-&gt;CreateMemento()</span>);</span><br><span class="line">    pGR-&gt;<span class="constructor">Attack()</span>;</span><br><span class="line">    pGR-&gt;<span class="constructor">ShowAttribute()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复第二次攻击前的状态,并显示属性</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Game Role Restore 1： &quot;</span>;</span><br><span class="line">    pGR-&gt;<span class="constructor">SetMemento(<span class="params">pGRCT</span>-&gt;LoadGameRoleMementoByIndex(1)</span>);</span><br><span class="line">    pGR-&gt;<span class="constructor">ShowAttribute()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//恢复第一次攻击前的状态,并显示属性</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Game Role Restore 0： &quot;</span>;</span><br><span class="line">    pGR-&gt;<span class="constructor">SetMemento(<span class="params">pGRCT</span>-&gt;LoadGameRoleMementoByIndex(0)</span>);</span><br><span class="line">    pGR-&gt;<span class="constructor">ShowAttribute()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pGRCT</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pGR</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果:</p>
<pre><code>Hero Attribution: [Agile]:50 [Power]:50 [Intelligence]:50
Hero Attribution: [Agile]:50 [Power]:40 [Intelligence]:50
Hero Attribution: [Agile]:50 [Power]:30 [Intelligence]:50
Game Role Restore 1： Hero Attribution: [Agile]:50 [Power]:40 [Intelligence]:50
Game Role Restore 0： Hero Attribution: [Agile]:50 [Power]:50 [Intelligence]:50
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式(结构型)</title>
    <url>/2018/06/16/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在使用Visual Studio开发应用程序时候，在完成代码后，大家都习惯的点击Build按钮完成代码的编译链接过程，其实在IDE内部进行了一系列的操作：先Scanner扫描，后Parser解析，而后MidcodeGenerator产生中间代码，最后MachcodeGenerator产生最终的机器码。IDE的好处就是界面对客户来说非常简洁，内部的各个子系统对客户来说是隐藏的，客户也没必要知道，只需一个按钮即可。这个按钮与本文要介绍的外观模式很类似。</p>
<span id="more"></span>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><hr>
<p>外观模式,通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便</p>
<blockquote>
<p>在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互即可<br>外观类(Facade):充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互<br>子系统(Subsystem)：在外观模式中，那些需要交互的业务类称为子系统</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Facade<br>知道哪些子系统类负责处理请求<br>将客户的请求代理给适当的子系统对象</p>
</li>
<li><p>Subsystem<br>实现子系统的功能<br>处理由Facade对象指派的任务<br>没有Facade的任何相关信息；即没有指向facade的指针</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/06/16/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/Facade.jpg" alt="facade"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义两个子系统类,及操作接口：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operateA</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Subsytem A operate&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubsystemB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operateB</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Subsytem B operate&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>再定义Facade类，该类封装了子系统的内部的操作：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外观类</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Facade</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> facadeOperate(<span class="built_in">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SubsystemA sa;</span><br><span class="line">        SubsystemB sb;</span><br><span class="line">        sa.operateA();</span><br><span class="line">        sb.operateB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试外观模式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FacadeTest</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Facade facade;</span><br><span class="line">    facade.facadeOperate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Subsytem A operate
Subsytem B operate
</code></pre>
<h3 id="对外观模式的改进"><a href="#对外观模式的改进" class="headerlink" title="对外观模式的改进"></a>对外观模式的改进</h3><p>在标准的外观模式结构图中，如果要修改与外观类交互的子系统类，必须修改外观类或客户端代码，违背了开闭原则，可以通过引入“抽象外观”来对系统进行改进，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象,如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象外观类</span></span><br><span class="line"><span class="keyword">class</span> Facade </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> void total<span class="constructor">Operate(<span class="params">void</span>)</span> = <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体外观类</span></span><br><span class="line"><span class="keyword">class</span> ConcreteFacadeA : Facade </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> void total<span class="constructor">Operate(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SubSystemA subSystemA;</span><br><span class="line">        SubSystemB subSystemB;<span class="operator"></span></span><br><span class="line"><span class="operator">        ...    </span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">        </span>subSystemA.op<span class="literal">()</span>;</span><br><span class="line">        subSystemB.op<span class="literal">()</span>;<span class="operator"></span></span><br><span class="line"><span class="operator">        ...</span></span><br><span class="line"><span class="operator">    </span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体外观类</span></span><br><span class="line"><span class="keyword">class</span> ConcreteFacadeNewA : Facade </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">virtual</span> void total<span class="constructor">Operate(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SubSysteNewA subSystemNewA;</span><br><span class="line">        SubSystemB subSystemB;<span class="operator"></span></span><br><span class="line"><span class="operator">        ...    </span></span><br><span class="line"><span class="operator">           </span></span><br><span class="line"><span class="operator">        </span>subSystemNewA.op<span class="literal">()</span>;</span><br><span class="line">        subSystemB.op<span class="literal">()</span>;<span class="operator"></span></span><br><span class="line"><span class="operator">        ...</span></span><br><span class="line"><span class="operator">    </span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line">Facade *facade = <span class="keyword">new</span> <span class="constructor">ConcreteFacadeA()</span>;</span><br><span class="line">facade-&gt;total<span class="constructor">Operate()</span>;</span><br><span class="line"></span><br><span class="line">Facade *facadenew = <span class="keyword">new</span> <span class="constructor">ConcreteFacadeNewA()</span>;</span><br><span class="line">facadenew-&gt;total<span class="constructor">Operate()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式</li>
<li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度</li>
</ul>
<blockquote>
<p>通常来讲，仅需要一个Facade对象，因此Facade对象通常属于Singleton模式</p>
</blockquote>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>它对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目，并使得子系统使用起来更加方便</li>
<li>它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的</li>
<li>外观模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要</li>
</ul>
</li>
<li>缺点<ul>
<li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性</li>
</ul>
</li>
</ul>
<h2 id="外观模式具体实例"><a href="#外观模式具体实例" class="headerlink" title="外观模式具体实例"></a>外观模式具体实例</h2><hr>
<h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><p><strong>实现前言说描述的编译外观模型</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>各个子系统类:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Scanner</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Scan</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Scan SubSystem&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Parser</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Parse</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Parser SubSystem&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenMidCode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Generate Middle Code SubSytem&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GenMachineCode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Generate Machine Code SubSystem&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高层接口,CompileFacade类:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高层接口</span></span><br><span class="line"><span class="keyword">class</span> CompileFacade</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Compile()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Scanner scanner;</span><br><span class="line">        Parser  pareser;</span><br><span class="line">        GenMidCode genmidcode;</span><br><span class="line">        GenMachineCode genmachinecode;</span><br><span class="line"></span><br><span class="line">        scanner.<span class="constructor">Scan()</span>;</span><br><span class="line">        pareser.<span class="constructor">Parse()</span>;</span><br><span class="line">        genmidcode.<span class="constructor">GenCode()</span>;</span><br><span class="line">        genmachinecode.<span class="constructor">GenCode()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试Compile Facade模式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompileFacadeTest</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    CompileFacade compilefacade;</span><br><span class="line">    compilefacade.Compile();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果：</p>
<p> I am Scan SubSystem<br> I am Parser SubSystem<br> I am Generate Middle Code SubSytem<br> I am Generate Machine Code SubSystem</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式（创建型）</title>
    <url>/2017/09/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>上一篇简要介绍了OOD的设计原则及设计模式的基本概念，从本篇开始介绍包括创建型(5)&amp;结构型(7)&amp;行为型(11)总共<strong>23种</strong>基本的设计模式和简单的C++代码实现。本篇介绍<strong>工厂模式</strong>，包括以下三种模式：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<span id="more"></span>

<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><hr>
<p>在介绍工厂方法模式之前，先介绍下简单工厂模式</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个创建对象的工厂类，并提供相应的创建对象的接口，简单工厂模式并不把一个类的实例化延迟到子类(也不存在子类)</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Concrete Factory<br>提供创建对象的接口，可以使用一个create接口来进行硬编码，也可以针对不同具体产品提供不同的create接口</p>
</li>
<li><p>Abstract Product<br>抽象产品类，可以派生出多个具体产品</p>
</li>
<li><p>Concrete Product<br>具体产品类</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/09/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/SimpleFactory.jpg" alt="simple_factory"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义一个抽象产品类，只提供一个简单的<code>Show()</code>接口显示不同产品类型的打印:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Show</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后分别根据抽象产品派生两个不同的产品类:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">ProductA: <span class="symbol">public</span></span> <span class="symbol">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Product A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ProductB: <span class="symbol">public</span></span> <span class="symbol">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Show()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Product B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后定义一个简单的工厂类，并提供一个静态的create方法，通过硬编码的方法来创建对象:</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="type"></span></span><br><span class="line">    <span class="keyword">static</span> AbstractProduct* CreateProduct(int ProductType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ProductType)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="type"></span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="type"></span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="type"></span></span><br><span class="line">            <span class="keyword">return</span> NULL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//除了硬编码还可以通过根据不同的产品提供不同create接口来实现：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="type"></span></span><br><span class="line">    <span class="keyword">static</span> AbstractProduct* CreateProductA()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> AbstractProduct* CreateProductB()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试简单工厂:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SimpleFactoryTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractProduct *pPA = SimpleFactory::<span class="built_in">CreateProduct</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// AbstractProduct *pPA = SimpleFactory::CreateProductA;</span></span><br><span class="line">    pPA-&gt;<span class="built_in">Show</span>();</span><br><span class="line">    AbstractProduct *pPB = SimpleFactory::<span class="built_in">CreateProduct</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// AbstractProduct *pPA = SimpleFactory::CreateProductB;</span></span><br><span class="line">    pPB-&gt;<span class="built_in">Show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pPA; pPA = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pPB; pPB = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>I am Product A
I am Product B
</code></pre>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>比较简单的对象创建</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：简单</li>
<li>缺点：要增加新的产品类型时，就需要修改工厂类，这就违反了开放封闭原则</li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><hr>
<p>如果想在增加新的产品类型时候，不需要修改原来的工厂类，从而符合开放封闭原则，可以考虑使用工厂方法模式类定义一个抽象接口，并增加新的产品工厂类即可</p>
<h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>定义一个用于创建对象的接口让子类决定实例化哪一个类。工厂模式使一个类的实例化延迟到其子类</p>
<h3 id="参与者-1"><a href="#参与者-1" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Abstract Factory<br>声明工厂方法，该方法返回一个Abstract Product类型的对象。Abstract Factory也可以定义一个工厂方法的缺省实现，它返回一个缺省的Concrete Product对象；<br>工厂接口是工厂方法模式的核心，与调用者直接交互用来提供产品</p>
</li>
<li><p>Concrete Factory<br>Concrete Factory决定如何实例化产品，是实现扩展的途径，需要有多少种产品，就需要有多少个具体的工厂实现；<br>重定义工厂方法以返回一个Concrete Product实例；</p>
</li>
<li><p>Abstract Product<br>抽象产品类，可以派生出多个具体产品</p>
</li>
<li><p>Concrete Product<br>具体产品类</p>
</li>
</ul>
<h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/09/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/FactoryMethod.jpg" alt="factory_method"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>抽象产品和具体的产品代码见上节的<strong>简单工厂模式</strong>的<em>代码实现</em>部分</p>
</li>
<li><p>与简单工厂模式不同的是，新增加了个抽象工厂类，提供一个virtual的create产品方法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProduct* <span class="title">CreateProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后针对不同的具体产品，定义不同的具体工厂类,并override抽象工厂的create产品方法:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品类A的具体工厂A</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">FactoryA: <span class="symbol">public</span></span> <span class="symbol">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AbstractProduct* CreateProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> new ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产品类B的具体工厂B</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">FactoryB: <span class="symbol">public</span></span> <span class="symbol">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AbstractProduct* CreateProduct()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> new ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试工厂方法模式:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void FactoryMethodTest()</span><br><span class="line">&#123;</span><br><span class="line">    AbstractFactory *pFA <span class="operator">=</span> new FactoryA()<span class="comment">; // 抽象的工厂指针指向具体的工厂对象</span></span><br><span class="line">    AbstractProduct *pPA <span class="operator">=</span> pFA-&gt;CreateProduct()<span class="comment">; // 抽象的产品指针具体的产品对象</span></span><br><span class="line">    pPA-&gt;Show()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    AbstractFactory *pFB <span class="operator">=</span> new FactoryB()<span class="comment">;</span></span><br><span class="line">    AbstractProduct *pPB<span class="operator">=</span> pFB-&gt;CreateProduct()<span class="comment">;</span></span><br><span class="line">    pPB-&gt;Show()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    delete pFA<span class="comment">; pFA = NULL;</span></span><br><span class="line">    delete pPA<span class="comment">; pPA = NULL;</span></span><br><span class="line">    delete pFB<span class="comment">; pFB = NULL;</span></span><br><span class="line">    delete pPB<span class="comment">; pPB = NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>I am Product A
I am Product B
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>当一个类不知道它所必须创建的对象的类的时候</li>
<li>当一个类希望由它的子类来指定它所创建的对象的时候</li>
<li>工厂模式是一种典型的解耦模式，迪米特法则在工厂模式中表现的尤为明显。<br>假如调用者自己组装产品需要增加依赖关系时，可以考虑使用工厂模式。将会大大降低对象之间的耦合度</li>
<li>需要系统有比较好的扩展性时，可以考虑工厂模式，不同的产品用不同的实现工厂来组装</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：<ul>
<li>可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，<br>  只需依赖工厂即可得到自己想要的产品</li>
<li>对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了，至于具体的实现，调用者根本无需关心。</li>
<li>降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的，即使变更了具体的实现，对调用者来说没有任何影响</li>
</ul>
</li>
<li>缺点：<br>新增加一个产品类型就需要引入一个工厂类，会增加系统的复杂度</li>
</ul>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><hr>
<h3 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h3><p>抽象工厂模式提供一个创建<strong>一系列</strong>相关或相互依赖对象的接口，而无需指定它们具体的类</p>
<h3 id="参与者-2"><a href="#参与者-2" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li>Abstract Factory<br>声明工厂方法，声明一个创建抽象产品对象的操作接口，通常含有多个创建接口对应于不同的产品族</li>
</ul>
<blockquote>
<p>所谓的产品族(也称为产品系列)，是指位于不同产品等级结构中功能相关联的产品组成的家族,在编程中，通常一个产品结构，表现为一个接口或者抽象类</p>
</blockquote>
<ul>
<li><p>Concrete Factory<br>Concrete Factory决定如何实例化产品，是实现扩展的途径，一般而言，多少种产品系列就有多少个具体工厂<br>重定义工厂方法以返回一个Concrete Product实例；</p>
</li>
<li><p>Abstract Product<br>抽象产品类，可以派生出多个具体产品</p>
</li>
<li><p>Concrete Product<br>具体产品类</p>
</li>
</ul>
<h3 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/09/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/AbstractFactory.jpg" alt="abstract_factory"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.抽象产品A(对应一个产品结构)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowA</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.抽象产品A派生的具体产品A1，A2</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">ProductA1</span> : <span class="symbol">public</span> <span class="symbol">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> ShowA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Product A1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ProductA2</span> : <span class="symbol">public</span> <span class="symbol">AbstractProductA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> ShowA()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Product A2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.抽象产品B(对应第二个产品结构)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowB</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.抽象产品B派生的具体产品B1，B2</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">ProductB1: <span class="symbol">public</span></span> <span class="symbol">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> ShowB()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Prouduct B1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ProductB2: <span class="symbol">public</span></span> <span class="symbol">AbstractProductB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> ShowB()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Prouduct B2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.抽象工厂，包括创建多个不同的产品等级的抽象接口，此类的产品等级分别为A，B</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractFactoryAB</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6.具体工厂，包含具体工厂1和工厂2，分别生成产品族1(A1,B1)和产品族2(A2,B2)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory1</span>: <span class="keyword">public</span> AbstractFactoryAB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory2</span>: <span class="keyword">public</span> AbstractFactoryAB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">AbstractProductA* <span class="title">CreateProductA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractProductB* <span class="title">CreateProductB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>7.测试抽象工厂模式：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void AbstractFactoryTest()</span><br><span class="line">&#123;</span><br><span class="line">    // 工厂<span class="number">1</span>生产产品族A1，B1</span><br><span class="line">    AbstractFactoryAB *pF1 <span class="operator">=</span> new Factory1()<span class="comment">;</span></span><br><span class="line">    AbstractProductA *pPA1 <span class="operator">=</span> pF1-&gt;CreateProductA()<span class="comment">;</span></span><br><span class="line">    pPA1-&gt;ShowA()<span class="comment">;</span></span><br><span class="line">    AbstractProductB *pPB1 <span class="operator">=</span> pF1-&gt;CreateProductB()<span class="comment">;</span></span><br><span class="line">    pPB1-&gt;ShowB()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    // 工厂<span class="number">2</span>生产产品族A2，B2</span><br><span class="line">    AbstractFactoryAB *pF2 <span class="operator">=</span> new Factory2()<span class="comment">;</span></span><br><span class="line">    AbstractProductA *pPA2 <span class="operator">=</span> pF2-&gt;CreateProductA()<span class="comment">;</span></span><br><span class="line">    pPA2-&gt;ShowA()<span class="comment">;</span></span><br><span class="line">    AbstractProductB *pPB2 <span class="operator">=</span> pF2-&gt;CreateProductB()<span class="comment">;</span></span><br><span class="line">    pPB2-&gt;ShowB()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    delete pF1<span class="comment">; pF1 = NULL;</span></span><br><span class="line">    delete pPA1<span class="comment">; pPA1 = NULL;</span></span><br><span class="line">    delete pPB1<span class="comment">; pPB1 = NULL;</span></span><br><span class="line">    delete pF2<span class="comment">; pF2 = NULL;</span></span><br><span class="line">    delete pPA2<span class="comment">; pPA2 = NULL;</span></span><br><span class="line">    delete pPB2<span class="comment">; pPB2 = NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<pre><code>I am Product A1
I am Prouduct B1
I am Product A2
I am Prouduct B2
</code></pre>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且<strong>分属各个等级结构中的实现类之间存在着一定的关联或者约束</strong>，就可以使用抽象工厂模式。<br>假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：<br>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。产品族一般或多或少的都存在一定的关联，抽象工厂模式就可以<strong>在类内部对产品族的关联关系进行定义和描述</strong>，而不必专门引入一个新的类来进行管理</li>
<li>缺点：<br>产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的</li>
</ul>
<h2 id="简单工厂模式-amp-工厂方法模式-amp-抽象工厂模式的区别"><a href="#简单工厂模式-amp-工厂方法模式-amp-抽象工厂模式的区别" class="headerlink" title="简单工厂模式&amp;工厂方法模式&amp;抽象工厂模式的区别"></a>简单工厂模式&amp;工厂方法模式&amp;抽象工厂模式的区别</h2><ul>
<li>此三者目的都是为了使一个系统独立于它的产品的创建、组合过程</li>
<li>简单工厂模式一般只提供一个具体的工厂，没有抽象的工厂；而工厂方法模式&amp;抽象工厂模式提供了抽象的工厂，更符合开闭原则</li>
<li>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象</li>
<li>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构</li>
<li>工厂方法模式所提供的具体产品是衍生自一个等级结构(接口或抽象类)；抽象工厂模式所提供的具体产品则是衍生自不同的等级结构(接口或抽象类)</li>
</ul>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Construction Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式(创建型)</title>
    <url>/2017/10/02/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><hr>
<p>建造者模式又称为生成器模式，是一种对象创建型模式，它将客户端与包含多个组成部分或部件的复杂对象的创建过程解耦，客户端无需知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。具体的建造者关注如何一步一步创建一个复杂对象，不同的具体创建者定义不同的创建过程，且它们之间相互独立，增加新的建造者非常方便，无需修改已有代码，系统扩展性好。</p>
<span id="more"></span>

<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Builder<br>为创建一个Product对象的各个部件指定抽象接口</p>
</li>
<li><p>Concrete Builer<br>实现Builder的接口以构造和装配该产品的各个部件；<br>定义并明确它所创建的表示；<br>提供一个检索产品的接口</p>
</li>
<li><p>Director<br>构造一个使用Builder接口的对象</p>
</li>
<li><p>Product<br>表示被构造的复杂对象，Concrete Builder 创建该产品的内部表示并定义它的装配过程；<br>包含定义组成部件的类，包括将这些部件装配成最终产品的接口</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li><p>基本的模式结构图<br><img src="http://www.taolingyang.com/2017/10/02/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/Builder.jpg" alt="builder"></p>
</li>
<li><p>各个参与者的协作图<br><img src="http://www.taolingyang.com/2017/10/02/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/Builder_Corp.PNG" alt="builder_corp"></p>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义抽象产品类，包括<code>AddPart()</code>和<code>ShowProduct()</code>分别定义组成Product的各个部分<br>及显示产品：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AbstractProduct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddPart</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span>* part</span>)</span> = <span class="number">0</span>; <span class="comment">//产品的部件操作接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowProduct</span>()</span> = <span class="number">0</span>; <span class="comment">// 打印显示产品</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再定义两个具体的产品ProductA、ProductB,并实现各自的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Product A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span>: <span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; m_VecPart;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddPart</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_VecPart.<span class="built_in">push_back</span>(part);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Product A!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;::iterator it = m_VecPart.<span class="built_in">begin</span>(); it != m_VecPart.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Product B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span>: <span class="keyword">public</span> AbstractProduct</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; m_VecPart;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddPart</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_VecPart.<span class="built_in">push_back</span>(part);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowProduct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Product B!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt;::iterator it = m_VecPart.<span class="built_in">begin</span>(); it != m_VecPart.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义抽象的Builder类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">AbstractBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuilderPart1</span>()</span> = <span class="number">0</span>; <span class="comment">// 构建产品部件1</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuilderPart2</span>()</span> = <span class="number">0</span>; <span class="comment">// 构建产品部件2</span></span><br><span class="line">    <span class="keyword">virtual</span> AbstractProduct* GetProduct() = <span class="number">0</span>; <span class="comment">// 获取构建的产品</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体两个Builder，BuilderA及BuilderB 分别构建和组装产品A和B：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Builder A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuilderA</span>: <span class="keyword">public</span> AbstractBuilder <span class="comment">//构建产品A内部部分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractProduct *m_pProduct; <span class="comment">// 被构建的抽象产品指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuilderA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pProduct = <span class="keyword">new</span> <span class="built_in">ProductA</span>(); <span class="comment">//构建产品A</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuilderPart1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pProduct-&gt;<span class="built_in">AddPart</span>(<span class="string">&quot;A Part 1 is Completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuilderPart2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pProduct-&gt;<span class="built_in">AddPart</span>(<span class="string">&quot;A Part 2 is Completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractProduct* <span class="title">GetProduct</span><span class="params">()</span> <span class="comment">// 返回构建的产品A</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Builder B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuilderB</span>: <span class="keyword">public</span> AbstractBuilder <span class="comment">//构建产品B内部部分</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractProduct *m_pProduct; <span class="comment">// 被构建的抽象产品指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuilderB</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pProduct = <span class="keyword">new</span> <span class="built_in">ProductB</span>(); <span class="comment">//构建产品B</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuilderPart1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pProduct-&gt;<span class="built_in">AddPart</span>(<span class="string">&quot;B Part 1 is Completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">BuilderPart2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pProduct-&gt;<span class="built_in">AddPart</span>(<span class="string">&quot;B Part 2 is Completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">AbstractProduct* <span class="title">GetProduct</span><span class="params">()</span> <span class="comment">// 返回构建的产品B</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pProduct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义引导者Director类，提供一个创建最终产品的接口，该接口使用Builder的方法来组装创建产品：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Director</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractBuilder *m_pBuilder;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Director(AbstractBuilder <span class="operator">*</span><span class="params">pbuilder</span>)</span>: m<span class="constructor">_pBuilder(<span class="params">pbuilder</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">CreateProduct()</span>      <span class="comment">// 组装整个产品</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pBuilder-&gt;<span class="constructor">BuilderPart1()</span>;</span><br><span class="line">        m_pBuilder-&gt;<span class="constructor">BuilderPart2()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试建造者模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuilderTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AbstractBuilder *pAB = <span class="keyword">new</span> <span class="built_in">BuilderA</span>();  <span class="comment">// 构建产品A</span></span><br><span class="line">    Director *pD = <span class="keyword">new</span> <span class="built_in">Director</span>(pAB);</span><br><span class="line">    pD-&gt;<span class="built_in">CreateProduct</span>();       <span class="comment">// 引导者负责通过 Builder 组装产品</span></span><br><span class="line">    AbstractProduct *pAP = pAB-&gt;<span class="built_in">GetProduct</span>();  <span class="comment">// 建造者负责 具体的Builder 组装产品，并提供获取产品接口</span></span><br><span class="line">    pAP-&gt;<span class="built_in">ShowProduct</span>();</span><br><span class="line"></span><br><span class="line">    AbstractBuilder *pAB2 = <span class="keyword">new</span> <span class="built_in">BuilderB</span>();   <span class="comment">// 构建产品B</span></span><br><span class="line">    Director *pD2 = <span class="keyword">new</span> <span class="built_in">Director</span>(pAB2);</span><br><span class="line">    pD2-&gt;<span class="built_in">CreateProduct</span>();       <span class="comment">// 引导者负责通过 Builder 组装产品</span></span><br><span class="line">    AbstractProduct *pAP2 = pAB2-&gt;<span class="built_in">GetProduct</span>();  <span class="comment">// 建造者负责 具体的Builder 组装产品，并提供获取产品接口</span></span><br><span class="line">    pAP2-&gt;<span class="built_in">ShowProduct</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pAB; pAB = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pD; pD = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pAP; pAP = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pAB2; pAB2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pD2; pD2 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pAP2; pAP2 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>I am Product A!
A Part 1 is Completed!
A Part 2 is Completed!
I am Product B!
B Part 1 is Completed!
B Part 2 is Completed!
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序</li>
<li>对象的创建过程独立于创建该对象的类，在Builder模式中通过引入Director类，将创建的过程封装在Director类中而非Builder或Client类中</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：<ul>
<li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象</li>
<li>当需要创建复杂对象的过程中，复杂对象没有多少共同的特点，很难抽象出来时，<br>  而复杂对象的组装又有一定的相似点时，建造者模式就可以发挥出作用</li>
<li>由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”</li>
<li>可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程</li>
</ul>
</li>
<li>缺点：<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本</li>
</ul>
</li>
</ul>
<h2 id="与工厂模式的区别"><a href="#与工厂模式的区别" class="headerlink" title="与工厂模式的区别"></a>与工厂模式的区别</h2><hr>
<p>都属于创建型的设计模式，所以二者之间是有公共点，但是建造者模式注重于对象组合，即不同的小对象组成一个整体的复杂大对象；而抽象工厂模式针对于接口编程，只是对外提供创建对象的工厂接口，不负责对象之后的处理</p>
<h2 id="建造者模式具体实例"><a href="#建造者模式具体实例" class="headerlink" title="建造者模式具体实例"></a>建造者模式具体实例</h2><hr>
<p><strong>构建一个人对象，包括胖和瘦两种类型，每个人都包含头、身体、手和脚四部分</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>抽象的ManBuilder类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象的人建造者类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ManBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 建造人的不同部位</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuilderHead</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuilderBody</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuilderHand</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuilderLeg</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体的两个建造者ThinBuilder和FatBuilder分别构建胖子和瘦子：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的瘦人建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThinBuilder</span>: <span class="title">public</span> <span class="title">ManBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderHead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thin Builder Head&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderBody</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thin Builder Body&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderHand</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thin Builder Hand&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderLeg</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Thin Builder Leg&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的胖人建造者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">FatBuilder</span>: <span class="title">public</span> <span class="title">ManBuilder</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderHead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fat Builder Head&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderBody</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fat Builder Body&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderHand</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fat Builder Hand&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuilderLeg</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Fat Builder Leg&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终创建人对象的ManDirector引导者类调用ManDirector的方法来组装和创建具体类型的人：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">class ManDirector</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    ManBuilder *m_pBuilder; <span class="comment">// 抽象的ManBuilder</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">ManDirector</span>(ManBuilder *pBuilder): <span class="built_in">m_pBuilder</span>(pBuilder) &#123;&#125;; </span><br><span class="line">    void <span class="built_in">CreateMan</span>() <span class="comment">// 使用ManBuilder的方法构建最终的Man</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pBuilder-&gt;<span class="built_in">BuilderHead</span>();</span><br><span class="line">        m_pBuilder-&gt;<span class="built_in">BuilderBody</span>();</span><br><span class="line">        m_pBuilder-&gt;<span class="built_in">BuilderHand</span>();</span><br><span class="line">        m_pBuilder-&gt;<span class="built_in">BuilderLeg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">ManBuilderTest()</span></span><br><span class="line">&#123;</span><br><span class="line">    ManBuilder *pMB = <span class="keyword">new</span> <span class="constructor">ThinBuilder()</span>;</span><br><span class="line">    ManDirector <span class="constructor">MD(<span class="params">pMB</span>)</span>;</span><br><span class="line">    MD.<span class="constructor">CreateMan()</span>;</span><br><span class="line"></span><br><span class="line">    ManBuilder *pMB2 = <span class="keyword">new</span> <span class="constructor">FatBuilder()</span>;</span><br><span class="line">    ManDirector <span class="constructor">MD2(<span class="params">pMB2</span>)</span>;</span><br><span class="line">    MD2.<span class="constructor">CreateMan()</span>;</span><br><span class="line"></span><br><span class="line">    delete pMB; pMB = NULL;</span><br><span class="line">    delete pMB2; pMB2 = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Thin Builder Head
Thin Builder Body
Thin Builder Hand
Thin Builder Leg
Fat Builder Head
Fat Builder Body
Fat Builder Hand
Fat Builder Leg
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Construction Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2016/06/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>排序算法是使一组无序的序列按照某种从小到大或从大到小的顺序输出的过程，主要分为<strong>内部排序</strong>和<strong>外部排序</strong>，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存，一般说的常用排序均是内部排序。</p>
<span id="more"></span>

<h2 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h2><hr>
<h3 id="常用排序算法分类"><a href="#常用排序算法分类" class="headerlink" title="常用排序算法分类"></a>常用排序算法分类</h3><hr>
<p>常用排序算法根据排序的原理方法一般分为：</p>
<ol>
<li>交换排序<br>交换排序包括<strong>冒泡排序</strong>和<strong>快速排序</strong></li>
<li>选择排序<br>选择排序包括<strong>简单选择排序</strong>和<strong>堆排序</strong></li>
<li>插入排序<br>插入排序包括<strong>直接插入排序</strong>和<strong>希尔排序</strong></li>
<li>归并排序</li>
<li>基数排序</li>
</ol>
<h3 id="常用排序算法时间空间复杂度及稳定性总结"><a href="#常用排序算法时间空间复杂度及稳定性总结" class="headerlink" title="常用排序算法时间空间复杂度及稳定性总结"></a>常用排序算法时间空间复杂度及稳定性总结</h3><hr>
<table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最坏情况</th>
<th align="center">最好情况</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(n²)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">简单选择排序</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">O(n²)</td>
<td align="center">O(n²)</td>
<td align="center">O(n)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">——</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(d(n+r))</td>
<td align="center">O(d(n+r))</td>
<td align="center">O(d(n+r))</td>
<td align="center">O(n+r)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><hr>
<h3 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>令数组长度为n<br>1.比较相邻的前后2个数据，如果前面数据大于后面的数据，就将二个数据交换<br>2.对数组的第0个数据到n-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第n-1个位置<br>3.令n&#x3D;n-1，如果n不为0就重复前面二步，否则排序完成</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 交换两个数</span></span><br><span class="line">void my<span class="constructor">Swap(<span class="params">int</span> &amp;<span class="params">a</span>, <span class="params">int</span> &amp;<span class="params">b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印长度为len的数组a[]第loop趟排序结果</span></span><br><span class="line">void my<span class="constructor">Print(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>, <span class="params">int</span> <span class="params">loop</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;loop[&quot;</span> &lt;&lt; loop &lt;&lt; <span class="string">&quot;]: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; a<span class="literal">[<span class="identifier">i</span>]</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 冒泡排序*/</span></span><br><span class="line">void bubble<span class="constructor">Sort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; len-i-<span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">j</span>]</span> &gt; a<span class="literal">[<span class="identifier">j</span>+<span class="number">1</span>]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">j</span>], <span class="params">a</span>[<span class="params">j</span>+1])</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序改进1"><a href="#冒泡排序改进1" class="headerlink" title="冒泡排序改进1"></a>冒泡排序改进1</h3><hr>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>对冒泡排序常见的改进方法是加入一标志性变量isExitExchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 改进的冒泡排序1</span></span><br><span class="line"><span class="comment">增加某一趟是否有交换的记录，没有则认为已经排序完成，否则没有排序完成，继续交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">void bubble<span class="constructor">SortByIsExistExchange(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> isExitExchange = <span class="literal">true</span>; <span class="comment">// 第一次假定存在交换</span></span><br><span class="line">    <span class="built_in">int</span> tmpLen = len-<span class="number">1</span>; <span class="comment">//若存在交换，下一次for循环遍历的长度,</span></span><br><span class="line">                        <span class="comment">//初始化为len-1,因为for循环从0开始，且数组索引有i+1</span></span><br><span class="line">    <span class="keyword">while</span> (isExitExchange)  </span><br><span class="line">    &#123;</span><br><span class="line">        isExitExchange = <span class="literal">false</span>; <span class="comment">//默认是不存在交换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tmpLen; i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &gt; a<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">i</span>+1])</span>;</span><br><span class="line">                isExitExchange = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>)</span>;</span><br><span class="line">        tmpLen--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="冒泡排序改进2"><a href="#冒泡排序改进2" class="headerlink" title="冒泡排序改进2"></a>冒泡排序改进2</h3><hr>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>进一步的，可以增加记录某一趟遍历最后一次交换的位置，下一次从头开始遍历的时候就可以从记录的位置索引为长度开始跳跃着交换，而不需要每次长度只递减1</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*改进的冒泡排序2</span></span><br><span class="line"><span class="comment">增加记录某一趟遍历最后一次交换的位置，下一次从头开始遍历的时候就可以从记录的位置索引为长度开始跳跃着交换，而不需要每次长度只递减1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">void bubble<span class="constructor">SortByRecordLastSwapIndex(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> lastSwapInex = len - <span class="number">1</span>; <span class="comment">//若存在交换，下一次for循环遍历的长度,初始化为len-1</span></span><br><span class="line">    <span class="built_in">int</span> swapFlag = lastSwapInex; <span class="comment">//swapFlag: 是否继续交换的标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (swapFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        lastSwapInex = swapFlag; <span class="comment">// 根据上一次记录的最后交换索引，更新本次for循环的长度</span></span><br><span class="line">        swapFlag = <span class="number">0</span>;  <span class="comment">// 默认是0，不继续</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; lastSwapInex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &gt; a<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">i</span>+1])</span>;</span><br><span class="line">                swapFlag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序结果打印"><a href="#冒泡排序结果打印" class="headerlink" title="冒泡排序结果打印"></a>冒泡排序结果打印</h3><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[0]: 1 6 8 4 5 6 9 19 3 0 2 25
loop[1]: 1 6 4 5 6 8 9 3 0 2 19 25
loop[2]: 1 4 5 6 6 8 3 0 2 9 19 25
loop[3]: 1 4 5 6 6 3 0 2 8 9 19 25
loop[4]: 1 4 5 6 3 0 2 6 8 9 19 25
loop[5]: 1 4 5 3 0 2 6 6 8 9 19 25
loop[6]: 1 4 3 0 2 5 6 6 8 9 19 25
loop[7]: 1 3 0 2 4 5 6 6 8 9 19 25
loop[8]: 1 0 2 3 4 5 6 6 8 9 19 25
loop[9]: 0 1 2 3 4 5 6 6 8 9 19 25
loop[10]: 0 1 2 3 4 5 6 6 8 9 19 25
loop[11]: 0 1 2 3 4 5 6 6 8 9 19 25
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><hr>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>思想是<strong>分治</strong> 和<strong>递归</strong></p>
<ol>
<li>确定基准值(一般是序列第一个位置、最后一个位置或中间位置)</li>
<li>从序列后面开始向前找元素，若小于基准值则交换之，否则继续前向步进，直到找到一个满足条件的值</li>
<li>从序列前面开始向后找元素，若大于基准值则交换之(元素与上一次的交换操作的结果进行交换)，否则继续向后步进，直到找到一个满足条件的值；</li>
<li>重复2~3操作，直到基准值左边的元素均不大于基准值，基准值右边的元素均不小于基准值，分为了左半部分和右半部分</li>
<li>分别对左半部分和右半部分重复1~4的操作</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*进行经过1~4步操作,并返回基准值的位置*/</span></span><br><span class="line"><span class="built_in">int</span> get<span class="constructor">PartionIndex(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> stardardValue = a<span class="literal">[<span class="identifier">left</span>]</span>; <span class="comment">// 初始化基准值为序列第一个位置的值</span></span><br><span class="line">    <span class="built_in">int</span> i = left; <span class="comment">// 初始i,j</span></span><br><span class="line">    <span class="built_in">int</span> j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) <span class="comment">// 循环继续条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ((i &lt; j)<span class="operator"> &amp;&amp; </span>(a<span class="literal">[<span class="identifier">j</span>]</span> &gt;= stardardValue)) <span class="comment">//从后面元素开始向前遍历，未找到满足条件继续步进</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">j</span>])</span>;  <span class="comment">//找到了一个小于stardardValue，则交换</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((i &lt; j)<span class="operator"> &amp;&amp; </span>(a<span class="literal">[<span class="identifier">i</span>]</span> &lt;= stardardValue)) <span class="comment">//从前面元素开始向后遍历，未找到满足条件继续步进</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">j</span>])</span>; <span class="comment">//找到了一个大于stardardValue，则交换</span></span><br><span class="line">    &#125;</span><br><span class="line">    my<span class="constructor">Print(<span class="params">a</span>, <span class="params">right</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line">void quick<span class="constructor">Sort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) <span class="comment">// 递归终止条件</span></span><br><span class="line">    &#123; </span><br><span class="line">       <span class="comment">//获取基准位置，使基准位置左边数不比基准大，右边数不比基准小</span></span><br><span class="line">        <span class="built_in">int</span> stardardValueIndex = get<span class="constructor">PartionIndex(<span class="params">a</span>, <span class="params">left</span>, <span class="params">right</span>)</span>; </span><br><span class="line">        quick<span class="constructor">Sort(<span class="params">a</span>, <span class="params">left</span>, <span class="params">stardardValueIndex</span> - 1)</span>; <span class="comment">// 快排左边的部分</span></span><br><span class="line">        quick<span class="constructor">Sort(<span class="params">a</span>, <span class="params">stardardValueIndex</span> + 1, <span class="params">right</span>)</span>; <span class="comment">// 快排右边的部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序结果打印"><a href="#快速排序结果打印" class="headerlink" title="快速排序结果打印"></a>快速排序结果打印</h3><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[1]: 0 1 8 9 4 5 6 25 19 3 6
loop[8]: 0 1 2 6 4 5 6 3 8 19 25
loop[2]: 0 1 2 6 4 5 6
loop[7]: 0 1 2 3 4 5 6
loop[3]: 0 1 2 3 4 5
loop[4]: 0 1 2 3 4 5
loop[5]: 0 1 2 3 4 5
loop[10]: 0 1 2 3 4 5 6 6 8 9 19
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><hr>
<h3 id="简单选择排序-1"><a href="#简单选择排序-1" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><hr>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接播放排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后</p>
<ol>
<li>初始时，数组全为无序区为a[0~n-1]</li>
<li>在无序区a[i<del>n-1]中选取一个最小的元素，将其与a[i]交换。交换之后a[0</del>i]就形成了一个有序区</li>
<li>i++并重复第二步直到i—&gt;n-1排序完成</li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取长度为len的序列a[] 从索引index开始到len-1范围序列的最小值的索引</span></span><br><span class="line"><span class="built_in">int</span> get<span class="constructor">MinValueIndex(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>, <span class="params">int</span> <span class="params">index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minValue = a<span class="literal">[<span class="identifier">index</span>]</span>;</span><br><span class="line">    <span class="built_in">int</span> minValueInex = index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = index + <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &lt; minValue)</span><br><span class="line">        &#123;</span><br><span class="line">            minValue = a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">            minValueInex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return minValueInex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从i ~ len中选择最小值，放到索引为i的位置(i = 0 ~ len（外层循环)）</span></span><br><span class="line">void simple<span class="constructor">SelectSort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minValueInex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        minValueInex = get<span class="constructor">MinValueIndex(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (minValueInex != i)</span><br><span class="line">        &#123;</span><br><span class="line">            my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">minValueInex</span>])</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单选择排序2"><a href="#简单选择排序2" class="headerlink" title="简单选择排序2"></a>简单选择排序2</h3><hr>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>通过依次比较和交换来完成选择最小值</p>
<p>####代码实现</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//内层循环从i+1 ~ len中依次与i进行比较，选择最小值，放到索引为i的位置(i = 0 ~ len（外层循环)）</span></span><br><span class="line">void simple<span class="constructor">SelectSort2(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">j</span>]</span> &lt; a<span class="literal">[<span class="identifier">i</span>]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">j</span>], <span class="params">a</span>[<span class="params">i</span>])</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单选择排序3-二元选择排序"><a href="#简单选择排序3-二元选择排序" class="headerlink" title="简单选择排序3(二元选择排序)"></a>简单选择排序3(二元选择排序)</h3><hr>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>通过每次遍历同时选择最小值和最大值，减少遍历次数为n&#x2F;2</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二元选择排序，每次从i ~ len-i中选择最大值和最小值，然后分别放入i和len-i-1的位置(i = 0 ~ len/2)</span></span><br><span class="line">void simple<span class="constructor">SelectSort3(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> minValueIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++) <span class="comment">// i只需0~len/2</span></span><br><span class="line">    &#123;</span><br><span class="line">        minValueIndex = i;</span><br><span class="line">        maxValueIndex = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = i+<span class="number">1</span>; j &lt; len-i; j++) <span class="comment">//遍历i~len-i获取最大值和最小值索引</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">j</span>]</span> &gt; a<span class="literal">[<span class="identifier">maxValueIndex</span>]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                maxValueIndex = j;</span><br><span class="line">                continue; <span class="comment">// 满足大于当前最大值条件就没必要去下面比较最小值了</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">j</span>]</span> &lt; a<span class="literal">[<span class="identifier">minValueIndex</span>]</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                minValueIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minValueIndex != i)</span><br><span class="line">        &#123;</span><br><span class="line">            my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">i</span>], <span class="params">a</span>[<span class="params">minValueIndex</span>])</span>; <span class="comment">// 获取的最小值与a[i]交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex != len-i-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            my<span class="constructor">Swap(<span class="params">a</span>[<span class="params">len</span>-<span class="params">i</span>-1], <span class="params">a</span>[<span class="params">maxValueIndex</span>])</span>; <span class="comment">// 获取的最大值与a[len-i-1]交换</span></span><br><span class="line">        &#125;</span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单选择排序结果打印"><a href="#简单选择排序结果打印" class="headerlink" title="简单选择排序结果打印"></a>简单选择排序结果打印</h3><hr>
<pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[0]: 0 6 8 9 4 5 6 25 19 3 1 2
loop[1]: 0 1 8 9 4 5 6 25 19 3 6 2
loop[2]: 0 1 2 9 4 5 6 25 19 3 6 8
loop[3]: 0 1 2 3 4 5 6 25 19 9 6 8
loop[4]: 0 1 2 3 4 5 6 25 19 9 6 8
loop[5]: 0 1 2 3 4 5 6 25 19 9 6 8
loop[6]: 0 1 2 3 4 5 6 25 19 9 6 8
loop[7]: 0 1 2 3 4 5 6 6 19 9 25 8
loop[8]: 0 1 2 3 4 5 6 6 8 9 25 19
loop[9]: 0 1 2 3 4 5 6 6 8 9 25 19
loop[10]: 0 1 2 3 4 5 6 6 8 9 19 25
loop[11]: 0 1 2 3 4 5 6 6 8 9 19 25
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><hr>
<p>二叉堆是完全二叉树或者是近似完全二叉树。二叉堆满足二个特性：<br>1.父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值<br>2.每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）<br>当父结点的键值总是大于或等于任何一个子节点的键值时为<strong>最大堆</strong><br>当父结点的键值总是小于或等于任何一个子节点的键值时为<strong>最小堆</strong></p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>最小堆排序：(从大到小顺序)<br>1.建立最小堆<br>2.交换堆顶(最小值)和末尾位置<br>3.向下重新调整最小堆(不包括末尾位置)<br>4.循环2~3步骤(末尾位置不断变小)</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向下调整最小堆：当前位置index, 左右孩子节点分别为2*index+1和2*index+2</span></span><br><span class="line"><span class="comment">// 最小值上浮过程</span></span><br><span class="line">void down<span class="constructor">AdjustMinHeap(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>, <span class="params">int</span> <span class="params">index</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sonIndex = <span class="number">2</span><span class="operator"> * </span>index + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> tmp = a<span class="literal">[<span class="identifier">index</span>]</span>; <span class="comment">// 交换第一步</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (sonIndex &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sonIndex+<span class="number">1</span> &lt; len)<span class="operator"> &amp;&amp; </span>(a<span class="literal">[<span class="identifier">sonIndex</span>+<span class="number">1</span>]</span> &lt; a<span class="literal">[<span class="identifier">sonIndex</span>]</span>)) <span class="comment">// 获取左右孩子节点的较小值的索引</span></span><br><span class="line">        &#123;</span><br><span class="line">            sonIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">sonIndex</span>]</span> &gt;= tmp)    <span class="comment">// 若孩子结点不比当前值小，则退出</span></span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若孩子结点比当前值小，则交换之</span></span><br><span class="line">        a<span class="literal">[<span class="identifier">index</span>]</span> = a<span class="literal">[<span class="identifier">sonIndex</span>]</span>; <span class="comment">// 交换第二步</span></span><br><span class="line">        index = sonIndex;</span><br><span class="line"></span><br><span class="line">        sonIndex = <span class="number">2</span><span class="operator"> * </span>index + <span class="number">1</span>; <span class="comment">//继续后续孩子结点比较</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a<span class="literal">[<span class="identifier">index</span>]</span> = tmp;  <span class="comment">// 交换第三步,注意，此处索引为index,非sonIndex（因为sonIndex已经运算了一次sonIndex = 2*index + 1了）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立最小堆：从堆中最下面的非叶子节点(总共len/2-1个非叶子节点)开始依次往上使用(直到索引为0)向下调整最小堆的方法</span></span><br><span class="line">void build<span class="constructor">MinHeap(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = len/<span class="number">2</span>-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        down<span class="constructor">AdjustMinHeap(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;build min heap result: &quot;</span>;</span><br><span class="line">    my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小堆排序</span></span><br><span class="line">void min<span class="constructor">HeapSort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    build<span class="constructor">MinHeap(<span class="params">a</span>, <span class="params">len</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = len-<span class="number">1</span>; i &gt;=<span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        my<span class="constructor">Swap(<span class="params">a</span>[0], <span class="params">a</span>[<span class="params">i</span>])</span>;</span><br><span class="line">        down<span class="constructor">AdjustMinHeap(<span class="params">a</span>, <span class="params">i</span>, 0)</span>; <span class="comment">// 每次都是从根节点0</span></span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>, <span class="params">i</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序结果打印"><a href="#堆排序结果打印" class="headerlink" title="堆排序结果打印"></a>堆排序结果打印</h3><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
build min heap result: loop[0]: 0 1 2 9 3 5 6 25 19 6 4 8
loop[11]: 1 3 2 9 4 5 6 25 19 6 8 0
loop[10]: 2 3 5 9 4 8 6 25 19 6 1 0
loop[9]: 3 4 5 9 6 8 6 25 19 2 1 0
loop[8]: 4 6 5 9 19 8 6 25 3 2 1 0
loop[7]: 5 6 6 9 19 8 25 4 3 2 1 0
loop[6]: 6 9 6 25 19 8 5 4 3 2 1 0
loop[5]: 6 9 8 25 19 6 5 4 3 2 1 0
loop[4]: 8 9 19 25 6 6 5 4 3 2 1 0
loop[3]: 9 25 19 8 6 6 5 4 3 2 1 0
loop[2]: 19 25 9 8 6 6 5 4 3 2 1 0
loop[1]: 25 19 9 8 6 6 5 4 3 2 1 0
after sorted print:
loop[0]: 25 19 9 8 6 6 5 4 3 2 1 0
</code></pre>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><hr>
<h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>将一个记录插入到一个已经排序好的序列中，从而得到一个新的，记录数+1的有序序列<br>即先将有序序列第一个元素当成有序序列，然后从第二个元素开始依次逐个进行插入，直到整个序列有序为止</p>
<ol>
<li>初始时，a[0]自成1个有序区，无序区为a[1~n-1]。令i&#x3D;1</li>
<li>将a[i]并入当前的有序区a[0<del>i-1]中形成a[0</del>i]的有序区间。</li>
<li>i++并重复第二步直到i—&gt;n-1排序完成。</li>
</ol>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*直接的插入排序</span></span><br><span class="line"><span class="comment">从哨兵开始从后向前比较</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> directInsertSort(<span class="built_in">int</span> a[], <span class="built_in">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[i<span class="number">-1</span>]) <span class="comment">// 哨兵前一个元素比哨兵大则进行后移操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> tmp = a[i]; <span class="comment">// 暂存当前哨兵值</span></span><br><span class="line">            <span class="built_in">int</span> <span class="keyword">index</span> = i - <span class="number">1</span>; <span class="comment">// 暂存当前哨兵前一个元素的值</span></span><br><span class="line">            a[i] = a[i<span class="number">-1</span>]; <span class="comment">// 后移一位当前哨兵值的前一个元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (a[<span class="keyword">index</span>] &gt; tmp)  <span class="comment">// 若当前哨兵值前面多个序列元素比哨兵值大，则哨兵值前面序列的较大元素依次循环后移</span></span><br><span class="line">            &#123;</span><br><span class="line">                a[<span class="keyword">index</span> + <span class="number">1</span>] = a[<span class="keyword">index</span>];</span><br><span class="line">                <span class="keyword">index</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">            a[<span class="keyword">index</span> + <span class="number">1</span>] = tmp; <span class="comment">// 当前哨兵值插入合适为止，使当前哨兵值前一个元素刚好不大于其值</span></span><br><span class="line">        &#125;</span><br><span class="line">        myPrint(a, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接插入排序结果打印"><a href="#直接插入排序结果打印" class="headerlink" title="直接插入排序结果打印"></a>直接插入排序结果打印</h3><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[1]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[2]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[3]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[4]: 1 4 6 8 9 5 6 25 19 3 0 2
loop[5]: 1 4 5 6 8 9 6 25 19 3 0 2
loop[6]: 1 4 5 6 6 8 9 25 19 3 0 2
loop[7]: 1 4 5 6 6 8 9 25 19 3 0 2
loop[8]: 1 4 5 6 6 8 9 19 25 3 0 2
loop[9]: 1 3 4 5 6 6 8 9 19 25 0 2
loop[10]: 0 1 3 4 5 6 6 8 9 19 25 2
loop[11]: 0 1 2 3 4 5 6 6 8 9 19 25
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><hr>
<h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的</p>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通用的插入排序</span></span><br><span class="line"><span class="comment">直接插入排序中dk = 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">void shell<span class="constructor">InsertSort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>, <span class="params">int</span> <span class="params">dk</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = dk; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &lt; a<span class="literal">[<span class="identifier">i</span>-<span class="identifier">dk</span>]</span>) <span class="comment">// 哨兵前dk距离的元素比哨兵大则进行后移操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> tmp = a<span class="literal">[<span class="identifier">i</span>]</span>;  <span class="comment">// 暂存当前哨兵值</span></span><br><span class="line">            <span class="built_in">int</span> index = i - dk; <span class="comment">// 暂存当前哨兵前dk距离的元素的值</span></span><br><span class="line">            a<span class="literal">[<span class="identifier">i</span>]</span> = a<span class="literal">[<span class="identifier">i</span>-<span class="identifier">dk</span>]</span>; <span class="comment">// 后移dk位当前哨兵值的前dk距离的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (a<span class="literal">[<span class="identifier">index</span>]</span> &gt; tmp) <span class="comment">// 若当前哨兵值前面多个距离为dk的序列元素比哨兵值大，则哨兵值前面序列的较大元素依次循环后移</span></span><br><span class="line">            &#123;</span><br><span class="line">                a<span class="literal">[<span class="identifier">index</span> + <span class="identifier">dk</span>]</span> = a<span class="literal">[<span class="identifier">index</span>]</span>;</span><br><span class="line">                index -= dk;</span><br><span class="line">            &#125;</span><br><span class="line">            a<span class="literal">[<span class="identifier">index</span> + <span class="identifier">dk</span>]</span> = tmp; <span class="comment">// 当前哨兵值插入合适为止，使当前哨兵值前dk距离的元素刚好不大于其值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">希尔排序： dk = len/2,len/4....,1;</span></span><br><span class="line"><span class="comment">减少增量的直接插入排序，直到增量为1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">void shell<span class="constructor">Sort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> dk = len<span class="operator"> / </span><span class="number">2</span>; <span class="comment">//dk = len/2,len/4....,1;</span></span><br><span class="line">    <span class="keyword">while</span> (dk &gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        shell<span class="constructor">InsertSort(<span class="params">a</span>, <span class="params">len</span>, <span class="params">dk</span>)</span>;</span><br><span class="line">        dk /= <span class="number">2</span>;</span><br><span class="line">        my<span class="constructor">Print(<span class="params">a</span>, <span class="params">len</span>, <span class="params">dk</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序结果打印"><a href="#希尔排序结果打印" class="headerlink" title="希尔排序结果打印"></a>希尔排序结果打印</h3><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[3]: 1 6 8 3 0 2 6 25 19 9 4 5
loop[1]: 1 0 2 3 4 5 6 6 8 9 25 19
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><hr>
<h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><p>基本思想是<strong>分治</strong><br>先递归序列拆成多个有序序列，直到每个序列有一个元素，然后再合并有序序列</p>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的合并两个有序序列a[len_a]和b[len_b]到最终有序序列res[]中</span></span><br><span class="line">void common<span class="constructor">MergeSortedSequence(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">len_a</span>, <span class="params">int</span> <span class="params">b</span>[], <span class="params">int</span> <span class="params">len_b</span>, <span class="params">int</span> <span class="params">res</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len_a<span class="operator"> &amp;&amp; </span>j &lt; len_b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &lt; b<span class="literal">[<span class="identifier">j</span>]</span>) <span class="comment">//结果中存入较小的a元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>          <span class="comment">//结果中存入较小的b元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = b<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; len_a) <span class="comment">// 结果中存入剩余的a元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (j &lt; len_b) <span class="comment">// 结果中存入剩余的b元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = b<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*归并排序*/</span></span><br><span class="line"><span class="comment">//合并有序序列a[left, mid]和 a[mid+1, right]到最终有序序列res[]中,初始化left = 0, right = len-1</span></span><br><span class="line"></span><br><span class="line">void merge<span class="constructor">Array(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">mid</span>, <span class="params">int</span> <span class="params">right</span>, <span class="params">int</span> <span class="params">res</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i = left; <span class="comment">// i 从[left,mid]包括mid</span></span><br><span class="line">    <span class="built_in">int</span> j = mid+<span class="number">1</span>;  <span class="comment">// j 从[mid+1,right]包括right</span></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid<span class="operator"> &amp;&amp; </span>j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &lt; a<span class="literal">[<span class="identifier">j</span>]</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">    &#123;</span><br><span class="line">        res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">i</span><span class="operator">++</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        res<span class="literal">[<span class="identifier">index</span><span class="operator">++</span>]</span> = a<span class="literal">[<span class="identifier">j</span><span class="operator">++</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将合并结果res[]赋给a[left,right),保持a[]有序，以便下面递归使用</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a<span class="literal">[<span class="identifier">left</span> + <span class="identifier">i</span>]</span> = res<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my<span class="constructor">Print(<span class="params">res</span>, <span class="params">index</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">void merge<span class="constructor">Sort(<span class="params">int</span> <span class="params">a</span>[], <span class="params">int</span> <span class="params">left</span>, <span class="params">int</span> <span class="params">right</span>, <span class="params">int</span> <span class="params">res</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left  &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        merge<span class="constructor">Sort(<span class="params">a</span>, <span class="params">left</span>, <span class="params">mid</span>, <span class="params">res</span>)</span>; <span class="comment">// 递归归并排序左边的有序序列</span></span><br><span class="line">        merge<span class="constructor">Sort(<span class="params">a</span>, <span class="params">mid</span>+1, <span class="params">right</span>, <span class="params">res</span>)</span>; <span class="comment">//递归 归并排序右边的有序序列</span></span><br><span class="line">        merge<span class="constructor">Array(<span class="params">a</span>, <span class="params">left</span>, <span class="params">mid</span>, <span class="params">right</span>, <span class="params">res</span>)</span>; <span class="comment">// 合并有序的左边和右边有序序列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序结果打印"><a href="#归并排序结果打印" class="headerlink" title="归并排序结果打印"></a>归并排序结果打印</h3><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[0]: 1 6
loop[0]: 1 6 8
loop[0]: 4 9
loop[0]: 4 5 9
loop[0]: 1 4 5 6 8 9
loop[0]: 6 25
loop[0]: 6 19 25
loop[0]: 0 3
loop[0]: 0 2 3
loop[0]: 0 2 3 6 19 25
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h2 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h2><hr>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><hr>
<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ol>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组CountArray的第i项</li>
<li>对所有的计数累加（从CountArray中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第CountArray(i)项，每放一个元素就将CountArray(i)减去1</li>
</ol>
<h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; maxValue)</span><br><span class="line">        &#123;</span><br><span class="line">            maxValue = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">countSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> res[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(a, len);</span><br><span class="line">    <span class="type">int</span> *countArray = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue+<span class="number">1</span>]; <span class="comment">//  计数数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxValue+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[i] = <span class="number">0</span>;    <span class="comment">// 初始化计数数组为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[a[i]]++; <span class="comment">// 计数a[]中每个元素的个数存入计数数组，且索引为元素值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; maxValue+<span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        countArray[i] += countArray[i - <span class="number">1</span>]; <span class="comment">// 累加计数数组，最终计数数组中保存不小于元素值的计数个数，索引依然为元素值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> a[i]; <span class="comment">// 当前待排序元素a[i]值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortIndex</span> <span class="operator">=</span> countArray[element] - <span class="number">1</span>; <span class="comment">// 当前元素a[i]在最终排序后有序序列中的位置索引</span></span><br><span class="line">        res[sortIndex] = element; <span class="comment">// 将当前元素a[i]放在最终排序后有序序列中的相应位置上</span></span><br><span class="line">        countArray[element]--;  <span class="comment">// 每次放入一个后，个数减一调整之</span></span><br><span class="line">        myPrint(a, len, sortIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete []countArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序运行结果打印"><a href="#计数排序运行结果打印" class="headerlink" title="计数排序运行结果打印"></a>计数排序运行结果打印</h4><pre><code>before sorted print:
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
sorted process print:
loop[1]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[7]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[8]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[9]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[4]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[5]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[6]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[11]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[10]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[3]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[0]: 1 6 8 9 4 5 6 25 19 3 0 2
loop[2]: 1 6 8 9 4 5 6 25 19 3 0 2
after sorted print:
loop[0]: 0 1 2 3 4 5 6 6 8 9 19 25
</code></pre>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><hr>
<p>同计数排序一样，桶排序也对待排序序列作了假设，桶排序假设序列由一个随机过程产生，该过程将元素均匀而独立地分布在区间[0,1)上。基本思想是：把区间[0,1)划分成n个相同大小的子区间，称为桶。将n个记录分布到各个桶中去。如果有多于一个记录分到同一个桶中，需要进行桶内排序(可以使用快排)。最后依次把各个桶中的记录列出来记得到有序序列</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>在计数排序中，当k很大时，时间和空间的开销都会增大（可以想一下对序列{12344,33333,6666}用计数排序，此时不但浪费很多空间，而且时间方面还不如比较排序）。于是可以把待排序记录分解成个位(第一位)、十位(第二位)….然后分别以第一位、第二位…对整个序列进行计数排序。这样的话分解出来的每一位不超过9，即用计数排序序列中最大值是9了</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式(行为型)</title>
    <url>/2017/12/01/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在找工作写简历的时候，会发现网上有许多简历模板，这些简历模板都包含一些了解一个求职者的基本信息，包括个人基本信息，教育经历，工作经历等等，还有些非英语专业毕业的还需要包括CET的成绩，若英语专业则不需要。像这种简历模板只提供一个基本的模板，而具体的内容由具体的使用者(具体子类)实现的模式可以通过模板方式模式来实现。</p>
<span id="more"></span>

<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><hr>
<p>模板方法模式是一种基于<strong>继承</strong>的代码复用技术，它是一种类行为型模式<br>模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为<strong>模板方法</strong>的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些基本方法，从而使得相同的算法框架可以有不同的执行结果</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义了操作算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>AbstractClass<br>抽象类，定义抽象的原语操作(primitive operation)，具体的子类将重定义它们以实现一个算法<br>的各个步骤<br>实现一个模板方法,定义一个算法的骨架。该模板方法不仅调用原语操作，也调用定义在AbstractClass或其他对象中的操作</p>
</li>
<li><p>ConcreteClass<br>具体类，实现原语操作(primitive operation)以完成算法中与特定子类相关的步骤</p>
</li>
</ul>
<blockquote>
<p><strong>模板方法</strong>：定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法，模板方法是一个具体方法。它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口<br><strong>基本方法</strong>：基本方法是实现算法各个步骤的方法，是模板方法的组成部分，分为三类<br>1.抽象方法：抽象类声明、由其具体子类实现<br>2.具体方法：个具体方法由一个抽象类或具体类声明并实现，其子类可以进行重写也可以直接继承<br>3.钩子方法：由一个抽象类或具体类声明并实现，而其子类可能会加以扩展，一般来说有两种钩子方法，一种是父类是空的实现钩子方法，子类通过重写该方法来控制父类的流程；另一种是父类是个返回bool型的钩子方法，一般有个默认值，而子类通过重写该bool返回值的钩子方法，来控制父类的流程以实现在不同条件下执行模板方法中的不同步骤</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2017/12/01/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/Template.jpg" alt="template"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象类<code>AbstractFrameWork</code>,声明和实现模板方法<code>SkeletonOperator()</code>,并声明或实现相应的原语操作:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 骨架流程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">AbstractFrameWork</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// 声明为public 客户端调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SkeletonOperator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PrimitiveOperator1();</span><br><span class="line">        PrimitiveOperator2();</span><br><span class="line">        PrimitiveOperator3();</span><br><span class="line">        <span class="keyword">if</span> (isSupportPrimitiveOperator4())</span><br><span class="line">        &#123;</span><br><span class="line">            PrimitiveOperator4();</span><br><span class="line">        &#125;</span><br><span class="line">        PrimitiveOperator5();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:  </span><br><span class="line"><span class="comment">// 声明为protected 客户端不可见，子类可见, 也可以声明为private 对于virtual而言即使private属性也有多态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//父类抽象虚拟方法，必须被子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrimitiveOperator1</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrimitiveOperator2</span>()</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类具体普通方法，有默认实现，可以被子类覆盖（是有条件的,必须面对具体编程,且显式的直接调用PrimitiveOperator3,不能是模板方法SkeletonOperato）</span></span><br><span class="line">    <span class="comment">//最好是加virtual 子类就重写了该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator3</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PrimitiveOperator3 Default Implement&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 此时若在客户端通过基类指针来指向具体的子类对象(通过面对抽象编程)，此时不管指向哪个具体子类对象，调用的均是父类方法</span></span><br><span class="line">        因为没有<span class="keyword">virtual</span>,没有多态,是静态绑定的； 若想调用子类对象的方法，必须要面对具体对象编程，通过子类指针来指向子类对象，且显式的直接调用该方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父类具体虚拟方法，有默认实现，可以被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrimitiveOperator4</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;PrimitiveOperator4 Default Implement&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类具体钩子虚拟方法（默认是空的）,可以被子类重写,通过子类重写来控制父类的流程</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrimitiveOperator5</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父类具体钩子虚拟方法(返回bool类型）,可以被子类重写,通过子类重写来控制父类的流程</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">isSupportPrimitiveOperator4</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义三个具体的实现类<code>ConcreteImplementA</code>、<code>ConcreteImplementB</code>和<code>ConcreteImplementC</code>,并实现或重写相应的原语操作：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConcreteImplementA</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementA</span> : <span class="title">public</span> <span class="title">AbstractFrameWork</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement A Primitive Operator1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement A Primitive Operator2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator3</span>() <span class="comment">//覆盖了父类默认的普通方法PrimitiveOperator3，但是面对抽象编程时候子类该方法不会生效，除非父类该方法加virtual</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement A Primitive Operator3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator5</span>()  <span class="comment">// 重写了父类默认为空的钩子方法PrimitiveOperator5</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement A Primitive Operator5&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcreteImplementB</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementB</span> : <span class="title">public</span> <span class="title">AbstractFrameWork</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement B Primitive Operator1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement B Primitive Operator2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">isSupportPrimitiveOperator4</span>() <span class="comment">// 重写了父类默认返回true的钩子方法isSupportPrimitiveOperator4</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>/ConcreteImplementC</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteImplementC</span> : <span class="title">public</span> <span class="title">AbstractFrameWork</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement C Primitive Operator1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement C Primitive Operator2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator3</span>() <span class="comment">//覆盖了父类默认的普通方法PrimitiveOperator3，但是面对抽象编程时候子类该方法不会生效，除非父类该方法加virtual</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement C Primitive Operator3&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrimitiveOperator4</span>() <span class="comment">//重写了父类默认的虚方法PrimitiveOperator4</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ConcreteImplement C Primitive Operator4&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试模板方法模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">TemplateTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 面对抽象编程</span></span><br><span class="line">    AbstractFrameWork *pCI_A = <span class="keyword">new</span> <span class="constructor">ConcreteImplementA()</span>;</span><br><span class="line">    pCI_A-&gt;<span class="constructor">SkeletonOperator()</span>;</span><br><span class="line"></span><br><span class="line">    AbstractFrameWork *pCI_B = <span class="keyword">new</span> <span class="constructor">ConcreteImplementB()</span>;</span><br><span class="line">    pCI_B-&gt;<span class="constructor">SkeletonOperator()</span>;</span><br><span class="line"></span><br><span class="line">    AbstractFrameWork *pCI_C = <span class="keyword">new</span> <span class="constructor">ConcreteImplementC()</span>;</span><br><span class="line">    pCI_C-&gt;<span class="constructor">SkeletonOperator()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 面对具体编程</span></span><br><span class="line">    ConcreteImplementA *pC_A = <span class="keyword">new</span> <span class="constructor">ConcreteImplementA()</span>;</span><br><span class="line">    pC_A-&gt;<span class="constructor">SkeletonOperator()</span>;   <span class="comment">// 没有覆盖父类的方法，仍然调用的是父类的PrimitiveOperator3 Default Implement</span></span><br><span class="line">    pC_A-&gt;<span class="constructor">PrimitiveOperator3()</span>; <span class="comment">// 覆盖了父类的方法：ConcreteImplement A Primitive Operator3</span></span><br><span class="line">    ConcreteImplementC *pC_C = <span class="keyword">new</span> <span class="constructor">ConcreteImplementC()</span>;</span><br><span class="line">    pC_C-&gt;<span class="constructor">SkeletonOperator()</span>;   <span class="comment">// 没有覆盖父类的方法，仍然调用的是父类的PrimitiveOperator3 Default Implement</span></span><br><span class="line">    pC_C-&gt;<span class="constructor">PrimitiveOperator3()</span>; <span class="comment">// 覆盖了父类的方法：ConcreteImplement C Primitive Operator3</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCI_A</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCI_B</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCI_C</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pC_A</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pC_C</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果：</p>
<pre><code>ConcreteImplement A Primitive Operator1
ConcreteImplement A Primitive Operator2
PrimitiveOperator3 Default Implement
PrimitiveOperator4 Default Implement
ConcreteImplement A Primitive Operator5
ConcreteImplement B Primitive Operator1
ConcreteImplement B Primitive Operator2
PrimitiveOperator3 Default Implement
ConcreteImplement C Primitive Operator1
ConcreteImplement C Primitive Operator2
PrimitiveOperator3 Default Implement
ConcreteImplement C Primitive Operator4
ConcreteImplement A Primitive Operator1
ConcreteImplement A Primitive Operator2
PrimitiveOperator3 Default Implement
PrimitiveOperator4 Default Implement
ConcreteImplement A Primitive Operator5
ConcreteImplement A Primitive Operator3
ConcreteImplement C Primitive Operator1
ConcreteImplement C Primitive Operator2
PrimitiveOperator3 Default Implement
ConcreteImplement C Primitive Operator4
ConcreteImplement C Primitive Operator3
</code></pre>
<h3 id="与策略模式的区别"><a href="#与策略模式的区别" class="headerlink" title="与策略模式的区别"></a>与策略模式的区别</h3><p>策略模式是对象行为型模式，是通过委托对象来达到复用目的；而模板方法模式是类行为型模，是通过继承来实现复用的</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即一次性实现一个算法的不变部分，并将可变的行为留给子类来实现</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序</li>
<li>是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用</li>
<li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行</li>
<li>可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则</li>
</ul>
</li>
<li>缺点<ul>
<li>如果父类中可变的基本方法太多，将会导致类的个数增加，系统过于庞大</li>
</ul>
</li>
</ul>
<h2 id="模板方法模式具体实例"><a href="#模板方法模式具体实例" class="headerlink" title="模板方法模式具体实例"></a>模板方法模式具体实例</h2><hr>
<h3 id="简历模板问题"><a href="#简历模板问题" class="headerlink" title="简历模板问题"></a>简历模板问题</h3><p><strong>使用模板方法模式简单实现前言所述的简历模板问题</strong></p>
<p><strong>代码实现</strong><br>1.定义简历模板类<code>Resume</code>，并声明和实现模板方法<code>WriteResume()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简历模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Resume</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:   <span class="comment">// public,供客户端调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteResume</span>() <span class="comment">//  模板方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        WritePersonalInfo();</span><br><span class="line">        WriteEnducationExp();</span><br><span class="line">        WriteWorkExp();</span><br><span class="line">        <span class="keyword">if</span> (isNotEnglishMajor())</span><br><span class="line">        &#123;</span><br><span class="line">            WriteCETScore();</span><br><span class="line">        &#125;</span><br><span class="line">        WritePublishedPaper();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">// protected</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WritePersonalInfo</span>()</span>  = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteEnducationExp</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteWorkExp</span>()</span>       = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">isNotEnglishMajor</span>() <span class="comment">//钩子方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WriteCETScore</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">WritePublishedPaper</span>() <span class="comment">//钩子方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.定义两个种具体的简历类<code>ResumeA</code>和<code>ResumeB</code>，并实现或重写相应的原语操作:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ResumeA</span> : <span class="title">public</span> <span class="title">Resume</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WritePersonalInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My Name is A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteEnducationExp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;I Graduated from HUST&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteWorkExp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I Worked in ZTE&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteCETScore</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CET4 is 550 score&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ResumeB</span> : <span class="title">public</span> <span class="title">Resume</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WritePersonalInfo</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My Name is B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteEnducationExp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;I Graduated from WuHan University&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteWorkExp</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I Worked in HW&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">isNotEnglishMajor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WriteCETScore</span>() <span class="comment">// 必须实现，否则编译不过，不能实例化抽象类，此处为空实现</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WritePublishedPaper</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I have published a paper about program learning &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试模板方法模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">TemplateTest_Resume()</span></span><br><span class="line">&#123;</span><br><span class="line">    Resume *pR_A = <span class="keyword">new</span> <span class="constructor">ResumeA()</span>;</span><br><span class="line">    pR_A-&gt;<span class="constructor">WriteResume()</span>;</span><br><span class="line"></span><br><span class="line">    Resume *pR_B = <span class="keyword">new</span> <span class="constructor">ResumeB()</span>;</span><br><span class="line">    pR_B-&gt;<span class="constructor">WriteResume()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pR_A</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pR_B</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果:</p>
<pre><code>My Name is A
I Graduated from HUST
I Worked in ZTE
CET4 is 550 score
My Name is B
I Graduated from WuHan University
I Worked in HW
I have published a paper about program learning
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式(结构型)</title>
    <url>/2018/05/02/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在绘图时候，会用到各种各样的画笔，画笔按照型号大小，可以分为大中小三种型号，而对于三种不同的型号的画笔又包含多种颜色，对于M种型号的N种颜色的画笔，需要涉及到M*N种画笔对象;但如果把画笔的型号和颜色这两个属性分开来处理，即提供三种型号的画笔，不同颜色通过另外的单独的不同的颜料来搭配之，此时，对于M种不同型号的N种颜色的画笔，仅需要涉及到M + N种对象。<br>而且增加一种类型的画笔，对于前者来说需要增加N种颜色的类型，而后者只需要增加一种类型即可。对于画笔来说型号和颜色有两种不同变化维度，两个维度有较强的耦合性，将两者解耦，使两个维度独立变化就是本章要介绍的桥接模式。</p>
<span id="more"></span>

<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><hr>
<p>桥接模式，是对于系统中某个类如果存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个<strong>抽象关联</strong>，该关联关系类似一条连接两个独立继承结构的桥。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Abstraction<br>定义抽象类的接口;维护一个指向Implementor的指针</p>
</li>
<li><p>ConcreteAbstraction<br>扩充或重写由Abstraction定义的接口</p>
</li>
<li><p>Implementor<br>定义实现类的接口；该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来说,Implementor的接口仅提供基本的操作，而Abstraction则定义了基于这些基本操作的较高层次的操作</p>
</li>
<li><p>ConcreteImplementor<br>实现Implementor接口并定义它的具体实现</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/05/02/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/Bridge.jpg" alt="bridge"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义一个实现类接口<code>Implementor</code>,及接口<code>OperatorImp()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现类抽象接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OperatorImp</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义两个具体的实现类<code>ConcreteImplementorA、ConcreteImplementorB</code>,并实现其接口<code>OperatorImp()</code>:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现类的具体实现A</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ConcreteImplementorA</span> : <span class="symbol">public</span> <span class="symbol">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> OperatorImp()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Concrete OperatorImpA&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类的具体实现B</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ConcreteImplementorB</span> : <span class="symbol">public</span> <span class="symbol">Implementor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> OperatorImp()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Concrete OperatorImpB&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再定义一个抽象类的接口<code>Abstraction</code>,及接口<code>Operator()</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">/ 抽象类的接口</span><br><span class="line"><span class="keyword">class</span> <span class="title">Abstraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:                        <span class="comment">// Must Be Protected 继承类要用到</span></span><br><span class="line">    Implementor *m_pImplementor;  <span class="comment">// 关联抽象的实现类（Aggregation)</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Abstraction(Implementor *pI): m_pImplementor(pI) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operator</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义两个具体的抽象类<code>ConcreteAbstractionA、ConcreteAbstractionB</code>，分别实现其接口<code>Operator()</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类的具体实现A</span></span><br><span class="line"><span class="keyword">class</span> ConcreteAbstractionA : public Abstraction</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteAbstractionA(Implementor <span class="operator">*</span><span class="params">pI</span>)</span>: <span class="constructor">Abstraction(<span class="params">pI</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Operator()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete AbstractionA Operation:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_pImplementor-&gt;<span class="constructor">OperatorImp()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的具体实现B</span></span><br><span class="line"><span class="keyword">class</span> ConcreteAbstractionB : public Abstraction</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteAbstractionB(Implementor <span class="operator">*</span><span class="params">pI</span>)</span>: <span class="constructor">Abstraction(<span class="params">pI</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Operator()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete AbstractionB Operation:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_pImplementor-&gt;<span class="constructor">OperatorImp()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试桥接模式：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> BridgeTest_Abstraction_Implementor()</span><br><span class="line">&#123;</span><br><span class="line">    // ①、② 不同一具体实现ConcreteImplementorA、B，同一的具体抽象ConcreteAbstractionA</span><br><span class="line">    Implementor *pI_A = <span class="built_in">new</span> ConcreteImplementorA();</span><br><span class="line">    Abstraction *pA_AA = <span class="built_in">new</span> ConcreteAbstractionA(pI_A);</span><br><span class="line">    pA_AA-&gt;<span class="keyword">Operator</span>(); // CAA <span class="comment">---&gt; CIA</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Implementor *pI_B = <span class="built_in">new</span> ConcreteImplementorB();</span><br><span class="line">    Abstraction *pA_AB = <span class="built_in">new</span> ConcreteAbstractionA(pI_B);</span><br><span class="line">    pA_AB-&gt;<span class="keyword">Operator</span>(); // CAA <span class="comment">---&gt;CIB</span></span><br><span class="line"></span><br><span class="line">    // ②、③ 同一具体实现ConcreteImplementorB，不同的具体抽象ConcreteAbstractionA、B</span><br><span class="line">    Abstraction *pA_BB = <span class="built_in">new</span> ConcreteAbstractionB(pI_B);</span><br><span class="line">    pA_BB-&gt;<span class="keyword">Operator</span>(); // CAB <span class="comment">---&gt; CIB</span></span><br><span class="line"></span><br><span class="line">    Abstraction *pA_BA = <span class="built_in">new</span> ConcreteAbstractionB(pI_A);</span><br><span class="line">    pA_BA-&gt;<span class="keyword">Operator</span>(); // CAB <span class="comment">--&gt; CIA</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pI_A; pI_A = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pI_B; pI_B = <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pA_AA; pA_AA = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pA_AB; pA_AB = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pA_BB; pA_BB = <span class="keyword">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pA_BA; pA_BA = <span class="keyword">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Concrete AbstractionA Operation:
I am Concrete OperatorImpA
Concrete AbstractionA Operation:
I am Concrete OperatorImpB
Concrete AbstractionB Operation:
I am Concrete OperatorImpB
Concrete AbstractionB Operation:
I am Concrete OperatorImpA
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系</li>
<li>不希望在抽象和它的实现部分之间有一个固定的绑定关系，也就是继承关系，如果我们打破了这种固定的绑定关系，以后，就可以方便的在抽象部分切换不同的实现部分可以考虑使用适配器模式</li>
<li>对客户完全隐藏抽象的实现部分</li>
<li>一个对象有多个变化因素的时候，通过抽象这些变化因素，将依赖具体实现，修改为依赖抽象</li>
<li>某个变化因素在多个对象中共享时，可以抽象出这个变化因素，然后实现这些不同的变化因素</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象</li>
<li>桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数</li>
<li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”</li>
</ul>
</li>
<li>缺点<ul>
<li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程</li>
<li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，正确识别两个独立维度也需要一定的经验积累</li>
</ul>
</li>
</ul>
<h2 id="桥接模式具体实例"><a href="#桥接模式具体实例" class="headerlink" title="桥接模式具体实例"></a>桥接模式具体实例</h2><hr>
<h3 id="实例1-—-电脑装系统"><a href="#实例1-—-电脑装系统" class="headerlink" title="实例1 — 电脑装系统"></a>实例1 — 电脑装系统</h3><p><strong>不同的型号(Dell,Acer)的电脑装不同的操作系统(Windows,Linux)</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>操作系统实现类及其抽象接口<code>InstallOs_Impl()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OS抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">OS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InstallOs_Impl</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体的操作系统类:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux OS:</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">LinuxOS</span> : <span class="symbol">public</span> <span class="symbol">OS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> InstallOs_Impl()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Install Linux OS Implementor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Windows OS:</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">WindowsOS</span> : <span class="symbol">public</span> <span class="symbol">OS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> InstallOs_Impl()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Install Windows OS Implementor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>电脑抽象类及其抽象接口<code>InstallOs()</code>方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象Computer类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    OS *m_pOs;  <span class="comment">// 关联抽象实现类OS</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Computer(OS *pOS): m_pOs(pOS) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">InstallOs</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体的电脑型号类：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> DellComputer : public Computer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">DellComputer(OS <span class="operator">*</span><span class="params">pOS</span>)</span> : <span class="constructor">Computer(<span class="params">pOS</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">InstallOs()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dell Computer: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_pOs-&gt;<span class="constructor">InstallOs_Impl()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AcerComputer : public Computer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">AcerComputer(OS <span class="operator">*</span><span class="params">pOS</span>)</span>: <span class="constructor">Computer(<span class="params">pOS</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">InstallOs()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Acer Computer: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_pOs-&gt;<span class="constructor">InstallOs_Impl()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试Computer桥接模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">BridgeTest_Computer_OS()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 安装Linux OS 的 Dell电脑</span></span><br><span class="line">    OS *pOS_Linux = <span class="keyword">new</span> <span class="constructor">LinuxOS()</span>;</span><br><span class="line">    Computer *pC_Dell_Linux = <span class="keyword">new</span> <span class="constructor">DellComputer(<span class="params">pOS_Linux</span>)</span>;</span><br><span class="line">    pC_Dell_Linux-&gt;<span class="constructor">InstallOs()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装 Windows OS 的 Dell电脑</span></span><br><span class="line">    OS *pOS_Windows = <span class="keyword">new</span> <span class="constructor">WindowsOS()</span>;</span><br><span class="line">    Computer *pC_Dell_Windows = <span class="keyword">new</span> <span class="constructor">DellComputer(<span class="params">pOS_Windows</span>)</span>;</span><br><span class="line">    pC_Dell_Windows-&gt;<span class="constructor">InstallOs()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安装 Linux OS 的 Acer电脑</span></span><br><span class="line">    Computer *pC_Acer_Linux = <span class="keyword">new</span> <span class="constructor">AcerComputer(<span class="params">pOS_Linux</span>)</span>;</span><br><span class="line">    pC_Acer_Linux-&gt;<span class="constructor">InstallOs()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//安装 Windows OS 的 Acer电脑</span></span><br><span class="line">    Computer *pC_Acer_Windows = <span class="keyword">new</span> <span class="constructor">AcerComputer(<span class="params">pOS_Windows</span>)</span>;</span><br><span class="line">    pC_Acer_Windows-&gt;<span class="constructor">InstallOs()</span>;</span><br><span class="line"></span><br><span class="line">    delete pOS_Linux;       pOS_Linux = NULL;</span><br><span class="line">    delete pOS_Windows;     pOS_Windows = NULL;</span><br><span class="line">    delete pC_Dell_Linux;   pC_Dell_Linux = NULL;</span><br><span class="line">    delete pC_Dell_Windows; pC_Dell_Windows = NULL;</span><br><span class="line">    delete pC_Acer_Linux;   pC_Acer_Linux = NULL;</span><br><span class="line">    delete pC_Acer_Windows; pC_Acer_Windows = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果：</p>
<p> Dell Computer:<br> Install Linux OS Implementor<br> Dell Computer:<br> Install Windows OS Implementor<br> Acer Computer:<br> Install Linux OS Implementor<br> Acer Computer:<br> Install Windows OS Implementor</p>
</li>
</ol>
<h3 id="实例2-—-画笔问题"><a href="#实例2-—-画笔问题" class="headerlink" title="实例2 — 画笔问题"></a>实例2 — 画笔问题</h3><p><strong>实现前言所描述的三种型号(Huge,Mid,Small)和三种颜色(Red,Green,Black)的画笔</strong></p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>颜色抽象类及其接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Color</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Color</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doPaint</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>颜色具体实现类：：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Red </span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Red</span> : <span class="symbol">public</span> <span class="symbol">Color</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> doPaint()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Red Color&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Green</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Green</span> : <span class="symbol">public</span> <span class="symbol">Color</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> doPaint()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Green Color&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Black </span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Black</span> : <span class="symbol">public</span> <span class="symbol">Color</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> doPaint()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Black Color&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>画笔抽象类及其接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pen</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Pen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Color *m_pColor; <span class="comment">// 被子类所继承和使用</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pen(Color *color): m_pColor(color)&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>画笔具体实现类：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HugePen</span></span><br><span class="line"><span class="keyword">class</span> HugePen : public Pen</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">HugePen(Color <span class="operator">*</span><span class="params">color</span>)</span> : <span class="constructor">Pen(<span class="params">color</span>)</span>&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Draw()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Huge Pen Draw And Use The Kind Of &quot;</span>;</span><br><span class="line">        m_pColor-&gt;<span class="keyword">do</span><span class="constructor">Paint()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Middle Pen</span></span><br><span class="line"><span class="keyword">class</span> MiddlePen : public Pen</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">MiddlePen(Color <span class="operator">*</span><span class="params">color</span>)</span>: <span class="constructor">Pen(<span class="params">color</span>)</span>&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Draw()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Middle Pen Draw And Use The Kind Of &quot;</span>;</span><br><span class="line">        m_pColor-&gt;<span class="keyword">do</span><span class="constructor">Paint()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Small Pen</span></span><br><span class="line"><span class="keyword">class</span> SmallPen : public Pen</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">SmallPen(Color <span class="operator">*</span><span class="params">color</span>)</span>: <span class="constructor">Pen(<span class="params">color</span>)</span>&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Draw()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Small Pen Draw And Use The Kind Of &quot;</span>;</span><br><span class="line">        m_pColor-&gt;<span class="keyword">do</span><span class="constructor">Paint()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试实例：</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">void <span class="built_in">BridgeTest_Pen_Color</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Huge Red Pen</span></span><br><span class="line">    Color *pR = <span class="keyword">new</span> <span class="built_in">Red</span>();</span><br><span class="line">    Pen   *pRed_HugePen = <span class="keyword">new</span> <span class="built_in">HugePen</span>(pR);</span><br><span class="line">    pRed_HugePen-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Huge Green Pen</span></span><br><span class="line">    Color *pG = <span class="keyword">new</span> <span class="built_in">Green</span>();</span><br><span class="line">    Pen   *pGreen_HugePen = <span class="keyword">new</span> <span class="built_in">HugePen</span>(pG);</span><br><span class="line">    pGreen_HugePen-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Middle Green Pen</span></span><br><span class="line">    Pen   *pGreen_MidPen = <span class="keyword">new</span> <span class="built_in">MiddlePen</span>(pG);</span><br><span class="line">    pGreen_MidPen-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Small Black Pen</span></span><br><span class="line">    Color *pB = <span class="keyword">new</span> <span class="built_in">Black</span>();</span><br><span class="line">    Pen   *pBlack_SmallPen = <span class="keyword">new</span> <span class="built_in">SmallPen</span>(pB);</span><br><span class="line">    pBlack_SmallPen-&gt;<span class="built_in">Draw</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pR; pR = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pG; pG = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pB; pB = <span class="built_in">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pRed_HugePen; pRed_HugePen = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pGreen_HugePen; pGreen_HugePen = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pGreen_MidPen;  pGreen_MidPen = <span class="built_in">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pBlack_SmallPen; pBlack_SmallPen = <span class="built_in">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Huge Pen Draw And Use The Kind Of Red Color
Huge Pen Draw And Use The Kind Of Green Color
Middle Pen Draw And Use The Kind Of Green Color
Small Pen Draw And Use The Kind Of Black Color
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式(行为型)</title>
    <url>/2018/01/02/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在dota即时对战中，不同的时期，战争的行为是不一样的。如在游戏战争前期，主要是辅助英雄包鸡包眼游走gank，后期英雄发育为主，一般不会参与团战，这时候主要以前期辅助英雄为主角；在游戏战争中期，后期英雄发育经过前期的发育，开始与辅助英雄抱团推塔，参加团战，辅助作用慢慢减弱，后期英雄慢慢变强；而在游戏战争的后期，经过前期的发育，中期团战金钱的积累，后期英雄成为了战场的主角，开始带领辅助英雄推高地，占领基地。像这种随着时间的推移，角色对象在不同的状态下具有不同的行为或者状态在某些情况下能够相互转换的行为，可以通过状态模式来解决。</p>
<span id="more"></span>

<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><hr>
<p>在状态模式中，我们将对象在每一个状态下的行为和状态转移语句封装在一个个状态类中，通过这些状态类来分散冗长的条件转移语句，让系统具有更好的灵活性和可扩展性</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类，别名是状态对象</p>
<blockquote>
<p>系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化，对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Context<br>环境类，拥有多种状态的对象<br>维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象</p>
</li>
<li><p>State<br>抽象状态类，定义一个接口以封装与环境类Context的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法<br>抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中</p>
</li>
<li><p>ConcreteState<br>具体状态类，抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/01/02/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/State.jpg" alt="state"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义状态上下类<code>StateContext</code>，维护了一个<code>State</code>类引用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// State Context</span></span><br><span class="line"><span class="keyword">class</span> StateContext</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *m_pState; <span class="comment">// 上下文的State引用</span></span><br><span class="line">    <span class="built_in">int</span>  m_value; <span class="comment">//  上下文的信息</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">StateContext(State <span class="operator">*</span><span class="params">pState</span>, <span class="params">int</span> <span class="params">value</span>)</span> : m<span class="constructor">_pState(<span class="params">pState</span>)</span>, m<span class="constructor">_value(<span class="params">value</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Request()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="constructor">NULL_POINTER(<span class="params">m_pState</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pState-&gt;<span class="constructor">Handle(<span class="params">this</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">SetState(State <span class="operator">*</span><span class="params">pState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    State* <span class="constructor">GetState(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_pState;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">int</span> <span class="constructor">GetValue(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_value;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">SetValue(<span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义抽象的状态类<code>State</code>,并声明<code>Handle()</code>接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(StateContext *pSC)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.再定义两个具体的状态类<code>ConcreteStateA</code>和<code>ConcreteStateB</code>,并实现<code>Handle()</code>接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete State A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(StateContext *pSC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; pSC-&gt;<span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete State A Handle!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete State B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> : <span class="keyword">public</span> State</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Handle</span><span class="params">(StateContext *pSC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value is &quot;</span> &lt;&lt; pSC-&gt;<span class="built_in">GetValue</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete State B Handle!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试状态模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">StateTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    State *pStateA = <span class="keyword">new</span> <span class="constructor">ConcreteStateA()</span>;</span><br><span class="line">    State *pStateB = <span class="keyword">new</span> <span class="constructor">ConcreteStateB()</span>;</span><br><span class="line"></span><br><span class="line">    StateContext *pSC = <span class="keyword">new</span> <span class="constructor">StateContext(<span class="params">pStateA</span>, 10)</span>; <span class="comment">// 构造注入ConcreteStateA</span></span><br><span class="line">    pSC-&gt;<span class="constructor">Request()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在客户端根据上下文信息进行状态选择切换</span></span><br><span class="line">    <span class="keyword">if</span> (pSC-&gt;<span class="constructor">GetValue()</span> &lt;= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pSC-&gt;<span class="constructor">SetState(<span class="params">pStateB</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pSC-&gt;<span class="constructor">SetState(<span class="params">pStateA</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pSC-&gt;<span class="constructor">Request()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pStateA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pStateB</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSC</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果：</p>
<pre><code>value is 10
Concrete State A Handle!!!
value is 10
Concrete State B Handle!!!
</code></pre>
<h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><p>上述，是在客户端中根据上下文信息对状态进行切换，比较好的做法是将状态切换放在状态上下文类或具体的状态类中</p>
<h4 id="改进版1-在StateContext中切换状态"><a href="#改进版1-在StateContext中切换状态" class="headerlink" title="改进版1-在StateContext中切换状态"></a>改进版1-在StateContext中切换状态</h4><p>代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> StateContextEx</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StateEx    *m_pCurrentState;</span><br><span class="line">    ConcreteStateExA *m_pStateA;</span><br><span class="line">    ConcreteStateExB *m_pStateB;</span><br><span class="line">    <span class="built_in">int</span> m_value;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">StateContextEx(<span class="params">int</span> <span class="params">value</span> = 10)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pStateA = <span class="keyword">new</span> <span class="constructor">ConcreteStateExA()</span>;</span><br><span class="line">        m_pStateB = <span class="keyword">new</span> <span class="constructor">ConcreteStateExB()</span>;</span><br><span class="line">        m_pCurrentState = m_pStateA; <span class="comment">// 初始化为状态A</span></span><br><span class="line">        m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">StateContextEx()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">m_pStateA</span>)</span>;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">m_pStateB</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">SetState(StateEx <span class="operator">*</span><span class="params">pState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pCurrentState = pState;</span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">SetValue(<span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="constructor">GetValue(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_value;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Request()</span>         <span class="comment">// 在状态上下文中进行判断和切换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">GetValue()</span> &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="constructor">SetState(<span class="params">m_pStateA</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="constructor">SetState(<span class="params">m_pStateB</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pCurrentState-&gt;<span class="constructor">Handle()</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="改进版2-在具体State中切换状态"><a href="#改进版2-在具体State中切换状态" class="headerlink" title="改进版2-在具体State中切换状态"></a>改进版2-在具体State中切换状态</h4><p>1.具体State实现：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete State A</span></span><br><span class="line"><span class="keyword">class</span> ConcreteStateA : public State</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Handle(StateContext <span class="operator">*</span><span class="params">pSC</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSC-&gt;<span class="constructor">GetValue()</span> &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete State A Handle!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pSC-&gt;<span class="constructor">GetValue()</span> &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pSC-&gt;<span class="constructor">SetState(<span class="params">new</span> ConcreteStateB)</span>; <span class="comment">// 可以优化为单例模式</span></span><br><span class="line">            pSC-&gt;<span class="constructor">GetState()</span>-&gt;<span class="constructor">Handle(<span class="params">pSC</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pSC-&gt;<span class="constructor">SetState(<span class="params">new</span> ConcreteStateC)</span>; <span class="comment">// 可以优化为单例模式</span></span><br><span class="line">            pSC-&gt;<span class="constructor">GetState()</span>-&gt;<span class="constructor">Handle(<span class="params">pSC</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete State B</span></span><br><span class="line"><span class="keyword">class</span> ConcreteStateB : public State</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Handle(StateContext <span class="operator">*</span><span class="params">pSC</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSC-&gt;<span class="constructor">GetValue()</span> &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pSC-&gt;<span class="constructor">SetState(<span class="params">new</span> ConcreteStateA)</span>; <span class="comment">// 可以优化为单例模式</span></span><br><span class="line">            pSC-&gt;<span class="constructor">GetState()</span>-&gt;<span class="constructor">Handle(<span class="params">pSC</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pSC-&gt;<span class="constructor">GetValue()</span> &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete State B Handle!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pSC-&gt;<span class="constructor">SetState(<span class="params">new</span> ConcreteStateC)</span>; <span class="comment">// 可以优化为单例模式</span></span><br><span class="line">            pSC-&gt;<span class="constructor">GetState()</span>-&gt;<span class="constructor">Handle(<span class="params">pSC</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete State C</span></span><br><span class="line"><span class="keyword">class</span> ConcreteStateC : public State</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Handle(StateContext <span class="operator">*</span><span class="params">pSC</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSC-&gt;<span class="constructor">GetValue()</span> &lt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pSC-&gt;<span class="constructor">SetState(<span class="params">new</span> ConcreteStateA)</span>; <span class="comment">// 可以优化为单例模式</span></span><br><span class="line">            pSC-&gt;<span class="constructor">GetState()</span>-&gt;<span class="constructor">Handle(<span class="params">pSC</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pSC-&gt;<span class="constructor">GetValue()</span> &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pSC-&gt;<span class="constructor">SetState(<span class="params">new</span> ConcreteStateB)</span>; <span class="comment">// 可以优化为单例模式</span></span><br><span class="line">            pSC-&gt;<span class="constructor">GetState()</span>-&gt;<span class="constructor">Handle(<span class="params">pSC</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete State C Handle!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.这时候在环境上下文的设置状态接口中要增加释放内存的操作(若是单例模式则不需要)：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// State Context</span></span><br><span class="line"><span class="keyword">class</span> StateContext</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    State *m_pState; <span class="comment">// 上下文的State引用</span></span><br><span class="line">    <span class="built_in">int</span>  m_value; <span class="comment">//  上下文的信息</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">StateContext(State <span class="operator">*</span><span class="params">pState</span>, <span class="params">int</span> <span class="params">value</span>)</span> : m<span class="constructor">_pState(<span class="params">pState</span>)</span>, m<span class="constructor">_value(<span class="params">value</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">SetState(State <span class="operator">*</span><span class="params">pState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="constructor">NULL_POINTER(<span class="params">m_pState</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            delete m_pState;  <span class="comment">// 先删除之前的State对象指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        m_pState = pState;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>3.客户端调用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">StateTest_GeneralEx()</span></span><br><span class="line">&#123;</span><br><span class="line">    StateContextEx *pSCEx = <span class="keyword">new</span> <span class="constructor">StateContextEx(5)</span>;</span><br><span class="line">    pSCEx-&gt;<span class="constructor">Request()</span>; <span class="comment">// 只需Request，内部进行状态转换(包括上下文内部或具体状态内部)</span></span><br><span class="line"></span><br><span class="line">    pSCEx-&gt;<span class="constructor">SetValue(20)</span>;</span><br><span class="line">    pSCEx-&gt;<span class="constructor">Request()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSCEx</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理</li>
<li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数</li>
</ul>
</li>
<li>缺点<ul>
<li>会增加系统中类和对象的个数，导致系统运行开销增大</li>
<li>对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态</li>
</ul>
</li>
</ul>
<h2 id="状态模式具体实例"><a href="#状态模式具体实例" class="headerlink" title="状态模式具体实例"></a>状态模式具体实例</h2><hr>
<h3 id="Dota游戏战争状态问题"><a href="#Dota游戏战争状态问题" class="headerlink" title="Dota游戏战争状态问题"></a>Dota游戏战争状态问题</h3><p><strong>使用状态模式简单实现前言所述的Dota游戏战争状态不同英雄行为不同功能</strong></p>
<p><strong>代码实现</strong><br>1.定义War上下文类<code>War</code>:</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> War  (State Context)</span><br><span class="line">class War</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    WarState *m_pWarState;</span><br><span class="line">    int m_ElapsedDays;</span><br><span class="line">public:</span><br><span class="line">    War(WarState *pWarState) : m_pWarState(pWarState), m_ElapsedDays(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    int GetElapsedDays()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_ElapsedDays;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetElapsedDays(int days)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ElapsedDays = days;</span><br><span class="line">    &#125;</span><br><span class="line">    void SetWarState(WarState *pWarState)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pWarState = pWarState;</span><br><span class="line">    &#125;</span><br><span class="line">    WarState* GetWarState()</span><br><span class="line">    &#123;</span><br><span class="line">        return m_pWarState;</span><br><span class="line">    &#125;</span><br><span class="line">    void RunWar() <span class="regexp">//</span> 具体的War状态类负责状态选择和转换</span><br><span class="line">    &#123;</span><br><span class="line">        m_pWarState-&gt;Run(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span>void RunWar() <span class="regexp">//</span>  环境变量类负责状态选择和转换</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  <span class="keyword">if</span> (GetElapsedDays() &lt; PREPHASE_DAY_MAX)</span><br><span class="line">    <span class="regexp">//</span>  &#123;</span><br><span class="line">    <span class="regexp">//</span>      m_pWarState = PrephaseWarState::Instance();</span><br><span class="line">    <span class="regexp">//</span>  &#125;</span><br><span class="line">    <span class="regexp">//</span>  <span class="keyword">else</span> <span class="keyword">if</span> (GetElapsedDays() &lt; METAPHASE_DAY_MAX)</span><br><span class="line">    <span class="regexp">//</span>  &#123;</span><br><span class="line">    <span class="regexp">//</span>      m_pWarState = MetaphaseWarState::Instance();</span><br><span class="line">    <span class="regexp">//</span>  &#125;</span><br><span class="line">    <span class="regexp">//</span>  <span class="keyword">else</span></span><br><span class="line">    <span class="regexp">//</span>  &#123;</span><br><span class="line">    <span class="regexp">//</span>      m_pWarState = AnaphaseWarState::Instance();</span><br><span class="line">    <span class="regexp">//</span>  &#125;</span><br><span class="line">    <span class="regexp">//</span>  m_pWarState-&gt;Run(); <span class="regexp">//</span> 无需传入contxt</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.定义抽象的War状态类<code>WarState</code>,并声明<code>Run()</code>接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WarState</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Run</span><span class="params">(War *pWar)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义具体的三个时期的War状态类后期<code>AnaphaseWarState</code>,中期<code>MetaphaseWarState</code>及前期<code>PrephaseWarState</code>, 实现<code>Run()</code>接口,并内部根据War进行的时间进行状态选择和切换:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnaphaseWarState</span></span><br><span class="line"><span class="keyword">class</span> AnaphaseWarState : public WarState <span class="comment">// 单例模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    static AnaphaseWarState *m_pWarState;</span><br><span class="line">    <span class="keyword">class</span> Garbage <span class="comment">//  单例模式内部类</span></span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="constructor">Garbage()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(AnaphaseWarState::Instance()</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                delete AnaphaseWarState::<span class="constructor">Instance()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static Garbage g;  <span class="comment">//根据类的静态成员变量在宿主类析构的时候自动调用静态成员类的析构函数的原理来释放单例模式对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="constructor">AnaphaseWarState()</span> &#123;&#125;;</span><br><span class="line">    <span class="constructor">AnaphaseWarState(<span class="params">const</span> AnaphaseWarState&amp;)</span> &#123;&#125;;</span><br><span class="line">    AnaphaseWarState&amp; operator = (const AnaphaseWarState) &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    static AnaphaseWarState* <span class="constructor">Instance()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pWarState</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pWarState = <span class="keyword">new</span> <span class="constructor">AnaphaseWarState()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return m_pWarState;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(War <span class="operator">*</span><span class="params">pWar</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Now The War Is On Anaphase State, Anaphase dota heroes become the protagonist, War is coming to end&quot;</span> &lt;&lt; <span class="string">&quot;[time = &quot;</span> &lt;&lt; pWar-&gt;<span class="constructor">GetElapsedDays()</span>&lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">AnaphaseWarState* AnaphaseWarState::m_pWarState = NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Metaphase War State</span></span><br><span class="line"><span class="keyword">class</span> MetaphaseWarState : public WarState <span class="comment">// 单例模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    static MetaphaseWarState *m_pWarState;</span><br><span class="line">    <span class="keyword">class</span> Garbage</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="constructor">Garbage()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(MetaphaseWarState::Instance()</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                delete MetaphaseWarState::<span class="constructor">Instance()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static Garbage g;<span class="comment">//根据类的静态成员变量在宿主类析构的时候自动调用静态成员类的析构函数的原理来释放单例模式对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="constructor">MetaphaseWarState()</span> &#123;&#125;;</span><br><span class="line">    <span class="constructor">MetaphaseWarState(<span class="params">const</span> MetaphaseWarState&amp;)</span> &#123;&#125;;</span><br><span class="line">    MetaphaseWarState&amp; operator = (const MetaphaseWarState) &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    static MetaphaseWarState* <span class="constructor">Instance()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pWarState</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pWarState = <span class="keyword">new</span> <span class="constructor">MetaphaseWarState()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return m_pWarState;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(War <span class="operator">*</span><span class="params">pWar</span>)</span>    <span class="comment">//  各个具体状态内部负责状态的选择和转换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pWar-&gt;<span class="constructor">GetElapsedDays()</span> &lt;= METAPHASE_DAY_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot&quot;</span> &lt;&lt; <span class="string">&quot;[time = &quot;</span> &lt;&lt; pWar-&gt;<span class="constructor">GetElapsedDays()</span>&lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pWar-&gt;<span class="constructor">SetWarState(AnaphaseWarState::Instance()</span>);</span><br><span class="line">            pWar-&gt;<span class="constructor">GetWarState()</span>-&gt;<span class="constructor">Run(<span class="params">pWar</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MetaphaseWarState* MetaphaseWarState::m_pWarState = NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prephase War State</span></span><br><span class="line"><span class="keyword">class</span> PrephaseWarState : public WarState <span class="comment">// 单例模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    static PrephaseWarState *m_pWarState;</span><br><span class="line">    <span class="keyword">class</span> Garbage</span><br><span class="line">    &#123;</span><br><span class="line">    public:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="constructor">Garbage()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(PrephaseWarState::Instance()</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                delete PrephaseWarState::<span class="constructor">Instance()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    static Garbage g;<span class="comment">//根据类的静态成员变量在宿主类析构的时候自动调用静态成员类的析构函数的原理来释放单例模式对象</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="constructor">PrephaseWarState()</span> &#123;&#125;;</span><br><span class="line">    <span class="constructor">PrephaseWarState(<span class="params">const</span> PrephaseWarState&amp;)</span> &#123;&#125;;</span><br><span class="line">    PrephaseWarState&amp; operator = (const PrephaseWarState) &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    static PrephaseWarState* <span class="constructor">Instance()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pWarState</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pWarState = <span class="keyword">new</span> <span class="constructor">PrephaseWarState()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return m_pWarState;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Run(War <span class="operator">*</span><span class="params">pWar</span>)</span> <span class="comment">//  各个具体状态内部负责状态的选择和转换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pWar-&gt;<span class="constructor">GetElapsedDays()</span> &lt;= PREPHASE_DAY_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin&quot;</span> &lt;&lt; <span class="string">&quot;[time = &quot;</span> &lt;&lt; pWar-&gt;<span class="constructor">GetElapsedDays()</span>&lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pWar-&gt;<span class="constructor">SetWarState(MetaphaseWarState::Instance()</span>);</span><br><span class="line">            pWar-&gt;<span class="constructor">GetWarState()</span>-&gt;<span class="constructor">Run(<span class="params">pWar</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">PrephaseWarState* PrephaseWarState::m_pWarState = NULL;</span><br></pre></td></tr></table></figure>

<p>4.测试状态模式:</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="function"><span class="title">StateTest_War</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">War</span> *<span class="variable">pW</span> = <span class="variable">new</span> <span class="function"><span class="title">War</span>(<span class="variable">PrephaseWarState</span>::<span class="title">Instance</span>());</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="variable">for</span> (<span class="variable">int</span> <span class="variable">ElapsedDays</span> = <span class="number">0</span>; <span class="variable">ElapsedDays</span> &lt; <span class="number">30</span>; <span class="variable">ElapsedDays</span>+=<span class="number">4</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">pW</span>-&gt;<span class="function"><span class="title">SetElapsedDays</span>(<span class="variable">ElapsedDays</span>);</span></span><br><span class="line"><span class="function">        <span class="variable">pW</span>-&gt;<span class="title">RunWar</span>(); <span class="comment">// 客户端只负责调用RunWar即可，具体War状态内部进行了转换</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">SAFE_RELASE_POINTER</span>(<span class="variable">pW</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>5.运行结果:</p>
<pre><code>Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin[time = 0]
Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin[time = 4]
Now The War Is On Prephase State, Prephase dota heroes become the protagonist, War is coming to begin[time = 8]
Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot[time = 12]
Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot[time = 16]
Now The War Is On Metaphase State, Anaphase and Prephase dota heroes both become the protagonist, War is on hot[time = 20]
Now The War Is On Anaphase State, Anaphase dota heroes become the protagonist, War is coming to end[time = 24]
Now The War Is On Anaphase State, Anaphase dota heroes become the protagonist, War is coming to end[time = 28]
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式(行为型)</title>
    <url>/2018/01/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在出去旅游的时候，有很多种交通方式均能达到旅游的目的地。可以选择汽车，方便自由，也可以选择火车，速度较快，也可以沿途看风景，路程较远可以选择飞机，时间快。实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式来实现灵活地选择解决途径，也能够方便地增加新的解决途径，这就是本章要将要介绍的策略模式。</p>
<span id="more"></span>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><hr>
<p>在策略模式中，定义一些独立的类来封装不同的算法，每一个类封装一种具体的算法(策略)，为了保证这些策略在使用时具有一致性，一般会提供一个抽象的策略类来做规则的定义，而每种算法则对应于一个具体策略类，将算法的定义和使用分离，也就是将算法的行为和环境分开</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Context<br>环境类，用一个ConcreteStrategy对象类配置<br>维护一个对Strategy对象的引用<br>可以定义一个接口来让Strategy访问它的数据</p>
</li>
<li><p>Strategy<br>抽象策略类，定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy对象定义的算法</p>
</li>
<li><p>ConcreteState<br>具体策略类，以Strategy接口实现某具体算法<br>可以拥有一个Context对象引用访问Context的数据</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/01/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/Strategy.jpg" alt="strategy"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象策略类<code>Strategy</code>，声明算法接口<code>AlgorithmInterface()</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Strategy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Strategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AlgorithmInterface</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义三个具体的策略类<code>ConcreteStrategyA</code>、<code>ConcreteStrategyB</code>及<code>ConcreteStrategyC</code>,并实现算法接口<code>AlgorithmInterface()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Strategy A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> : <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; I am Concrete Strategy A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Strategy B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> : <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; I am Concrete Strategy B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Strategy C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategyC</span> : <span class="keyword">public</span> Strategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AlgorithmInterface</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; I am Concrete Strategy C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.再定义策略环境类<code>StrategyContext</code>,具有<code>Strategy</code>对象的引用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context</span></span><br><span class="line"><span class="keyword">class</span> StrategyContext</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Strategy *m_pStrategy;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">StrategyContext(Strategy <span class="operator">*</span><span class="params">pS</span>)</span> : m<span class="constructor">_pStrategy(<span class="params">pS</span>)</span> &#123;&#125;;  <span class="comment">// 构造静态注入策略对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">StrategyContext()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">m_pStrategy</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">SetStrategy(Strategy <span class="operator">*</span><span class="params">pS</span>)</span>   <span class="comment">// 动态注入策略对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="constructor">SAFE_RELASE_POINTER(<span class="params">m_pStrategy</span>)</span>;<span class="comment">// 释放之前申请的对象</span></span><br><span class="line">        m_pStrategy = pS;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">ContextInterface()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pStrategy</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pStrategy-&gt;<span class="constructor">AlgorithmInterface()</span>; <span class="comment">// 调用注入的策略对象算法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试策略模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">StrategyTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    Strategy *pCSA = <span class="keyword">new</span> <span class="constructor">ConcreteStrategyA()</span>;</span><br><span class="line">    Strategy *pCSB = <span class="keyword">new</span> <span class="constructor">ConcreteStrategyB()</span>;</span><br><span class="line">    Strategy *pCSC = <span class="keyword">new</span> <span class="constructor">ConcreteStrategyC()</span>;</span><br><span class="line"></span><br><span class="line">    StrategyContext *pSContext = <span class="keyword">new</span> <span class="constructor">StrategyContext(<span class="params">pCSA</span>)</span>;</span><br><span class="line">    pSContext-&gt;<span class="constructor">ContextInterface()</span>;</span><br><span class="line"></span><br><span class="line">    pSContext-&gt;<span class="constructor">SetStrategy(<span class="params">pCSB</span>)</span>;</span><br><span class="line">    pSContext-&gt;<span class="constructor">ContextInterface()</span>;</span><br><span class="line"></span><br><span class="line">    pSContext-&gt;<span class="constructor">SetStrategy(<span class="params">pCSC</span>)</span>;</span><br><span class="line">    pSContext-&gt;<span class="constructor">ContextInterface()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSContext</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果：</p>
<pre><code> I am Concrete Strategy A
 I am Concrete Strategy B
 I am Concrete Strategy C
</code></pre>
<h3 id="改进版"><a href="#改进版" class="headerlink" title="改进版"></a>改进版</h3><h4 id="改进版1-通过将Strategy作为C-模板参数来实现"><a href="#改进版1-通过将Strategy作为C-模板参数来实现" class="headerlink" title="改进版1-通过将Strategy作为C++模板参数来实现"></a>改进版1-通过将Strategy作为C++模板参数来实现</h4><p>在C++中，可利用模板机制用一个Strategy来配置一个类。然而这种技术仅当下面条件满足时才可以使用:</p>
<ul>
<li>可以在编译时选择Strategy</li>
<li>它不需在运行时改变<br>在这种情况下，要被配置的类（如Context）被定义为以一个Strategy类作为一个参数的模板类</li>
</ul>
<blockquote>
<p>使用模板不再需要定义给Strategy定义接口的抽象类。把Strategy作为一个模板参数也使得可以将一个Strategy和它的Context静态地绑定在一起，从而提高效率</p>
</blockquote>
<p>1.实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContextEx</span>  <span class="comment">// StrategyContext以Strategy为模板参数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ContextInterface</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _strategy.<span class="built_in">AlgorithmInterface</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _strategy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把具体的Strategy作为一个模板参数将一个Strategy和它的Context静态地绑定在一起</span></span><br><span class="line"><span class="keyword">typedef</span> StrategyContextEx&lt;ConcreteStrategyA&gt; StrategyContextA;</span><br><span class="line"><span class="keyword">typedef</span> StrategyContextEx&lt;ConcreteStrategyB&gt; StrategyContextB;</span><br><span class="line"><span class="keyword">typedef</span> StrategyContextEx&lt;ConcreteStrategyC&gt; StrategyContextC;</span><br></pre></td></tr></table></figure>

<p>2.客户端测试代码：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void StrategyTest_GeneralTemplateEx()</span><br><span class="line">&#123;</span><br><span class="line">    StrategyContextA SC_A<span class="comment">;</span></span><br><span class="line">    SC_A.ContextInterface()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    StrategyContextB SC_B<span class="comment">;</span></span><br><span class="line">    SC_B.ContextInterface()<span class="comment">;    </span></span><br><span class="line">    </span><br><span class="line">    StrategyContextC SC_C<span class="comment">;</span></span><br><span class="line">    SC_C.ContextInterface()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.运行结果：</p>
<pre><code> I am Concrete Strategy A
 I am Concrete Strategy B
 I am Concrete Strategy C
</code></pre>
<h4 id="改进版2-通过工厂方法模式来创建具体策略对象"><a href="#改进版2-通过工厂方法模式来创建具体策略对象" class="headerlink" title="改进版2-通过工厂方法模式来创建具体策略对象"></a>改进版2-通过工厂方法模式来创建具体策略对象</h4><p>在上述策略模式中，客户端通过new不同的具体策略类来创建对象，对于多个策略可以将创建工作通过工厂方法模式来实现</p>
<p>1.具体实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Use Factory Pattern to Produce Concrete Strategy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Strategy Factory</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyAbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Strategy* <span class="title">CreateStrategy</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Strategy Factory A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyFactoryA</span> : <span class="keyword">public</span> StrategyAbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Strategy* <span class="title">CreateStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteStrategyA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Strategy Factory B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyFactoryB</span> : <span class="keyword">public</span> StrategyAbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Strategy* <span class="title">CreateStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteStrategyB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Strategy Factory C</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyFactoryC</span> : <span class="keyword">public</span> StrategyAbstractFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Strategy* <span class="title">CreateStrategy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteStrategyC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.客户端调用直接调用工厂方法即可：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">StrategyTest_GeneralEx()</span></span><br><span class="line">&#123;</span><br><span class="line">    StrategyAbstractFactory *pSFA = <span class="keyword">new</span> <span class="constructor">StrategyFactoryA()</span>;</span><br><span class="line">    Strategy *pSA = pSFA-&gt;<span class="constructor">CreateStrategy()</span>;   <span class="comment">// 调用工厂方法创建具体策略对象</span></span><br><span class="line"></span><br><span class="line">    StrategyAbstractFactory *pSFB = <span class="keyword">new</span> <span class="constructor">StrategyFactoryB()</span>;</span><br><span class="line">    Strategy *pSB = pSFB-&gt;<span class="constructor">CreateStrategy()</span>;</span><br><span class="line"></span><br><span class="line">    StrategyAbstractFactory *pSFC = <span class="keyword">new</span> <span class="constructor">StrategyFactoryC()</span>;</span><br><span class="line">    Strategy *pSC = pSFC-&gt;<span class="constructor">CreateStrategy()</span>;</span><br><span class="line"></span><br><span class="line">    StrategyContext *pSContext =<span class="keyword">new</span> <span class="constructor">StrategyContext(<span class="params">pSA</span>)</span>;</span><br><span class="line">    pSContext-&gt;<span class="constructor">ContextInterface()</span>;</span><br><span class="line"></span><br><span class="line">    pSContext-&gt;<span class="constructor">SetStrategy(<span class="params">pSB</span>)</span>;</span><br><span class="line">    pSContext-&gt;<span class="constructor">ContextInterface()</span>;</span><br><span class="line"></span><br><span class="line">    pSContext-&gt;<span class="constructor">SetStrategy(<span class="params">pSC</span>)</span>;</span><br><span class="line">    pSContext-&gt;<span class="constructor">ContextInterface()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSFA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSFB</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSFC</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSContext</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.进一步的，对于工厂方法，同样也可以通过C++模板特性来替换抽象Strategy类的多态特性，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyFactoryBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T* <span class="title">CreateStrategy</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> StrategyFactoryBase&lt;ConcreteStrategyA&gt;  StrategyFactoryTemplateA;</span><br><span class="line"><span class="keyword">typedef</span> StrategyFactoryBase&lt;ConcreteStrategyB&gt;  StrategyFactoryTemplateB;</span><br><span class="line"><span class="keyword">typedef</span> StrategyFactoryBase&lt;ConcreteStrategyC&gt;  StrategyFactoryTemplateC;</span><br></pre></td></tr></table></figure>

<p>4.客户端使用：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void StrategyTest_GeneralFactoryTemplateEx()</span><br><span class="line">&#123;</span><br><span class="line">    StrategyFactoryTemplateA SFT_A<span class="comment">;</span></span><br><span class="line">    Strategy *pSA <span class="operator">=</span> SFT_A.CreateStrategy()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    StrategyFactoryTemplateB SFT_B<span class="comment">;</span></span><br><span class="line">    Strategy *pSB <span class="operator">=</span> SFT_B.CreateStrategy()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    StrategyFactoryTemplateC SFT_C<span class="comment">;</span></span><br><span class="line">    Strategy *pSC <span class="operator">=</span> SFT_C.CreateStrategy()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    StrategyContext *pSContext <span class="operator">=</span> new StrategyContext(pSA)<span class="comment">;</span></span><br><span class="line">    pSContext-&gt;ContextInterface()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    pSContext-&gt;SetStrategy(pSB)<span class="comment">;</span></span><br><span class="line">    pSContext-&gt;ContextInterface()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    pSContext-&gt;SetStrategy(pSC)<span class="comment">;</span></span><br><span class="line">    pSContext-&gt;ContextInterface()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    SAFE_RELASE_POINTER(pSContext)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果：</p>
<pre><code> I am Concrete Strategy A
 I am Concrete Strategy B
 I am Concrete Strategy C
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>许多相关的类仅仅是行为有异。 “策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种</li>
<li>需要使用一个算法的不同变体。例如，你可能会定义一些反映不同的空间、时间权衡的算法。当这些变体实现为一个算法的类层次时,可以使用策略模式</li>
<li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的与算法相关的数据结构，让算法和对象分开来，使得算法可以独立于使用它的客户而变化</li>
<li>一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>相关算法系列 Strategy类层次为Context定义了一系列的可供重用的算法或行为 继承有助于析取出这些算法中的公共功能</li>
<li>将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展</li>
<li>消除了一些if else条件语句</li>
<li>实现的选择 Strategy模式可以提供相同行为的不同实现。客户可以根据不同时间、空间权衡取舍要求从不同策略中进行选择</li>
</ul>
</li>
<li>缺点<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类，该模式有一个潜在的缺点，就是一个客户要选择一个合适的Strategy就必须知道这些Strategy到底有何不同。此时可能不得不向客户暴露具体的实现问题。因此仅当这些不同行为变体与客户相关的行为时才需要使用Strategy模式</li>
<li>无论各个ConcreteStrategy实现的算法是简单还是复杂, 它们都共享Strategy定义的接口。因此很可能某些ConcreteStrategy不会都用到所有通过这个接口传递给它们的信息；简单的ConcreteStrategy可能不使用其中的任何信息。这就意味着有时Context会创建和初始化一些永远不会用到的参数。如果存在这样问题，那么将需要在Strategy和Context之间更进行紧密的耦合</li>
<li>策略模式将造成产生很多策略类</li>
</ul>
</li>
</ul>
<h3 id="与其他可以消除if-else条件模式的区别-状态模式、策略模式、工厂模式、责任链模式"><a href="#与其他可以消除if-else条件模式的区别-状态模式、策略模式、工厂模式、责任链模式" class="headerlink" title="与其他可以消除if-else条件模式的区别(状态模式、策略模式、工厂模式、责任链模式)"></a>与其他可以消除if-else条件模式的区别(状态模式、策略模式、工厂模式、责任链模式)</h3><p>1.状态模式</p>
<ul>
<li>可以认为“状态模式是完全封装且自修改的策略模式”</li>
<li>策略模式只是的条件选择只执行一次;而状态模式是随着实例参数（对象实例的状态）的改变不停地更改执行模式。换言之，策略模式只是在对象初始化的时候更改执行模式;而状态模式是根据对象实例的周期时间而动态地改变对象实例的执行模式</li>
<li>在状态模式中，状态的变迁是由对象的内部条件决定，外界只需关心其接口，不必关心其状态对象的创建和转化;而策略模式里，采取何种策略由外部条件(Context)决定</li>
<li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类;而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系</li>
<li>使用策略模式时，客户端需要知道所选的具体策略是哪一个;而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换</li>
<li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式;如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式</li>
</ul>
<p>2.工厂模式</p>
<ul>
<li>工厂模式是创建型模式，它关注对象创建提供创建对象的接口让对象的创建与具体的使用客户无关;策略模式是对象行为型模式，它关注行为和算法的封装。它定义一系列的算法，把每一个算法封装起来,，并且使它们可相互替换，使得算法可独立于使用它的客户而变化</li>
</ul>
<p>3.责任链模式</p>
<ul>
<li>状态与责任链两个设计模式最大的区别就是状态模式是让各个状态对象自己知道其下一个处理的对象是谁;而职责链模式中的各个对象并不指定其下一个处理的对象到底是谁，只有在客户端才设定</li>
</ul>
<h2 id="策略模式具体实例"><a href="#策略模式具体实例" class="headerlink" title="策略模式具体实例"></a>策略模式具体实例</h2><hr>
<h3 id="旅游交通工具选择问题"><a href="#旅游交通工具选择问题" class="headerlink" title="旅游交通工具选择问题"></a>旅游交通工具选择问题</h3><p><strong>使用策略模式简单实现前言所述的旅游交通工具选择问题</strong></p>
<p><strong>代码实现</strong><br>1.定义抽象旅游策略类<code>TravelStrategy</code>，并声明<code>Travel()</code>接口:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Travel Strategy</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">TravelStrategy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Travel</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.定义三种具体的旅游类<code>CarStrategy</code>、<code>AirplaneStrategy</code>和<code>TrainStrategy</code>，并实现<code>Travel()</code>接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Travel Strategy : Car Strategy</span></span><br><span class="line"><span class="comment">// Singleton &amp; Atuo memory delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarStrategy</span> : <span class="keyword">public</span> TravelStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> CarStrategy *m_pStrategy;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Garbage</span></span><br><span class="line">    &#123;</span><br><span class="line">        ~<span class="built_in">Garbage</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NULL_POINTER</span>(CarStrategy::<span class="built_in">GetInstance</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="keyword">delete</span> <span class="title">CarStrategy::GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Garbage g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CarStrategy* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NULL_POINTER</span>(m_pStrategy))</span><br><span class="line">        &#123;</span><br><span class="line">            m_pStrategy =  <span class="keyword">new</span> <span class="built_in">CarStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">CarStrategy</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">CarStrategy</span>(<span class="type">const</span> CarStrategy&amp;) &#123;&#125;;</span><br><span class="line">    CarStrategy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> CarStrategy&amp;) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Travel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Select The Way of Car For Traveling&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CarStrategy* CarStrategy::m_pStrategy = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Travel Strategy : Airplane Strategy</span></span><br><span class="line"><span class="comment">// Singleton &amp; Atuo memory delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirplaneStrategy</span> : <span class="keyword">public</span> TravelStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> AirplaneStrategy *m_pStrategy;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Garbage</span></span><br><span class="line">    &#123;</span><br><span class="line">        ~<span class="built_in">Garbage</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NULL_POINTER</span>(AirplaneStrategy::<span class="built_in">GetInstance</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="keyword">delete</span> <span class="title">AirplaneStrategy::GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Garbage g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> AirplaneStrategy* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NULL_POINTER</span>(m_pStrategy))</span><br><span class="line">        &#123;</span><br><span class="line">            m_pStrategy =  <span class="keyword">new</span> <span class="built_in">AirplaneStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">AirplaneStrategy</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">AirplaneStrategy</span>(<span class="type">const</span> AirplaneStrategy&amp;) &#123;&#125;;</span><br><span class="line">    AirplaneStrategy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> AirplaneStrategy&amp;) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Travel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Select The Way of Airplane For Traveling&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">AirplaneStrategy* AirplaneStrategy::m_pStrategy = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Travel Strategy : Train Strategy</span></span><br><span class="line"><span class="comment">// Singleton &amp; Atuo memory delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrainStrategy</span> : <span class="keyword">public</span> TravelStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> TrainStrategy *m_pStrategy;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Garbage</span></span><br><span class="line">    &#123;</span><br><span class="line">        ~<span class="built_in">Garbage</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NULL_POINTER</span>(TrainStrategy::<span class="built_in">GetInstance</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="keyword">delete</span> <span class="title">TrainStrategy::GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Garbage g;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> TrainStrategy* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NULL_POINTER</span>(m_pStrategy))</span><br><span class="line">        &#123;</span><br><span class="line">            m_pStrategy =  <span class="keyword">new</span> <span class="built_in">TrainStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m_pStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TrainStrategy</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">TrainStrategy</span>(<span class="type">const</span> TrainStrategy&amp;) &#123;&#125;;</span><br><span class="line">    TrainStrategy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> TrainStrategy&amp;) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Travel</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Select The Way of Train For Traveling&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TrainStrategy* TrainStrategy::m_pStrategy = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>3.定义旅游的上下文调用类<code>Person</code>, 具有<code>TravelStrategy</code>的一个对象引用:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Travel Context : Person</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TravelStrategy *m_pTravelStrategy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(TravelStrategy *pTS) : m_pTravelStrategy(pTS) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTravelStrategy</span>(<span class="params">TravelStrategy *pTS</span>) <span class="comment">// 有Garbage类，不需要手动释放ConcreteTravelStrategy对象了</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pTravelStrategy = pTS;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Travel</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_pTravelStrategy-&gt;Travel(); <span class="comment">// 委托调用具体Strategy的Travel方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试策略模式:</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">void</span> <span class="function"><span class="title">StrategyTest_Travel</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">Person</span> *<span class="variable">pPerson</span> = <span class="variable">new</span> <span class="function"><span class="title">Person</span>(<span class="variable">CarStrategy</span>::<span class="title">GetInstance</span>());</span></span><br><span class="line"><span class="function">    <span class="variable">pPerson</span>-&gt;<span class="title">Travel</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="variable">pPerson</span>-&gt;<span class="title">SetTravelStrategy</span>(<span class="variable">AirplaneStrategy</span>::<span class="title">GetInstance</span>());</span></span><br><span class="line"><span class="function">    <span class="variable">pPerson</span>-&gt;<span class="title">Travel</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="variable">pPerson</span>-&gt;<span class="title">SetTravelStrategy</span>(<span class="variable">TrainStrategy</span>::<span class="title">GetInstance</span>());</span></span><br><span class="line"><span class="function">    <span class="variable">pPerson</span>-&gt;<span class="title">Travel</span>();</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">SAFE_RELASE_POINTER</span>(<span class="variable">pPerson</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>5.运行结果:</p>
<pre><code>Select The Way of Car For Traveling
Select The Way of Airplane For Traveling
Select The Way of Train For Traveling
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式(结构型)</title>
    <url>/2018/07/02/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在稍微大一些的公司组织结构体系中，会有不同的功能部门，如HR Department、Financial Department等等。而有时候为了方便异地管理,又设置不同的子公司，子公司内部又有上述不同的功能部门组成，对于这种类似于文件系统的树形结构，可以考虑使用组合模式去实现。</p>
<span id="more"></span>

<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><hr>
<p>组合模式，该模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子节点(不包含子节点的节点)和组合节点(包含子节点的节点)。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将对象组合成树形结构以表示“部分、整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Component<br>为组合中的对象声明接口；<br>在适当的情况下,实现所有类共有接口的缺省行为；<br>声明的一个接口用于访问和管理Component的子组件;<br>(可选)在递归结构中定义一个接口，用于访问一个父部件，并在合适的情况下实现它;</p>
</li>
<li><p>Leaf<br>在组合中表示叶节点对象(叶节点没有子节点);<br>在组合中定义对象的行为;</p>
</li>
<li><p>Composite<br>定义有子部件的那些部件的行为;<br>存储子部件;<br>在Component接口中实现与子部件有关的操作</p>
</li>
<li><p>Client<br>通过Component接口操纵组合部件的对象</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/07/02/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/Composite.jpg" alt="component"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义一个实现类接口<code>AbstractComponent</code>,及操作接口<code>Operator()</code>和访问部件的接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象的组件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractComponent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractComponent</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Operator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(shared_ptr&lt;AbstractComponent&gt; &amp;pAC)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Remove</span><span class="params">(shared_ptr&lt;AbstractComponent&gt; &amp;pAC)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> shared_ptr&lt;AbstractComponent&gt;&amp; <span class="title">GetChild</span><span class="params">(<span class="type">int</span> n)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">int</span> nDepth)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义叶子组件类<code>Leaf</code>继承与<code>AbstractComponent</code>,并实现其相应接口<code>Operator()</code>,对于<code>Add()</code>、<code>Remove()</code>、<code>GetChild()</code>,实现为空或进行异常处理:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Leaf : public AbstractComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_strName;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Leaf(<span class="params">string</span> <span class="params">strName</span>)</span> : m<span class="constructor">_strName(<span class="params">strName</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Leaf()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Operator()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; I am Named&quot;</span> &lt;&lt; m_strName &lt;&lt; <span class="string">&quot;Leaf Operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Leaf组件对象内部没有子对象，故Add,Removew为空,必须去实现AbstractComponent的Virtual接口，即使为空</span></span><br><span class="line">    void <span class="constructor">Add(<span class="params">shared_ptr</span>&lt;AbstractComponent&gt; &amp;<span class="params">pAC</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Remove(<span class="params">shared_ptr</span>&lt;AbstractComponent&gt; &amp;<span class="params">pAC</span>)</span> &#123;&#125;;</span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;&amp; <span class="constructor">GetChild(<span class="params">int</span> <span class="params">n</span>)</span> &#123;return shared_ptr&lt;AbstractComponent&gt;(<span class="number">0</span>);&#125;</span><br><span class="line">    void <span class="constructor">Show(<span class="params">int</span> <span class="params">nDepth</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nDepth; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; flush; <span class="comment">// 清除缓存区 不换行，endl 是清除缓冲区 + 换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m_strName &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再定义一个组合组件类<code>Composite</code>继承与<code>AbstractComponent</code>,并实现其相应接口<code>Operator()</code>、<code>Add()</code>及<code>Remove()</code>、<code>GetChild()</code>：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合组件类，里面包含其他组件对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span> : <span class="keyword">public</span> AbstractComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_strName;</span><br><span class="line">    vector&lt;shared_ptr&lt;AbstractComponent&gt;&gt; m_VecComponent;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Composite</span>(string strName): <span class="built_in">m_strName</span>(strName) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Composite</span>() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Operator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; I am Named&quot;</span> &lt;&lt; m_strName &lt;&lt; <span class="string">&quot;Composite Operator&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(shared_ptr&lt;AbstractComponent&gt; &amp;pAC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_VecComponent.<span class="built_in">push_back</span>(pAC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Remove</span><span class="params">(shared_ptr&lt;AbstractComponent&gt; &amp;pAC)</span> <span class="comment">// 删除与指定组件对象名字一样的</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;shared_ptr&lt;AbstractComponent&gt;&gt;::iterator it = m_VecComponent.<span class="built_in">begin</span>();</span><br><span class="line">             it !=m_VecComponent.<span class="built_in">end</span>();</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == pAC)</span><br><span class="line">            &#123;</span><br><span class="line">                m_VecComponent.<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">shared_ptr&lt;AbstractComponent&gt;&amp; <span class="title">GetChild</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m_VecComponent.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;n is out of range&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;AbstractComponent&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_VecComponent[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">int</span> nDepth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 显示当前组合对象自己的名字信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt; nDepth; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; flush;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m_strName &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示当前组合对象容器内部包含的子对象的名字信息</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;shared_ptr&lt;AbstractComponent&gt;&gt;::iterator it = m_VecComponent.<span class="built_in">begin</span>();</span><br><span class="line">             it != m_VecComponent.<span class="built_in">end</span>();</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="built_in">Show</span>(nDepth + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试组合模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">CompositeTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建根节点</span></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Root(<span class="params">new</span> Composite(<span class="string">&quot;Root&quot;</span>)</span>);</span><br><span class="line">    <span class="comment">//创建并添加两个根节点的叶子节点A，B</span></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Leaf_Root_A(<span class="params">new</span> Leaf(<span class="string">&quot;Leaf A&quot;</span>)</span>);</span><br><span class="line">    pAC_Root-&gt;<span class="constructor">Add(<span class="params">pAC_Leaf_Root_A</span>)</span>;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Leaf_Root_B(<span class="params">new</span> Leaf(<span class="string">&quot;Leaf B&quot;</span>)</span>);</span><br><span class="line">    pAC_Root-&gt;<span class="constructor">Add(<span class="params">pAC_Leaf_Root_B</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并添加一个根节点的组合节点A,该组合节点内包含两个Leaf节点A,B</span></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Sub_Composite(<span class="params">new</span> Composite(<span class="string">&quot;Sub Composite A&quot;</span>)</span>);</span><br><span class="line">    pAC_Root-&gt;<span class="constructor">Add(<span class="params">pAC_Sub_Composite</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并添加该组合节点内部包含的两个Leaf节点</span></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Leaf_Sub_A(<span class="params">new</span> Leaf(<span class="string">&quot;Sub Composite Leaf A&quot;</span>)</span>);</span><br><span class="line">    pAC_Sub_Composite-&gt;<span class="constructor">Add(<span class="params">pAC_Leaf_Sub_A</span>)</span>;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Leaf_Sub_B(<span class="params">new</span> Leaf(<span class="string">&quot;Sub Composite Leaf B&quot;</span>)</span>);</span><br><span class="line">    pAC_Sub_Composite-&gt;<span class="constructor">Add(<span class="params">pAC_Leaf_Sub_B</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建并添加根节点的另一个组合节点A2,该组合节点内包含两个Leaf节点A2,B2</span></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Sub_Composite2(<span class="params">new</span> Composite(<span class="string">&quot;Sub Composite A2&quot;</span>)</span>);</span><br><span class="line">    pAC_Root-&gt;<span class="constructor">Add(<span class="params">pAC_Sub_Composite2</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并添加该组合节点内部包含的两个Leaf节点</span></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Leaf_Sub_A2(<span class="params">new</span> Leaf(<span class="string">&quot;Sub Composite Leaf A2&quot;</span>)</span>);</span><br><span class="line">    pAC_Sub_Composite2-&gt;<span class="constructor">Add(<span class="params">pAC_Leaf_Sub_A2</span>)</span>;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;AbstractComponent&gt;p<span class="constructor">AC_Leaf_Sub_B2(<span class="params">new</span> Leaf(<span class="string">&quot;Sub Composite Leaf B2&quot;</span>)</span>);</span><br><span class="line">    pAC_Sub_Composite2-&gt;<span class="constructor">Add(<span class="params">pAC_Leaf_Sub_B2</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示Root下所有组合节点和Leaf节点</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before Remove pAC_Leaf_Sub_B2:&quot;</span> &lt;&lt; endl &lt;&lt;endl;</span><br><span class="line">    pAC_Root-&gt;<span class="constructor">Show(0)</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除组合节点A2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Remove pAC_Leaf_Sub_B2:&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    pAC_Sub_Composite2-&gt;<span class="constructor">Remove(<span class="params">pAC_Leaf_Sub_B2</span>)</span>;</span><br><span class="line">    pAC_Root-&gt;<span class="constructor">Show(0)</span>;</span><br><span class="line">    <span class="comment">//只需要释放根节点，其他节点在根节点的析构函数内释放掉了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Before Remove pAC_Leaf_Sub_B2:
Root
----Leaf A
----Leaf B
----Sub Composite A
--------Sub Composite Leaf A
--------Sub Composite Leaf B
----Sub Composite A2
--------Sub Composite Leaf A2
--------Sub Composite Leaf B2
After Remove pAC_Leaf_Sub_B2:
Root
----Leaf A
----Leaf B
----Sub Composite A
--------Sub Composite Leaf A
--------Sub Composite Leaf B
----Sub Composite A2
--------Sub Composite Leaf A2
</code></pre>
<h3 id="对于叶子节点改进"><a href="#对于叶子节点改进" class="headerlink" title="对于叶子节点改进"></a>对于叶子节点改进</h3><p>在增加新的组合类型时,无须修改现有类库代码,只需增加一个新的组合类作为<code>AbstractComponent</code>类的子类即可,但是由于在<code>AbstractComponent</code>中声明了大量用于管理和访问成员构件的方法,例如<code>add()</code>、<code>remove()</code>等方法,我们不得不在新增的类中实现这些方法,或者提供对应的错误提示和异常处理。为了简化代码,可以考虑下面两种解决方案：</p>
<h4 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h4><p>将叶子构件的<code>add()</code>、<code>remove()</code>等方法的实现代码移至<code>AbstractComponent</code>父类中，由父类提供一个默认实现。</p>
<blockquote>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>
</blockquote>
<h4 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h4><p>安全组合模式中，在抽象构件<code>Component</code>中没有声明任何用于管理成员对象的方法，而是在<code>Composite</code>类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。</p>
<blockquote>
<p>安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</p>
</blockquote>
<h4 id="增加一个获取Composite的接口来区分"><a href="#增加一个获取Composite的接口来区分" class="headerlink" title="增加一个获取Composite的接口来区分"></a>增加一个获取Composite的接口来区分</h4><p>一种办法是在<code>Component</code>类中声明一个操作<code>Composite* GetComposite()</code>。<code>Component</code>提供提供了一个返回空指针的缺省操作。<code>Composite</code>类重新定义这个操作并通过<code>this</code>指针来返回对象本身：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    virtual Composite* GetComposite() &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Composite</span>: <span class="type">public</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    virtual Composite* GetComposite() &#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> : <span class="type">public</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，通过判断对象类型来进行相应调用：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Composite *composite <span class="operator">=</span> new Composite<span class="comment">;</span></span><br><span class="line">Leaf* leaf <span class="operator">=</span> new Leaf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Component *component<span class="comment">;</span></span><br><span class="line">Composite *test<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">component</span> <span class="operator">=</span> composite<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if(test <span class="operator">=</span> component-&gt;GetComposite())</span><br><span class="line">&#123;</span><br><span class="line">    test-&gt;Add(new Leaf)<span class="comment">; // willl add leaf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">component</span> <span class="operator">=</span> leaf<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">if(test <span class="operator">=</span> component-&gt;GetComposite())</span><br><span class="line">&#123;</span><br><span class="line">    test-&gt;Add(new Leaf)<span class="comment">; // will not add leaf</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>想表示对象的部分-整体层次结构</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象</li>
<li>在一个使用面向对象语言开发的系统中需要处理一个树形结构</li>
<li>一个对象有多个变化因素的时候，通过抽象这些变化因素，将依赖具体实现，修改为依赖抽象</li>
<li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码</li>
<li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单</li>
</ul>
</li>
<li>缺点<ul>
<li>在增加新构件时很难对容器中的构件类型进行限制,有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层</li>
</ul>
</li>
</ul>
<h2 id="组合模式具体实例"><a href="#组合模式具体实例" class="headerlink" title="组合模式具体实例"></a>组合模式具体实例</h2><hr>
<h3 id="公司组织结构"><a href="#公司组织结构" class="headerlink" title="公司组织结构"></a>公司组织结构</h3><p><strong>实现前言所描述的公司组织结构</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>抽象公司类:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象公司类</span></span><br><span class="line"><span class="keyword">class</span> Company</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> m_strName;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Company(<span class="params">string</span> <span class="params">strName</span>)</span> : m<span class="constructor">_strName(<span class="params">strName</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">Company()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Add(Company <span class="operator">*</span><span class="params">pC</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Remove(Company <span class="operator">*</span><span class="params">pC</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="constructor">GetName()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_strName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Show(<span class="params">int</span> <span class="params">nDepth</span>)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>公司的两个部门(叶子节点):</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 叶子节点1---金融部门</span></span><br><span class="line"><span class="keyword">class</span> FinanceDepartment : public Company</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">FinanceDepartment(<span class="params">string</span> <span class="params">strName</span>)</span> : <span class="constructor">Company(<span class="params">strName</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">FinanceDepartment()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Add(Company <span class="operator">*</span><span class="params">pC</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Remove(Company <span class="operator">*</span><span class="params">pC</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Show(<span class="params">int</span> <span class="params">nDepth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nDepth; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; flush;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="constructor">GetName()</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 叶子节点2-- HR部门</span></span><br><span class="line"><span class="keyword">class</span> HRDepartment : public Company</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">HRDepartment(<span class="params">string</span> <span class="params">strName</span>)</span> : <span class="constructor">Company(<span class="params">strName</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">HRDepartment()</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Add(Company <span class="operator">*</span><span class="params">pC</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Remove(Company <span class="operator">*</span><span class="params">pC</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Show(<span class="params">int</span> <span class="params">nDepth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nDepth; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; flush;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="constructor">GetName()</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合公司(组合节点)：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合公司</span></span><br><span class="line"><span class="keyword">class</span> CompositeCompany : public Company</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;Company*&gt; m__ListCompany;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">CompositeCompany(<span class="params">string</span> <span class="params">strName</span>)</span> : <span class="constructor">Company(<span class="params">strName</span>)</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="constructor">CompositeCompany()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Company*&gt;::iterator it = m__ListCompany.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">            it != m__ListCompany.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">            ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NULL != (*it))</span><br><span class="line">            &#123;</span><br><span class="line">                delete *it;</span><br><span class="line">                *it = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            m__ListCompany.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Add(Company <span class="operator">*</span><span class="params">pC</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        m__ListCompany.push<span class="constructor">_back(<span class="params">pC</span>)</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    void <span class="constructor">Remove(Company <span class="operator">*</span><span class="params">pC</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Company*&gt;::iterator it = m__ListCompany.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m__ListCompany.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it) <span class="comment">//  ++it 不是it++</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it)-&gt;<span class="constructor">GetName()</span><span class="operator"> == </span>pC-&gt;<span class="constructor">GetName()</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                delete *it;</span><br><span class="line">                *it = NULL;</span><br><span class="line">                m__ListCompany.erase(it); <span class="comment">// 防止erase之后迭代器失效</span></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    void <span class="constructor">Show(<span class="params">int</span> <span class="params">nDepth</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nDepth; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; flush;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="constructor">GetName()</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Company*&gt;::iterator it = m__ListCompany.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m__ListCompany.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NULL != (*it))</span><br><span class="line">            &#123;</span><br><span class="line">                (*it)-&gt;<span class="constructor">Show(<span class="params">nDepth</span> + 2)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>测试Computer桥接模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">CompositeTest_Company()</span></span><br><span class="line">&#123;</span><br><span class="line">    Company *pC_TopCpy = <span class="keyword">new</span> <span class="constructor">CompositeCompany(<span class="string">&quot;Top Company&quot;</span>)</span>; </span><br><span class="line">    Company *pC_Finance = <span class="keyword">new</span> <span class="constructor">FinanceDepartment(<span class="string">&quot;Company Finance Dept&quot;</span>)</span>;</span><br><span class="line">    Company *pC_HR      = <span class="keyword">new</span> <span class="constructor">HRDepartment(<span class="string">&quot;Company HR Dept&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pC_TopCpy-&gt;<span class="constructor">Add(<span class="params">pC_Finance</span>)</span>;</span><br><span class="line">    pC_TopCpy-&gt;<span class="constructor">Add(<span class="params">pC_HR</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Company *pC_SubCpy = <span class="keyword">new</span> <span class="constructor">CompositeCompany(<span class="string">&quot;Sub Company&quot;</span>)</span>;</span><br><span class="line">    Company *pC_Sub_HR = <span class="keyword">new</span> <span class="constructor">HRDepartment(<span class="string">&quot;Sub Company HR Dept&quot;</span>)</span>;</span><br><span class="line">    pC_SubCpy-&gt;<span class="constructor">Add(<span class="params">pC_Finance</span>)</span>;</span><br><span class="line">    pC_SubCpy-&gt;<span class="constructor">Add(<span class="params">pC_HR</span>)</span>;</span><br><span class="line">    pC_SubCpy-&gt;<span class="constructor">Add(<span class="params">pC_Sub_HR</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pC_TopCpy-&gt;<span class="constructor">Add(<span class="params">pC_SubCpy</span>)</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before Remove Sub Company HR Dept&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pC_TopCpy-&gt;<span class="constructor">Show(0)</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Remove Sub Company HR Dept&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pC_SubCpy-&gt;<span class="constructor">Remove(<span class="params">pC_Sub_HR</span>)</span>;</span><br><span class="line">    pC_TopCpy-&gt;<span class="constructor">Show(0)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果：</p>
<p> Before Remove Sub Company HR Dept<br> Top Company<br> ——Company Finance Dept<br> ——Company HR Dept<br> ——Sub Company<br> ————Company Finance Dept<br> ————Company HR Dept<br> ————Sub Company HR Dept<br> After Remove Sub Company HR Dept<br> Top Company<br> ——Company Finance Dept<br> ——Company HR Dept<br> ——Sub Company<br> ————Company Finance Dept<br> ————Company HR Dept</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式(结构型)</title>
    <url>/2018/07/22/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在平时的生活中，手机几乎无处不在，有些比较细心的机友可能会给手机增加各种一些额外扩展的功能，如屏保防止手机碎屏，添加些小挂件增加美观等等。同时市面上有各种类型的手机，如Iphone,Nokia等等,，这样就会组合成带有装饰功能的各种手机了，如带屏保的iphone手机,带屏保又带挂件的Nokia手机等。对于此种现象的描述，可以考虑使用装饰模式。</p>
<span id="more"></span>

<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><hr>
<p>装饰模式，是通过对象组合的功能复用方式来为已有的对象增加额外的功能。是一种用于替代继承的技术,它通过一种无须定义子类的方式来给对象动态增加职责,使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能</p>
<blockquote>
<p>通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。<br>在面向对象的设计中，而我们也应该尽量使用对象组合而不是对象继承来扩展和复用功能。<br>装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。是通过把复杂的功能简单化，分散化，然后再运行期间根据需要来动态组合的这样一个模式。</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>动态地给一个对象添加一些额外的职责。就增加功能来说， 装饰模式相比生成子类更灵活</p>
<blockquote>
<p>由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展,是一种对象结构型模式</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Component<br>具体构件和抽象装饰类的共同父类<br>声明了具体构件类中实现的业务方法，可以使客户端可以一致的处理装饰前和装饰后的对象</p>
</li>
<li><p>ConcreteComponent<br>具体构件类，抽象构件类的子类<br>实现了抽象构件类的方法，同时装饰器可以给它增加额外的职责或方法</p>
</li>
<li><p>Decorator<br>抽象装饰类，抽象构件类的子类<br>用于给具体构件增加职责，但是具体职责在其子类中实现<br>维护一个指向抽象构件类的指针或引用，通过它可以调用装饰之前构件对象的方法，并且通过抽象装饰类的子类来扩展该方法来达到装饰的目的</p>
</li>
<li><p>ConcreteDecorator<br>具体装饰类， 抽象装饰类的子类<br>它可以调用在抽象装饰类中定义的方法,并可以增加新的方法用以扩充对象的行为</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/07/22/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/Decorator.jpg" alt="decorator"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>首先定义一个抽象构件类<code>Component</code>,及操作接口<code>Operator()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象构件类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Component() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Operator</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再定义具体构件类<code>ConcreteComponentA</code>和<code>ConcreteComponentB</code>,并实现其相应接口<code>Operator()</code>:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体构件类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ConcreteComponentA</span> : <span class="symbol">public</span> <span class="symbol">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteComponentA() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Operator()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Concrete Component A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体构件类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ConcreteComponentB</span> : <span class="symbol">public</span> <span class="symbol">Component</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteComponentB() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Operator()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Concrete Component B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个抽象装饰器类<code>Decorator</code>，其继承于抽象构件类<code>Component</code>，以保持接口<code>Operator()</code>一致性，客户端可以一致性的处理装饰前和装饰后的对象,同时具有一个抽象构件类的对象指针或引用，以调用装饰前的构件方法同时还可以扩展该方法达到装饰的目的：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 装饰类父类（非抽象，继承抽象构件类,与桥接模式的不同）</span></span><br><span class="line"><span class="keyword">class</span> Decorator : public Component</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Component *m_pC;          <span class="comment">// 与桥接模式类似，都是对象组合</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Decorator(Component <span class="operator">*</span><span class="params">pC</span>)</span> : m<span class="constructor">_pC(<span class="params">pC</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Operator()</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (NULL != m_pC)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pC-&gt;<span class="constructor">Operator()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义具体的装饰器类<code>ConcreteDecoratorA</code>和<code>ConcreteDecoratorB</code>为构件增加具体的不同职责功能，可以是状态或操作：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的装饰类A，增加状态</span></span><br><span class="line"><span class="keyword">class</span> ConcreteDecoratorA : public Decorator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_AddedState;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteDecoratorA(Component <span class="operator">*</span><span class="params">pC</span>, <span class="params">int</span> <span class="params">state</span>)</span> : <span class="constructor">Decorator(<span class="params">pC</span>)</span>, m<span class="constructor">_AddedState(<span class="params">state</span>)</span> &#123;&#125;;</span><br><span class="line">    void <span class="constructor">Operator()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Decorator::<span class="constructor">Operator()</span>; <span class="comment">// 装饰之前的操作</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Decorator A Added State: &quot;</span> &lt;&lt; m_AddedState &lt;&lt; endl; </span><br><span class="line">        <span class="comment">//扩展状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 具体的装饰类B，增加操作</span></span><br><span class="line"><span class="keyword">class</span> ConcreteDecoratorB : public Decorator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteDecoratorB(Component <span class="operator">*</span><span class="params">pC</span>)</span> : <span class="constructor">Decorator(<span class="params">pC</span>)</span>&#123;&#125;;</span><br><span class="line">    void <span class="constructor">Operator()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Decorator::<span class="constructor">Operator()</span>; <span class="comment">// 装饰之前的操作</span></span><br><span class="line">        <span class="constructor">AddedOperator()</span>;  <span class="comment">// 扩展的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    void <span class="constructor">AddedOperator()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Decorator B Added Behavior:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试装饰模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">DecoratorTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个增加了装饰A的组件A</span></span><br><span class="line">    Component *pC_A = <span class="keyword">new</span> <span class="constructor">ConcreteComponentA()</span>;</span><br><span class="line">    Component *pD_AA = <span class="keyword">new</span> <span class="constructor">ConcreteDecoratorA(<span class="params">pC_A</span>,10)</span>;</span><br><span class="line">    pD_AA-&gt;<span class="constructor">Operator()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个增加了装饰B的组件A</span></span><br><span class="line">    Component *pD_BA = <span class="keyword">new</span> <span class="constructor">ConcreteDecoratorB(<span class="params">pC_A</span>)</span>;</span><br><span class="line">    pD_BA-&gt;<span class="constructor">Operator()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个同时增加了装饰 A 和 B的组件A</span></span><br><span class="line">    Component *pD_AB_A = <span class="keyword">new</span> <span class="constructor">ConcreteDecoratorB(<span class="params">pD_AA</span>)</span>;</span><br><span class="line">    pD_AB_A-&gt;<span class="constructor">Operator()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个增加了装饰A的组件B</span></span><br><span class="line">    Component *pC_B = <span class="keyword">new</span> <span class="constructor">ConcreteComponentB()</span>;</span><br><span class="line">    Component *pD_AB = <span class="keyword">new</span> <span class="constructor">ConcreteDecoratorA(<span class="params">pC_B</span>,10)</span>;</span><br><span class="line">    pD_AB-&gt;<span class="constructor">Operator()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个增加了装饰B的组件B </span></span><br><span class="line">    Component *pD_BB = <span class="keyword">new</span> <span class="constructor">ConcreteDecoratorB(<span class="params">pC_B</span>)</span>;</span><br><span class="line">    pD_BB-&gt;<span class="constructor">Operator()</span>;</span><br><span class="line"></span><br><span class="line">    delete pC_A;      pC_A = NULL;</span><br><span class="line">    delete pC_B;      pC_B = NULL;</span><br><span class="line">    delete pD_AA;     pD_AA = NULL;</span><br><span class="line">    delete pD_BA;     pD_BA = NULL;</span><br><span class="line">    delete pD_AB;     pD_AB = NULL;</span><br><span class="line">    delete pD_BB;     pD_BB = NULL;</span><br><span class="line">    delete pD_AB_A;   pD_AB_A = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>I am Concrete Component A
Concrete Decorator A Added State: 10
I am Concrete Component A
Concrete Decorator B Added Behavior:
I am Concrete Component A
Concrete Decorator A Added State: 10
Concrete Decorator B Added Behavior:
I am Concrete Component B
Concrete Decorator A Added State: 10
I am Concrete Component B
Concrete Decorator B Added Behavior:
</code></pre>
<h3 id="对装饰模式的分类"><a href="#对装饰模式的分类" class="headerlink" title="对装饰模式的分类"></a>对装饰模式的分类</h3><h4 id="透明装饰模式"><a href="#透明装饰模式" class="headerlink" title="透明装饰模式"></a>透明装饰模式</h4><p>上面描述的标准装饰模式即是透明的装饰模式，在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别<br>如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">Component *<span class="keyword">c</span><span class="number">1</span><span class="punctuation">,</span> *<span class="keyword">c</span><span class="number">2</span><span class="comment">;  // 使用抽象构件类定义对象</span></span><br><span class="line"><span class="keyword">c</span><span class="number">1</span>  <span class="operator">=</span>  new ConcreteComponent<span class="comment">;</span></span><br><span class="line"><span class="keyword">c</span><span class="number">2</span> <span class="operator">=</span> new ConcreteDecorator(<span class="keyword">c</span><span class="number">1</span>)<span class="comment">; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时，具体装饰类扩展的方法必须在构件的原有方法中得到显示的调用,但是客户端不能显示的单独调用新增加的业务方法</p>
</blockquote>
<h4 id="半透明装饰模式"><a href="#半透明装饰模式" class="headerlink" title="半透明装饰模式"></a>半透明装饰模式</h4><p>半透明装饰模式中，对于具体装饰类，需要使用具体装饰类型来定义装饰之后的对象，而不完全针对抽象编程。有时我们需要单独调用新增的业务方法。为了能够调用到新增方法，我们不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式，也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的，如：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Component *c1<span class="comment">;   </span></span><br><span class="line">ConcreteDecorator *d1<span class="comment">; //使用具体的装饰器类型来定义对象</span></span><br><span class="line"><span class="attribute">c1</span>  <span class="operator">=</span>  new ConcreteComponent<span class="comment">;</span></span><br><span class="line"><span class="attribute">d1</span> <span class="operator">=</span> new ConcreteDecorator(c1)<span class="comment">; </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>它使得我们可以给某个对象而不是整个类添加一些功能</li>
<li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li>
<li>处理那些可以撤销的职责<br>-当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式,不能采用继承的情况是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>对于扩展一个对象的功能，装饰模式比继承更加灵活性, 可以通过一种动态的方式来扩展一个对象的功能,不会导致类的个数急剧增加</li>
<li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象</li>
<li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”</li>
</ul>
</li>
<li>缺点<ul>
<li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能</li>
<li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐</li>
</ul>
</li>
</ul>
<h3 id="与桥接模式的区别"><a href="#与桥接模式的区别" class="headerlink" title="与桥接模式的区别"></a>与桥接模式的区别</h3><p>二者都是为了防止过度的继承，从而造成子类泛滥的情况</p>
<ol>
<li><p>桥接模式的定义是将抽象化与实现化分离（用组合的方式而不是继承的方式），使得两者可以独立变化，可以减少派生类的增长桥接模式中所说的分离，其实是指将结构与实现分离（当结构和实现有可能发生变化时）或属性与基于属性的行为进行分离；而装饰者只是对基于属性的行为进行封闭成独立的类，从而达到对其进行装饰，也就是扩展</p>
</li>
<li><p>桥接中的行为是横向的行为，行为彼此之间无关联，注意这里的行为之间是没有关联的，就比如异常和异常处理之间是没有行为关联的一样；而装饰者模式中的行为具有可叠加性，其表现出来的结果是一个整体，一个各个行为组合后的一个结果</p>
</li>
</ol>
<blockquote>
<p>比如：异常类和异常处理类之间就可以使用桥接模式来实现完成，而不能使用装饰模式来进行设计；如果对于异常的处理需要进行扩展时，我们又可以对异常处理类添加Decorator，从而添加处理的装饰，达到异常处理的扩展，这就是一个桥接模式与装饰模式的搭配；</p>
</blockquote>
<h2 id="装饰模式具体实例"><a href="#装饰模式具体实例" class="headerlink" title="装饰模式具体实例"></a>装饰模式具体实例</h2><hr>
<h3 id="手机装饰设计"><a href="#手机装饰设计" class="headerlink" title="手机装饰设计"></a>手机装饰设计</h3><p><strong>实现前言所描述的不同手机的装饰设计，允许为手机添加特性，比如增加挂件、屏幕贴膜等</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li><p>抽象手机类:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowPhone</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体手机类:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Nokia</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">NokiaPhone</span> : <span class="symbol">public</span> <span class="symbol">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> ShowPhone()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Nokia Phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iphone</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">ApplePhone</span> : <span class="symbol">public</span> <span class="symbol">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> ShowPhone()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Apple Phone&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象手机装饰类，并继承与抽象手机类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手机装饰类(非抽象，父类,继承Phone）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorPhone</span> : <span class="keyword">public</span> Phone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Phone *m_pPhone;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DecoratorPhone</span>(Phone *pP) : <span class="built_in">m_pPhone</span>(pP) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ShowPhone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != m_pPhone)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pPhone-&gt;<span class="built_in">ShowPhone</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体装饰类:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加屏保的装饰类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorPhoneA</span> : <span class="keyword">public</span> DecoratorPhone</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DecoratorPhoneA</span>(Phone *pP) : <span class="built_in">DecoratorPhone</span>(pP) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPhone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DecoratorPhone::<span class="built_in">ShowPhone</span>();</span><br><span class="line">        <span class="built_in">AddDecoratorA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddDecoratorA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Add Decorator Phone of Screen Protection&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加挂件的装饰类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecoratorPhoneB</span> : <span class="keyword">public</span> DecoratorPhone </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DecoratorPhoneB</span>(Phone *pP) : <span class="built_in">DecoratorPhone</span>(pP) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowPhone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DecoratorPhone::<span class="built_in">ShowPhone</span>();</span><br><span class="line">        <span class="built_in">AddDecoratorB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddDecoratorB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Add Decorator Phone of Pendant &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试Phone装饰模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">DecoratorTest_Phone()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 装了屏保的Nokia手机</span></span><br><span class="line">    Phone *pP_Nokia = <span class="keyword">new</span> <span class="constructor">NokiaPhone()</span>;</span><br><span class="line">    Phone *pD_Pendant_Nokia = <span class="keyword">new</span> <span class="constructor">DecoratorPhoneA(<span class="params">pP_Nokia</span>)</span>;</span><br><span class="line">    pD_Pendant_Nokia-&gt;<span class="constructor">ShowPhone()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装了屏保,和挂件的Nokia手机</span></span><br><span class="line">    Phone *pD_Pendant_ScnPrt_Nokia = <span class="keyword">new</span> <span class="constructor">DecoratorPhoneB(<span class="params">pD_Pendant_Nokia</span>)</span>;</span><br><span class="line">    pD_Pendant_ScnPrt_Nokia-&gt;<span class="constructor">ShowPhone()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装了挂件的Nokia手机</span></span><br><span class="line">    Phone *pD_ScnPrt_Nokia = <span class="keyword">new</span> <span class="constructor">DecoratorPhoneB(<span class="params">pP_Nokia</span>)</span>;</span><br><span class="line">    pD_ScnPrt_Nokia-&gt;<span class="constructor">ShowPhone()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装了屏保,和挂件的Apple手机</span></span><br><span class="line">    Phone *pP_Apple = <span class="keyword">new</span> <span class="constructor">ApplePhone()</span>;</span><br><span class="line">    Phone *pD_Pendant_Apple = <span class="keyword">new</span> <span class="constructor">DecoratorPhoneA(<span class="params">pP_Apple</span>)</span>;</span><br><span class="line">    Phone *pD_Pendant_ScnPrt_Apple = <span class="keyword">new</span> <span class="constructor">DecoratorPhoneB(<span class="params">pD_Pendant_Apple</span>)</span>;</span><br><span class="line">    pD_Pendant_ScnPrt_Apple-&gt;<span class="constructor">ShowPhone()</span>;</span><br><span class="line"></span><br><span class="line">    delete pP_Nokia;                       pP_Nokia = NULL;</span><br><span class="line">    delete pP_Apple;                       pP_Apple = NULL;</span><br><span class="line">    delete pD_Pendant_Nokia;               pD_Pendant_Nokia = NULL;</span><br><span class="line">    delete pD_ScnPrt_Nokia;                pD_ScnPrt_Nokia = NULL;</span><br><span class="line">    delete pD_Pendant_ScnPrt_Nokia;        pD_Pendant_ScnPrt_Nokia = NULL;</span><br><span class="line">    delete pD_Pendant_Apple;               pD_Pendant_Apple = NULL;</span><br><span class="line">    delete pD_Pendant_ScnPrt_Apple;        pD_Pendant_ScnPrt_Apple = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果：</p>
<p> I am Nokia Phone<br> Add Decorator Phone of Screen Protection<br> I am Nokia Phone<br> Add Decorator Phone of Screen Protection<br> Add Decorator Phone of Pendant<br> I am Nokia Phone<br> Add Decorator Phone of Pendant<br> I am Apple Phone<br> Add Decorator Phone of Screen Protection<br> Add Decorator Phone of Pendant</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式(行为型)</title>
    <url>/2018/03/21/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在网站博客系统中，当我们对某个博主的博客空间比较感兴趣的时候，都会选择订阅该博客，这时候就使我们很方便的获取到博主博客的更新文章了，当我们订阅的博客有更新变化时，它们也自动推送相应的更新通知给所有订阅该博客的订阅者，同时，作为订阅者，可以订阅多个博主博客。像这种一对多的对象之间的依赖关系，一个对象的改变能够影响其他对象的行为，可以通过观察者模式来实现。</p>
<span id="more"></span>

<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><hr>
<p>观察者用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为<strong>观察目标</strong>，而被通知的对象称为<strong>观察者</strong>，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。别名包括发布-订阅(Publish&#x2F;Subscribe)模式、模型-视图(Model&#x2F;View)模式、源-监听器(Source&#x2F;Listener)模式或从属者(Dependents)模式。是一种对象行为型模式</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Subject<br>观察者抽象目标，可以有任意多个观察者观察同一个目标<br>提供注册和删除观察者对象的接口<br>同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类</p>
</li>
<li><p>ConcreteSubject<br>具体目标，抽象目标子类，它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知<br>实现了在目标类中定义的抽象业务逻辑方法</p>
</li>
<li><p>Observer<br>抽象观察者，对观察目标的改变做出反应，观察者一般定义为接口<br>为那些在目标发生改变时需获得通知的对象定义一个更新接口update()</p>
</li>
<li><p>ConcreteObserver<br>具体观察者，维护一个指向ConcreteSubject对象的引用<br>存储有关状态，这些状态应与目标的状态保持一致<br>实现Observer的更新接口update()以使自身状态与目标的状态保持一致</p>
</li>
</ul>
<blockquote>
<p>当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知它的各个观察者ConcreteObserver<br>在得到一个具体目标的改变通知后, ConcreteObserver对象可向目标对象查询信息。<br>ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致</p>
</blockquote>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/03/21/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/Observer.jpg" alt="observer"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象主题目标类<code>Subject</code>,并声明<code>Notify()</code>接口和增删观察者对象的接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Subject</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Subject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Attach</span>(<span class="params">Observer *pObserver</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Detach</span>(<span class="params">Observer *pObserver</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Notify</span>()</span> = <span class="number">0</span>;         <span class="comment">// 变化通知接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetState</span>(<span class="params"><span class="built_in">int</span> state</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">GetState</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义具体的主题目标类<code>ConcreteSubject</code>,并实现<code>Notify()</code>及增删观察者接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteSubject</span></span><br><span class="line"><span class="keyword">class</span> ConcreteSubject : public Subject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;Observer*&gt; m_listObserver; <span class="comment">// 观察者集合</span></span><br><span class="line">    <span class="built_in">int</span> m_State;          <span class="comment">// 主题目标状态</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteSubject()</span>: m<span class="constructor">_State(0)</span>&#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Attach(Observer <span class="operator">*</span><span class="params">pObserver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_listObserver.push<span class="constructor">_back(<span class="params">pObserver</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Detach(Observer <span class="operator">*</span><span class="params">pObserver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_listObserver.remove(pObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Notify()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Observer*&gt;::iterator it = m_listObserver.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_listObserver.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="constructor">Update()</span>; <span class="comment">// 调用各个观察者的update方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">SetState(<span class="params">int</span> <span class="params">state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_State = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="constructor">GetState()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_State;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.再定义抽象的观察者类<code>Observer</code>,并声明更新接口<code>Update()</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Observer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>()</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowState</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.然后定义具体的观察者类<code>ConcreteObserver</code>，并实现接口<code>Update()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConcreteObserver</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> : <span class="title">public</span> <span class="title">Observer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    Subject *m_pSubject;  <span class="comment">// 具体的观察者维护一个具体的主题目标对象引用</span></span><br><span class="line">    <span class="built_in">int</span> m_State; <span class="comment">// 观察者状态</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConcreteObserver(Subject *pSubject): m_pSubject(pSubject),m_State(<span class="number">0</span>) &#123;&#125;;<span class="comment">//  具体的Observer关联的Subject，调用该Subject的方法Update（）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_State = m_pSubject-&gt;GetState();  <span class="comment">//使主题目标对象状态与观察者状态一致</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Observer State: &quot;</span> &lt;&lt; m_State &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试观察者模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">ObserverTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    Subject *pCS = <span class="keyword">new</span> <span class="constructor">ConcreteSubject()</span>;</span><br><span class="line"></span><br><span class="line">    Observer *pCO1 = <span class="keyword">new</span> <span class="constructor">ConcreteObserver(<span class="params">pCS</span>)</span>;</span><br><span class="line">    Observer *pCO2 = <span class="keyword">new</span> <span class="constructor">ConcreteObserver(<span class="params">pCS</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pCS-&gt;<span class="constructor">Attach(<span class="params">pCO1</span>)</span>;</span><br><span class="line">    pCS-&gt;<span class="constructor">Attach(<span class="params">pCO2</span>)</span>; <span class="comment">// 添加观察者对象到主题目标集合中</span></span><br><span class="line"></span><br><span class="line">    pCS-&gt;<span class="constructor">SetState(100)</span>;</span><br><span class="line">    pCS-&gt;<span class="constructor">Notify()</span>; <span class="comment">// 通知各个观察者更新状态</span></span><br><span class="line"></span><br><span class="line">    pCO1-&gt;<span class="constructor">ShowState()</span>;  <span class="comment">// 100</span></span><br><span class="line">    pCO2-&gt;<span class="constructor">ShowState()</span>;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    pCS-&gt;<span class="constructor">Detach(<span class="params">pCO2</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pCS-&gt;<span class="constructor">SetState(200)</span>;</span><br><span class="line">    pCS-&gt;<span class="constructor">Notify()</span>;</span><br><span class="line"></span><br><span class="line">    pCO1-&gt;<span class="constructor">ShowState()</span>;  <span class="comment">// 200</span></span><br><span class="line">    pCO2-&gt;<span class="constructor">ShowState()</span>;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCS</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCO1</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCO2</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行结果：</p>
<pre><code>Concrete Observer State: 100
Concrete Observer State: 100
Concrete Observer State: 200
Concrete Observer State: 100
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使他们可以独立的改变和复用</li>
<li>一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色</li>
<li>观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次</li>
<li>支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度</li>
<li>满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码</li>
</ul>
</li>
<li>缺点<ul>
<li>果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化</li>
</ul>
</li>
</ul>
<blockquote>
<p>MVC架构中也应用了观察者模式，MVC是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。其中模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容</p>
</blockquote>
<h2 id="观察者模式具体实例"><a href="#观察者模式具体实例" class="headerlink" title="观察者模式具体实例"></a>观察者模式具体实例</h2><hr>
<h3 id="博客订阅通知问题"><a href="#博客订阅通知问题" class="headerlink" title="博客订阅通知问题"></a>博客订阅通知问题</h3><p><strong>使用观察者模式简单实现前言所述的博客订阅通知功能</strong></p>
<p><strong>代码实现</strong><br>1.定义抽象的目标主题类<code>Blog</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Blog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Blog</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AttachBlogObserver</span>(<span class="params">BlogObserver *pBlogObserver</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DetachBlogObserver</span>(<span class="params">BlogObserver *pBlogObserver</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Notify</span>()</span>                                        = <span class="number">0</span>; <span class="comment">//  通知</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span>                                     = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PublishMsg</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span>                          = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetMsg</span>()</span>                                      = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.定义具体的目标主题类<code>CsdnBlog</code>,并实现通知接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Blog: Csdn Blog</span></span><br><span class="line"><span class="keyword">class</span> CsdnBlog : public Blog</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;BlogObserver*&gt; m_listBlogObserver;</span><br><span class="line">    <span class="built_in">string</span> m_BlogName;</span><br><span class="line">    <span class="built_in">string</span> m_msg;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">CsdnBlog(<span class="params">string</span> <span class="params">name</span>)</span>: m<span class="constructor">_BlogName(<span class="params">name</span>)</span>, m<span class="constructor">_msg(<span class="string">&quot;&quot;</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="constructor">GetName()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_BlogName;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">AttachBlogObserver(BlogObserver <span class="operator">*</span><span class="params">pBlogObserver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_listBlogObserver.push<span class="constructor">_back(<span class="params">pBlogObserver</span>)</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[Blog Observer]&quot;</span> &lt;&lt; pBlogObserver-&gt;<span class="constructor">GetName()</span> &lt;&lt; <span class="string">&quot; Attached To &quot;</span> &lt;&lt; <span class="string">&quot;[Blog]&quot;</span> &lt;&lt; m_BlogName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">DetachBlogObserver(BlogObserver <span class="operator">*</span><span class="params">pBlogObserver</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_listBlogObserver.remove(pBlogObserver);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[Blog Observer]&quot;</span> &lt;&lt; pBlogObserver-&gt;<span class="constructor">GetName()</span> &lt;&lt; <span class="string">&quot; Detached From &quot;</span> &lt;&lt; <span class="string">&quot;[Blog]&quot;</span> &lt;&lt; m_BlogName &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Notify()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;BlogObserver*&gt;::iterator it  = m_listBlogObserver.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_listBlogObserver.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="constructor">Update(<span class="params">this</span>)</span>; <span class="comment">// Update本Blog对象的Message到所有订阅该Blog对象的Observer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">PublishMsg(<span class="params">string</span> <span class="params">msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; m_BlogName &lt;&lt;  <span class="string">&quot; Send Message: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">        m_msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">string</span> <span class="constructor">GetMsg()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义抽象的观察者类<code>BlogObserver</code>,声明<code>Update()</code>接口:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">BlogObserver</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params">Blog *pBlog</span>)</span>     = <span class="number">0</span>;  <span class="comment">// Update指定Blog对象的Message</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">GetName</span>()</span>             = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShowMsg</span>()</span>               = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.定义具体的观察者类<code>ConcreteBlogObserver</code>，实现<code>Update()</code>接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Blog Observer</span></span><br><span class="line"><span class="keyword">class</span> ConcreteBlogObserver : public BlogObserver</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;Blog*, <span class="built_in">string</span>&gt; m_mapBlog_Msg;  <span class="comment">// 保存订阅的Blog及对应的消息</span></span><br><span class="line">    <span class="built_in">string</span> m_BlogObserverName;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteBlogObserver(<span class="params">string</span> <span class="params">name</span>)</span>: m<span class="constructor">_BlogObserverName(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> <span class="constructor">GetName()</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_BlogObserverName;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">Update(Blog <span class="operator">*</span><span class="params">pBlog</span>)</span>  <span class="comment">// 传入某个主题对象的指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[Blog Observer]&quot;</span> &lt;&lt; m_BlogObserverName &lt;&lt; <span class="string">&quot; Update Message: &quot;</span> &lt;&lt; pBlog-&gt;<span class="constructor">GetMsg()</span> &lt;&lt; <span class="string">&quot; From [Blog]&quot;</span> &lt;&lt; pBlog-&gt;<span class="constructor">GetName()</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        map&lt;Blog*, <span class="built_in">string</span>&gt;::iterator it = m_mapBlog_Msg.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span> (;it != m_mapBlog_Msg.<span class="keyword">end</span><span class="literal">()</span>;++it)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((*it).first)-&gt;<span class="constructor">GetName()</span><span class="operator"> == </span>pBlog-&gt;<span class="constructor">GetName()</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                (*it).second = pBlog-&gt;<span class="constructor">GetMsg()</span>; <span class="comment">// 找到了直接替换跟新Msg</span></span><br><span class="line">                return;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到，则插入到map</span></span><br><span class="line">        <span class="keyword">if</span> (it<span class="operator"> == </span>m_mapBlog_Msg.<span class="keyword">end</span><span class="literal">()</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_mapBlog_Msg.insert(make<span class="constructor">_pair(<span class="params">pBlog</span>, <span class="params">pBlog</span>-&gt;GetMsg()</span>));</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[Blog Observer]&quot;</span> &lt;&lt; m_BlogObserverName &lt;&lt; <span class="string">&quot; Add a New &quot;</span> &lt;&lt; <span class="string">&quot;[Blog]&quot;</span> &lt;&lt; pBlog-&gt;<span class="constructor">GetName()</span> &lt;&lt; endl;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">ShowMsg()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\nShow All Blog Message:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (map&lt;Blog*,<span class="built_in">string</span>&gt;::iterator it = m_mapBlog_Msg.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_mapBlog_Msg.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)       <span class="comment">// 显示所有list中的Message</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[Blog Observer]&quot;</span> &lt;&lt; m_BlogObserverName &lt;&lt; <span class="string">&quot; Message: &quot;</span> &lt;&lt; (*it).second &lt;&lt; <span class="string">&quot; From [Blog]&quot;</span> &lt;&lt; ((*it).first)-&gt;<span class="constructor">GetName()</span> &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;   </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试观察者模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">ObserverTest_Blog()</span></span><br><span class="line">&#123;</span><br><span class="line">    Blog *pCsdn_Tly = <span class="keyword">new</span> <span class="constructor">CsdnBlog(<span class="string">&quot;Tly_Bloger&quot;</span>)</span>;</span><br><span class="line">    Blog *pCsdn_Frank = <span class="keyword">new</span> <span class="constructor">CsdnBlog(<span class="string">&quot;Frank Bloger&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    BlogObserver *pBgOb_A = <span class="keyword">new</span> <span class="constructor">ConcreteBlogObserver(<span class="string">&quot;A&quot;</span>)</span>;</span><br><span class="line">    BlogObserver *pBgOb_B = <span class="keyword">new</span> <span class="constructor">ConcreteBlogObserver(<span class="string">&quot;B&quot;</span>)</span>;</span><br><span class="line">    BlogObserver *pBgOb_C = <span class="keyword">new</span> <span class="constructor">ConcreteBlogObserver(<span class="string">&quot;C&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">AttachBlogObserver(<span class="params">pBgOb_A</span>)</span>;</span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">AttachBlogObserver(<span class="params">pBgOb_B</span>)</span>;</span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">AttachBlogObserver(<span class="params">pBgOb_C</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个Blog：Tly Blog发布并通知跟新消息到A，B，C Observer</span></span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">PublishMsg(<span class="string">&quot;I am Tly&quot;</span>)</span>;</span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">Notify()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次显示A,B,C Observer订阅的所有Blog（此时均只有Tly)的信息</span></span><br><span class="line">    pBgOb_A-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_B-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_C-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line"></span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">AttachBlogObserver(<span class="params">pBgOb_A</span>)</span>;</span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">AttachBlogObserver(<span class="params">pBgOb_B</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另外一个Blog：Frank Blog发布并通知跟新消息到A，B Observer</span></span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">PublishMsg(<span class="string">&quot;I am Frank&quot;</span>)</span>;</span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">Notify()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依次显示A,B,C Observer订阅的所有Blog（此时有A,B有Tly、Frank,C只有Tly)的信息</span></span><br><span class="line">    pBgOb_A-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_B-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_C-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A 取消订阅了Tly, Tly 重新发布消息到B,C Observer</span></span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">DetachBlogObserver(<span class="params">pBgOb_A</span>)</span>;</span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">PublishMsg(<span class="string">&quot;I am Tly Two&quot;</span>)</span>;</span><br><span class="line">    pCsdn_Tly-&gt;<span class="constructor">Notify()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次显示A,B,C Observer订阅的所有Blog的信息</span></span><br><span class="line">    pBgOb_A-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_B-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_C-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A 取消订阅了Frank，Frank 重新发布消息到B Observer</span></span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">DetachBlogObserver(<span class="params">pBgOb_A</span>)</span>;</span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">PublishMsg(<span class="string">&quot;I am Frank Two&quot;</span>)</span>;</span><br><span class="line">    pCsdn_Frank-&gt;<span class="constructor">Notify()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次显示A,B,C Observer订阅的所有Blog的信息</span></span><br><span class="line">    pBgOb_A-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_B-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line">    pBgOb_C-&gt;<span class="constructor">ShowMsg()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pBgOb_A</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pBgOb_B</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pBgOb_C</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCsdn_Tly</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCsdn_Frank</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行结果:</p>
<pre><code>[Blog Observer]A Attached To [Blog]Tly_Bloger
[Blog Observer]B Attached To [Blog]Tly_Bloger
[Blog Observer]C Attached To [Blog]Tly_Bloger
Tly_Bloger Send Message: I am Tly
[Blog Observer]A Update Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]A Add a New [Blog]Tly_Bloger
[Blog Observer]B Update Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]B Add a New [Blog]Tly_Bloger
[Blog Observer]C Update Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]C Add a New [Blog]Tly_Bloger
Show All Blog Message:
[Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
Show All Blog Message:
[Blog Observer]B Message: I am Tly From [Blog]Tly_Bloger
Show All Blog Message:
[Blog Observer]C Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]A Attached To [Blog]Frank Bloger
[Blog Observer]B Attached To [Blog]Frank Bloger
Frank Bloger Send Message: I am Frank
[Blog Observer]A Update Message: I am Frank From [Blog]Frank Bloger
[Blog Observer]A Add a New [Blog]Frank Bloger
[Blog Observer]B Update Message: I am Frank From [Blog]Frank Bloger
[Blog Observer]B Add a New [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]A Message: I am Frank From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]B Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]B Message: I am Frank From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]C Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]A Detached From [Blog]Tly_Bloger
Tly_Bloger Send Message: I am Tly Two
[Blog Observer]B Update Message: I am Tly Two From [Blog]Tly_Bloger
[Blog Observer]C Update Message: I am Tly Two From [Blog]Tly_Bloger
Show All Blog Message:
[Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]A Message: I am Frank From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]B Message: I am Tly Two From [Blog]Tly_Bloger
[Blog Observer]B Message: I am Frank From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]C Message: I am Tly Two From [Blog]Tly_Bloger
[Blog Observer]A Detached From [Blog]Frank Bloger
Frank Bloger Send Message: I am Frank Two
[Blog Observer]B Update Message: I am Frank Two From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]A Message: I am Tly From [Blog]Tly_Bloger
[Blog Observer]A Message: I am Frank From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]B Message: I am Tly Two From [Blog]Tly_Bloger
[Blog Observer]B Message: I am Frank Two From [Blog]Frank Bloger
Show All Blog Message:
[Blog Observer]C Message: I am Tly Two From [Blog]Tly_Bloger
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式(行为型)</title>
    <url>/2018/04/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>有时候，我们想用一些简单的语言来实现一些特点的操作，只要向计算机输入一个特定的句子，能够按照预定的文法规则对其进行解释。如一个简单的加减法解释器，只要输入一个加减法表达式，他就能计算出表达式的结果。像这种设计自定义的简单语言文法的功能可以采用解释器模式来实现。</p>
<span id="more"></span>

<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><hr>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子</p>
<blockquote>
<p>解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子<br>在解释器模式中还可以通过一种称之为抽象语法树(AST)的图形方式来直观地表示语言的构成，每一颗抽象语法树对应一个语言实例。通常，终结符表达式类的实例作为树的叶子节点，而非终结符表达式类的实例作为非叶子节点，它们可以将终结符表达式类的实例以及包含终结符和非终结符实例的子表达式作为其子节点<br><strong>非终结符表达式</strong>:它的组成元素仍然可以是表达式，可以进一步分解<br><strong>终结符表达式</strong>:它的组成元素是最基本的语言单位，不能再进行分解</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>AbstractExpression<br>抽象表达式，声明了抽象的解释操作，他是所有终结符表达式和非终结符表达式的公共父类</p>
</li>
<li><p>TerminalExpression<br>抽象表达式的子类，实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例<br>通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子</p>
</li>
<li><p>NonterminalExpression<br>非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作<br>由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成</p>
</li>
<li><p>Context<br>环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句<br>这个角色的任务一般是也用来存放文法中各个终结符所对应的具体值，比如R&#x3D;R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/04/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/Interpreter.jpg" alt="interpreter"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象的表达式<code>AbstractExpression</code>,并提供<code>Interpreter()</code>接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Expression</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">Interpreter</span><span class="params">(Context ctx)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义<code>AbstractExpression</code>类的一个具体终结符表达式子类<code>TerminalExpression</code>，并实现其中的<code>Interpreter()</code>接口，该接口主要作用是返回一个操作数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Terminal Expression</span></span><br><span class="line"><span class="keyword">class</span> TerminalExpression : public AbstractExpression</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">int</span> m_Value;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">TerminalExpression(<span class="params">int</span> <span class="params">value</span>)</span> : m<span class="constructor">_Value(<span class="params">value</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="constructor">Interpreter(Context <span class="params">ctx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.分别在定义两个具体的<code>+</code>和<code>-</code>操作符非终结符表达式类<code>PlusNonterminalExpression</code>和<code>SubNonterminalExpression</code>类，并分别实现其<code>Interpreter()</code>接口，主要通过递归调用来实现：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NonTerminal Expression 2: Plus (&#x27;+&#x27;)</span></span><br><span class="line"><span class="keyword">class</span> PlusNonterminalExpression : public AbstractExpression </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractExpression *m_pLeftExpr;</span><br><span class="line">    AbstractExpression *m_pRightExpr;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">PlusNonterminalExpression(AbstractExpression <span class="operator">*</span><span class="params">pLeft</span>, AbstractExpression <span class="operator">*</span><span class="params">pRight</span>)</span> : m<span class="constructor">_pLeftExpr(<span class="params">pLeft</span>)</span>, m<span class="constructor">_pRightExpr(<span class="params">pRight</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="constructor">Interpreter(Context <span class="params">ctx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_pLeftExpr-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span> + m_pRightExpr-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span>;</span><br><span class="line">        <span class="comment">//调用两个操作数的Interpreter接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NonTerminal Expression 1: Sub (&#x27;-&#x27;)</span></span><br><span class="line"><span class="keyword">class</span> SubNonterminalExpression : public AbstractExpression <span class="comment">// 默认是私有继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractExpression *m_pLeftExpr;</span><br><span class="line">    AbstractExpression *m_pRightExpr;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">SubNonterminalExpression(AbstractExpression <span class="operator">*</span><span class="params">pLeft</span>, AbstractExpression <span class="operator">*</span><span class="params">pRight</span>)</span> : m<span class="constructor">_pLeftExpr(<span class="params">pLeft</span>)</span>, m<span class="constructor">_pRightExpr(<span class="params">pRight</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="constructor">Interpreter(Context <span class="params">ctx</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_pLeftExpr-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span> - m_pRightExpr-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span>; <span class="comment">//调用两个操作数的Interpreter接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.上下文环境类<code>Context</code>,主要是存储解释器之外的一些全局信息：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Context，一般使用map或list实现</span></span><br><span class="line"><span class="keyword">class</span> Context</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt; m_mapValue;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">AddValue(<span class="params">string</span> <span class="params">key</span>, <span class="params">int</span> <span class="params">value</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_mapValue.insert(make<span class="constructor">_pair(<span class="params">key</span>, <span class="params">value</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="constructor">GetValue(<span class="params">string</span> <span class="params">key</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return m_mapValue<span class="literal">[<span class="identifier">key</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.测试解释器模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">InterpreterTest_Computaion()</span></span><br><span class="line">&#123;</span><br><span class="line">    Context ctx;</span><br><span class="line">    ctx.<span class="constructor">AddValue(<span class="string">&quot;x&quot;</span>, 5)</span>;</span><br><span class="line">    ctx.<span class="constructor">AddValue(<span class="string">&quot;y&quot;</span>, 8)</span>;</span><br><span class="line">    ctx.<span class="constructor">AddValue(<span class="string">&quot;z&quot;</span>, 7)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Create Terminal Expression </span></span><br><span class="line">    AbstractExpression *pTE1 = <span class="keyword">new</span> <span class="constructor">TerminalExpression(<span class="params">ctx</span>.GetValue(<span class="string">&quot;x&quot;</span>)</span>);</span><br><span class="line">    AbstractExpression *pTE2 = <span class="keyword">new</span> <span class="constructor">TerminalExpression(<span class="params">ctx</span>.GetValue(<span class="string">&quot;y&quot;</span>)</span>);</span><br><span class="line">    AbstractExpression *pTE3 = <span class="keyword">new</span> <span class="constructor">TerminalExpression(<span class="params">ctx</span>.GetValue(<span class="string">&quot;z&quot;</span>)</span>);</span><br><span class="line"></span><br><span class="line">    AbstractExpression *pPNE = <span class="keyword">new</span> <span class="constructor">PlusNonterminalExpression(<span class="params">pTE1</span>, <span class="params">pTE2</span>)</span>; <span class="comment">//pPNE： PTE1-&gt;Interpreter() + pTE2-&gt;Intepreter()</span></span><br><span class="line">    AbstractExpression *pSNE = <span class="keyword">new</span> <span class="constructor">SubNonterminalExpression(<span class="params">pPNE</span>, <span class="params">pTE3</span>)</span>; <span class="comment">// pSNE： PNE-&gt;Interpreter() - pTE3-&gt;Intepreter()</span></span><br><span class="line">    AbstractExpression *pPNE2 = <span class="keyword">new</span> <span class="constructor">PlusNonterminalExpression(<span class="params">pSNE</span>, <span class="params">pPNE</span>)</span>; <span class="comment">//pPNE2: PSNE-&gt;Interpreter() + pPNE-&gt;Intepreter()</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Final Result of Express : x(5) + y(8) is &quot;</span> &lt;&lt; pPNE-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Final Result of Express : x(5) + y(8) - z(7)  is &quot;</span> &lt;&lt; pSNE-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The Final Result of Express : x(5) + y(8) - z(7) + x(5) + y(8) is &quot;</span> &lt;&lt; pPNE2-&gt;<span class="constructor">Interpreter(<span class="params">ctx</span>)</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pTE1</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pTE2</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pTE3</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pPNE</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSNE</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pPNE2</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行结果：</p>
<pre><code>The Final Result of Express : x(5) + y(8) is 13
The Final Result of Express : x(5) + y(8) - z(7)  is 6
The Final Result of Express : x(5) + y(8) - z(7) + x(5) + y(8) is 19
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>有一个简单的语法规则，比如一个sql语句，如果我们需要根据sql语句进行rm转换，就可以使用解释器模式来对语句进行解释</li>
<li>一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c<em>d，有时是a</em>b+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了</li>
</ul>
</li>
<li>缺点<ul>
<li>解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦</li>
<li>由于采用递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题</li>
</ul>
</li>
</ul>
<h2 id="解释器模式具体实例"><a href="#解释器模式具体实例" class="headerlink" title="解释器模式具体实例"></a>解释器模式具体实例</h2><hr>
<h3 id="机器人控制问题"><a href="#机器人控制问题" class="headerlink" title="机器人控制问题"></a>机器人控制问题</h3><p>该机器人控制程序中包含一些简单的英文控制指令，如”down  run 10 and left move 20”表示快速向下移动10cm，并向左移动20cm,具体文法如下：</p>
<ul>
<li>每一个指令对应一个表达式(expression)，该表达式可以是简单表达式也可以是复合表达式，</li>
<li>每一个简单表达式由方向(direction)，移动方式(action)和移动距离(distance)三部分组成</li>
<li>其中移动方向包括上(up)、下(down)、左(left)、右(right)；</li>
<li>移动方式包括移动(move)和快速移动(run)；</li>
<li>移动距离为一个正整数</li>
<li>两个表达式之间可以通过与(and)连接，形成复合(composite)表达式</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>1.定义抽象的<code>AbstractControlExpression</code>类，并提供<code>interpreter</code>接口:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// abstract expr</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">AbstractControlExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">string</span> <span class="built_in">int</span>erpreter(<span class="built_in">void</span>) = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别定义抽象表达式<code>AbstractControlExpression</code>的终结表达式子类<code>DirectionExpression</code>和<code>ActionExpression</code>及<code>DistanceExpression</code>:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方向终结符表达式：把英文的方向解释为中文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DirectionExpression</span> : <span class="keyword">public</span> <span class="title class_">AbstractControlExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">DirectionExpression</span>(<span class="built_in">string</span> direction) : <span class="title function_">_direction</span>(<span class="params">direction</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">interpreter</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_direction.<span class="title function_">compare</span>(<span class="string">&quot;up&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;向上&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_direction.<span class="title function_">compare</span>(<span class="string">&quot;down&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;向下&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_direction.<span class="title function_">compare</span>(<span class="string">&quot;left&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;向左&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_direction.<span class="title function_">compare</span>(<span class="string">&quot;right&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;向右&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;无效的命令&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _direction;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动作终结符表达式：把英文的动作解释为中文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActionExpression</span> : <span class="keyword">public</span> <span class="title class_">AbstractControlExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">ActionExpression</span>(<span class="built_in">string</span> action) : <span class="title function_">_action</span>(<span class="params">action</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">interpreter</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_action.<span class="title function_">compare</span>(<span class="string">&quot;run&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;快速移动&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_action.<span class="title function_">compare</span>(<span class="string">&quot;move&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;移动&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;无效的命令&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _action;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 距离终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DistanceExpression</span> : <span class="keyword">public</span> <span class="title class_">AbstractControlExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">public</span>:</span><br><span class="line">    <span class="title class_">DistanceExpression</span>(<span class="built_in">string</span> distance) : <span class="title function_">_distance</span>(<span class="params">distance</span>) &#123;&#125;;</span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">interpreter</span>(<span class="params"><span class="built_in">void</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _distance + <span class="string">&quot;厘米&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="attr">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _distance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.分别定义抽象表达式<code>AbstractControlExpression</code>的非终结表达式子类<code>SimpleSentenceExpression</code>和<code>AndSentenceExpression</code>:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单句子非终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">SimpleSentenceExpression</span> : <span class="symbol">public</span> <span class="symbol">AbstractControlExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SimpleSentenceExpression(AbstractControlExpression *direction, AbstractControlExpression *action, AbstractControlExpression *distance):</span><br><span class="line">        _direction(direction), _action(action), _distance(distance) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">int</span>erpreter(<span class="built_in">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (_direction-&gt;<span class="built_in">int</span>erpreter() + _action-&gt;<span class="built_in">int</span>erpreter() + _distance-&gt;<span class="built_in">int</span>erpreter()); <span class="comment">//调用终结符的interpreter</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractControlExpression *_direction;</span><br><span class="line">    AbstractControlExpression *_action;</span><br><span class="line">    AbstractControlExpression *_distance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// And句子非终结符表达式</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">AndSentenceExpression</span> : <span class="symbol">public</span> <span class="symbol">AbstractControlExpression</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AndSentenceExpression(AbstractControlExpression *leftSentence, AbstractControlExpression* rightSentence):</span><br><span class="line">        _leftSentence(leftSentence), _rightSentence(rightSentence) &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> <span class="built_in">int</span>erpreter(<span class="built_in">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (_leftSentence-&gt;<span class="built_in">int</span>erpreter() + <span class="string">&quot;并且&quot;</span> + _rightSentence-&gt;<span class="built_in">int</span>erpreter());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AbstractControlExpression *_leftSentence;</span><br><span class="line">    AbstractControlExpression *_rightSentence;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.测试解释器模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Robot Control Test</span></span><br><span class="line">void <span class="constructor">InterpreterTest_RobotControl(<span class="params">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> finalRes;</span><br><span class="line">    AbstractControlExpression *direction = <span class="keyword">new</span> <span class="constructor">DirectionExpression(<span class="string">&quot;down&quot;</span>)</span>;</span><br><span class="line">    AbstractControlExpression *action = <span class="keyword">new</span> <span class="constructor">ActionExpression(<span class="string">&quot;move&quot;</span>)</span>;</span><br><span class="line">    AbstractControlExpression *distance = <span class="keyword">new</span> <span class="constructor">DistanceExpression(<span class="string">&quot;100&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AbstractControlExpression *simple_sentence = <span class="keyword">new</span> <span class="constructor">SimpleSentenceExpression(<span class="params">direction</span>, <span class="params">action</span>, <span class="params">distance</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AbstractControlExpression *direction2 = <span class="keyword">new</span> <span class="constructor">DirectionExpression(<span class="string">&quot;up&quot;</span>)</span>;</span><br><span class="line">    AbstractControlExpression *action2 = <span class="keyword">new</span> <span class="constructor">ActionExpression(<span class="string">&quot;run&quot;</span>)</span>;</span><br><span class="line">    AbstractControlExpression *simple_sentence2 = <span class="keyword">new</span> <span class="constructor">SimpleSentenceExpression(<span class="params">direction2</span>, <span class="params">action2</span>, <span class="params">distance</span>)</span>;</span><br><span class="line"></span><br><span class="line">    AbstractControlExpression *complex_sentence = <span class="keyword">new</span> <span class="constructor">AndSentenceExpression(<span class="params">simple_sentence</span>, <span class="params">simple_sentence2</span>)</span>;</span><br><span class="line">    finalRes = complex_sentence-&gt;interpreter<span class="literal">()</span>;</span><br><span class="line">    cout &lt;&lt; finalRes &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">direction</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">action</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">distance</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">simple_sentence</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">direction2</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">action2</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">simple_sentence2</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">complex_sentence</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.运行结果:</p>
<pre><code>向上快速移动100厘米并且向下移动100厘米
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式(行为型)</title>
    <url>/2018/03/03/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在大型体育馆中有各种体育项目，如羽毛球室，乒乓球室，篮球室等等，每种运动项目场地里面会有各种职业背景的体育爱好者，如学生，职工，老师；同时对于同一种职业背景的体育爱好者，可以访问多种运动项目。在软件开发中，有时候我们也需要处理像体育馆这样的不同的运动场所集合对象结构，在该对象结构中存储了多个不同类型的对象信息，而且对同一对象结构中的元素的操作方式并不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式等等。对于此类问题可以通过访问者模式来解决，因为其模式动机就是以不同的方式操作复杂对象结构。</p>
<span id="more"></span>

<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><hr>
<p>访问者模式包含<strong>访问者</strong>和<strong>被访问元素</strong>两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作，访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作</p>
<blockquote>
<p>在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为<strong>对象结构</strong>，访问者通过遍历对象结构实现对其中存储的元素的逐个操作</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变个元素的类的前提下定义作用于这些元素的新的操作。访问者模式是一种对象行为型模式</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Visitor<br>抽象访问者，为该对象结构中ConcreteElement的每一个类声明一个visit操作。该操作的名字和特<br>征标识了发送visit请求给该访问者的那个类。这使得访问者可以确定被访问元素的具体的类。这样访问者就可以通过该元素的特定接口直接访问它、</p>
</li>
<li><p>ConcreteVisitor<br>具体访问者，实现每个由Visitor声明的操作。每个操作实现本算法的一部分，而该算法片断乃是<br>对应于结构中对象的类。ConcreteVisitor为该算法提供了上下文并存储它的局部状态。这一状态常常在遍历该结构的过程中累积结果</p>
</li>
<li><p>Element<br>定义一个accept操作，它以一个访问者为参数</p>
</li>
<li><p>ConcreteElement<br>实现accept操作，该操作以一个访问者为参数</p>
</li>
<li><p>ObjectStructure<br>能枚举它的元素<br>可以提供一个高层的接口以允许该访问者访问它的元素<br>可以是一个复合或是一个集合，如一个列表或一个无序集合</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/03/03/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/visitor.png" alt="visitor"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象元素类<code>Element</code>,并声明<code>Accept()</code>方法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pv)</span> </span>= <span class="number">0</span>; <span class="comment">// 该方法传入一个抽象的访问者对象指针</span></span><br><span class="line"><span class="comment">//  virtual void Operation()  = 0; 每个元素各种有自己的操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义两个具体的元素类<code>ConcreteElementA</code>、<code>ConcreteElementB</code>,并实现<code>Accept()</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体数据元素类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementA</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pv-&gt;<span class="built_in">VisitConcreteElementA</span>(<span class="keyword">this</span>); <span class="comment">// 传入this给访问者的访问接口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OperationA</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Element A OperatorA!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体数据元素类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteElementB</span> : <span class="keyword">public</span> Element</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(Visitor *pv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pv-&gt;<span class="built_in">VisitConcreteElementB</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OperationB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Element B OperatorB!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义抽象访问者类<code>Visitor</code>,并定义两个访问两个具体元素的接口<code>VisitConcreteElementA()</code>和<code>VisitConcreteElementB()</code>,每个接口都是以具体的元素为参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Visitor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pea)</span> </span>= <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//以具体的被访问元素为参数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *peb)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//以具体的被访问元素为参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 若各有自己的操作，VisitConcreteElementA和VisitConcreteElementB</span></span><br><span class="line">    <span class="comment">// 可以合并一个函数，但是参数必须是具体的Element,即重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.再定义两个具体的访问者类<code>ConcreteVisitorA</code>和<code>ConcreteVisitorB</code>，并实现<code>VisitConcreteElementA()</code>和<code>VisitConcreteElementB()</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体访问者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorA</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pea)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Visitor A:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pea-&gt;<span class="built_in">OperationA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *peb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Visitor A:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        peb-&gt;<span class="built_in">OperationB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// VisitConcreteElementA 和VisitConcreteElementB可以合并一个函数，</span></span><br><span class="line">    <span class="comment">//但是参数必须是具体的Element,即重载</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体访问者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteVisitorB</span> : <span class="keyword">public</span> Visitor</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementA</span><span class="params">(ConcreteElementA *pea)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Visitor B:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        pea-&gt;<span class="built_in">OperationA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitConcreteElementB</span><span class="params">(ConcreteElementB *peb)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Concrete Visitor B:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        peb-&gt;<span class="built_in">OperationB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.最后定义对象结构<code>ObjectStructure</code>作为元素的集合，并提供元素增删接口和统一的高层<code>Accept()</code>接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ObjectStructure</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">list</span>&lt;Element*&gt; m_ListElement;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">Attach(Element <span class="operator">*</span><span class="params">pe</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_ListElement.push<span class="constructor">_back(<span class="params">pe</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="constructor">Detach(Element <span class="operator">*</span><span class="params">pe</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>&lt;Element*&gt; ::iterator it = find(m_ListElement.<span class="keyword">begin</span><span class="literal">()</span>, m_ListElement.<span class="keyword">end</span><span class="literal">()</span>, pe);</span><br><span class="line">        <span class="keyword">if</span> (it != m_ListElement.<span class="keyword">end</span><span class="literal">()</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_ListElement.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void <span class="constructor">Accept(Visitor <span class="operator">*</span><span class="params">pv</span>)</span> <span class="comment">// 高层各个元素统一的Accept接口</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">list</span>&lt;Element*&gt; ::iterator it = m_ListElement.<span class="keyword">begin</span><span class="literal">()</span>;</span><br><span class="line">             it != m_ListElement.<span class="keyword">end</span><span class="literal">()</span>;</span><br><span class="line">             ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            (*it)-&gt;<span class="constructor">Accept(<span class="params">pv</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6.测试访问者模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">VisitorTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    ObjectStructure *pOS = <span class="keyword">new</span> <span class="constructor">ObjectStructure()</span>;</span><br><span class="line"></span><br><span class="line">    Element *pEA = <span class="keyword">new</span> <span class="constructor">ConcreteElementA()</span>;</span><br><span class="line">    Element *pEB = <span class="keyword">new</span> <span class="constructor">ConcreteElementB()</span>;</span><br><span class="line"></span><br><span class="line">    pOS-&gt;<span class="constructor">Attach(<span class="params">pEA</span>)</span>;</span><br><span class="line">    pOS-&gt;<span class="constructor">Attach(<span class="params">pEB</span>)</span>;</span><br><span class="line"></span><br><span class="line">    Visitor *pVA = <span class="keyword">new</span> <span class="constructor">ConcreteVisitorA()</span>;</span><br><span class="line">    Visitor *pVB = <span class="keyword">new</span> <span class="constructor">ConcreteVisitorB()</span>;</span><br><span class="line"></span><br><span class="line">    pOS-&gt;<span class="constructor">Accept(<span class="params">pVA</span>)</span>;</span><br><span class="line">    pOS-&gt;<span class="constructor">Accept(<span class="params">pVB</span>)</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Detach ConcretElement A:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pOS-&gt;<span class="constructor">Detach(<span class="params">pEA</span>)</span>;</span><br><span class="line">    pOS-&gt;<span class="constructor">Accept(<span class="params">pVA</span>)</span>;</span><br><span class="line">    pOS-&gt;<span class="constructor">Accept(<span class="params">pVB</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pOS-&gt;<span class="constructor">Detach(<span class="params">pEB</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pOS</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pEA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pEB</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pVA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pVB</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.运行结果：</p>
<pre><code>Concrete Visitor A:
Concrete Element A OperatorA!!!
Concrete Visitor A:
Concrete Element B OperatorB!!!
Concrete Visitor B:
Concrete Element A OperatorA!!!
Concrete Visitor B:
Concrete Element B OperatorB!!!
After Detach ConcretElement A:
Concrete Visitor A:
Concrete Element B OperatorB!!!
Concrete Visitor B:
Concrete Element B OperatorB!!!
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor模式使得你可以将相关的操作集中起来 定义在一个类中</li>
<li>当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作</li>
<li>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展</li>
<li>扩展性良好：元素类可以通过接受不同的访问者来实现对不同操作的扩展</li>
<li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问</li>
</ul>
</li>
<li>缺点<ul>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求</li>
<li>破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问</li>
</ul>
</li>
</ul>
<h2 id="访问者方法模式具体实例"><a href="#访问者方法模式具体实例" class="headerlink" title="访问者方法模式具体实例"></a>访问者方法模式具体实例</h2><hr>
<h3 id="体育馆访问问题"><a href="#体育馆访问问题" class="headerlink" title="体育馆访问问题"></a>体育馆访问问题</h3><p><strong>使用访问者方法模式简单实现前言所述的体育馆访问问题</strong></p>
<p><strong>代码实现</strong><br>1.定义抽象元素类<code>Stadium</code>，并声明接受访问方法<code>Accept()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Stadium</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Accept</span>(<span class="params">SportsLover *pSL</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DoSports</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.定义三个种具体的元素类<code>BadmintonStadium</code>和<code>PingpongStadium</code>及<code>BascketballStadium</code>，并实现接受访问方法<code>Accept()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BadmintonStadium</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BadmintonStadium</span> : <span class="keyword">public</span> Stadium</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(SportsLover *pSL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pSL-&gt;<span class="built_in">VisitBadmintonStadium</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//// 重载版</span></span><br><span class="line">        <span class="comment">//pSL-&gt;Visit(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoSports</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Doing Badminton Sport&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PingpongStadium</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PingpongStadium</span> : <span class="keyword">public</span> Stadium</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(SportsLover *pSL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pSL-&gt;<span class="built_in">VisitPingpongStadium</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//// 重载版</span></span><br><span class="line">        <span class="comment">//pSL-&gt;Visit(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoSports</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Doing Ping Pong Sport&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BascketballStadium</span> : <span class="keyword">public</span> Stadium</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Accept</span><span class="params">(SportsLover *pSL)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pSL-&gt;<span class="built_in">VisitBasketballStadium</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//// 重载版</span></span><br><span class="line">        <span class="comment">//pSL-&gt;Visit(this);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DoSports</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Doing Bascket ball Sport&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义抽象的访问者类<code>SportsLover</code>，并声明访问具体元素的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Visitor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SportsLover</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitBadmintonStadium</span><span class="params">(BadmintonStadium *pS)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitPingpongStadium</span><span class="params">(PingpongStadium *pS)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VisitBasketballStadium</span><span class="params">(BascketballStadium *pS)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//// 重载版</span></span><br><span class="line">    <span class="comment">//virtual void Visit(BadmintonStadium *pS) = 0;</span></span><br><span class="line">    <span class="comment">//virtual void Visit(PingpongStadium *pS) = 0;</span></span><br><span class="line">    <span class="comment">//virtual void Visit(BascketballStadium *pS) = 0;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.定义两个具体的访问者类<code>Students</code>和<code>Teachers</code>，并实现相应的访问方法：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> Stduent Visitor</span><br><span class="line">class Students : public SportsLover</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual void VisitBadmintonStadium(BadmintonStadium *pS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;students visit: &quot;</span>;</span><br><span class="line">        pS-&gt;DoSports();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void VisitPingpongStadium(PingpongStadium *pS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;students visit: &quot;</span>;</span><br><span class="line">        pS-&gt;DoSports();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void VisitBasketballStadium(BascketballStadium *pS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;students visit: &quot;</span>;</span><br><span class="line">        pS-&gt;DoSports();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span><span class="regexp">//</span> 重载版</span><br><span class="line">    <span class="regexp">//</span>virtual void Visit(BadmintonStadium *pS)</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  cout &lt;&lt; <span class="string">&quot;students visit: &quot;</span>;</span><br><span class="line">    <span class="regexp">//</span>  pS-&gt;DoSports();</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line">    <span class="regexp">//</span>virtual void Visit(PingpongStadium *pS)</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  cout &lt;&lt; <span class="string">&quot;students visit: &quot;</span>;</span><br><span class="line">    <span class="regexp">//</span>  pS-&gt;DoSports();</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line">    <span class="regexp">//</span>virtual void Visit(BascketballStadium *pS)</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  cout &lt;&lt; <span class="string">&quot;students visit: &quot;</span>;</span><br><span class="line">    <span class="regexp">//</span>  pS-&gt;DoSports();</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> Teachers Visitor</span><br><span class="line">class Teachers : public SportsLover</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    virtual void VisitBadmintonStadium(BadmintonStadium *pS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;teachers visit: &quot;</span>;</span><br><span class="line">        pS-&gt;DoSports();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void VisitPingpongStadium(PingpongStadium *pS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;teachers visit: &quot;</span>;</span><br><span class="line">        pS-&gt;DoSports();</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void VisitBasketballStadium(BascketballStadium *pS)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;teachers visit: &quot;</span>;</span><br><span class="line">        pS-&gt;DoSports();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="regexp">//</span><span class="regexp">//</span> 重载版</span><br><span class="line">    <span class="regexp">//</span>virtual void Visit(BadmintonStadium *pS)</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  cout &lt;&lt; <span class="string">&quot;teachers visit: &quot;</span>;</span><br><span class="line">    <span class="regexp">//</span>  pS-&gt;DoSports();</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line">    <span class="regexp">//</span>virtual void Visit(PingpongStadium *pS)</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  cout &lt;&lt; <span class="string">&quot;teachers visit: &quot;</span>;</span><br><span class="line">    <span class="regexp">//</span>  pS-&gt;DoSports();</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line">    <span class="regexp">//</span>virtual void Visit(BascketballStadium *pS)</span><br><span class="line">    <span class="regexp">//</span>&#123;</span><br><span class="line">    <span class="regexp">//</span>  cout &lt;&lt; <span class="string">&quot;teachers visit: &quot;</span>;</span><br><span class="line">    <span class="regexp">//</span>  pS-&gt;DoSports();</span><br><span class="line">    <span class="regexp">//</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>5.定义对象结构<code>StadiumContainer</code>,并声明和实现增删元素的接口及统一的高层<code>Accept()</code>接口：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">StadiumContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">private:</span></span><br><span class="line"><span class="class">    vector&lt;<span class="type">Stadium</span>*&gt; m_VectorStadium;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    void <span class="type">Attach</span>(<span class="type">Stadium</span> *<span class="title">ps</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        m_VectorStadium.push_back(<span class="title">ps</span>);</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    void <span class="type">Detach</span>(<span class="type">Stadium</span> *<span class="title">ps</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        vector&lt;<span class="type">Stadium</span>*&gt; :: iterator it  = find(<span class="title">m_VectorStadium</span>.<span class="title">begin</span>(), m_VectorStadium.end(), ps);</span></span><br><span class="line"><span class="class">        if (<span class="title">it</span> != <span class="title">m_VectorStadium</span>.<span class="title">end</span>())</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line"><span class="class">            m_VectorStadium.erase(<span class="title">it</span>);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    void <span class="type">Accept</span>(<span class="type">SportsLover</span> *<span class="title">pSL</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        for (<span class="title">vector</span>&lt;<span class="type">Stadium</span>*&gt; :: <span class="title">iterator</span> <span class="title">it</span>  = <span class="title">m_VectorStadium</span>.<span class="title">begin</span>();</span></span><br><span class="line"><span class="class">             it != m_VectorStadium.end();</span></span><br><span class="line"><span class="class">             ++it)</span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line"><span class="class">            (*<span class="title">it</span>)-&gt;<span class="type">Accept</span>(<span class="title">pSL</span>);</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>6.测试访问者模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">VisitorTest_Sports()</span></span><br><span class="line">&#123;</span><br><span class="line">    StadiumContainer *pSC = <span class="keyword">new</span> <span class="constructor">StadiumContainer()</span>;</span><br><span class="line"></span><br><span class="line">    BadmintonStadium   *pBS = <span class="keyword">new</span> <span class="constructor">BadmintonStadium()</span>;</span><br><span class="line">    PingpongStadium    *pPS = <span class="keyword">new</span> <span class="constructor">PingpongStadium()</span>;</span><br><span class="line">    BascketballStadium *pBkS = <span class="keyword">new</span> <span class="constructor">BascketballStadium()</span>;</span><br><span class="line"></span><br><span class="line">    pSC-&gt;<span class="constructor">Attach(<span class="params">pBS</span>)</span>;</span><br><span class="line">    pSC-&gt;<span class="constructor">Attach(<span class="params">pPS</span>)</span>;</span><br><span class="line">    pSC-&gt;<span class="constructor">Attach(<span class="params">pBkS</span>)</span>;</span><br><span class="line"></span><br><span class="line">    SportsLover  *pSS = <span class="keyword">new</span> <span class="constructor">Students()</span>;</span><br><span class="line">    SportsLover  *pST = <span class="keyword">new</span> <span class="constructor">Teachers()</span>;</span><br><span class="line"></span><br><span class="line">    pSC-&gt;<span class="constructor">Accept(<span class="params">pSS</span>)</span>;</span><br><span class="line">    pSC-&gt;<span class="constructor">Accept(<span class="params">pST</span>)</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Detach Ping Pong Stadium !!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    pSC-&gt;<span class="constructor">Detach(<span class="params">pPS</span>)</span>;</span><br><span class="line"></span><br><span class="line">    pSC-&gt;<span class="constructor">Accept(<span class="params">pSS</span>)</span>;</span><br><span class="line">    pSC-&gt;<span class="constructor">Accept(<span class="params">pST</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSC</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pBS</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pBkS</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pPS</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pSS</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pST</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.运行结果:</p>
<pre><code>students visit: Doing Badminton Sport
students visit: Doing Ping Pong Sport
students visit: Doing Bascket ball Sport
teachers visit: Doing Badminton Sport
teachers visit: Doing Ping Pong Sport
teachers visit: Doing Bascket ball Sport
Detach Ping Pong Stadium !!!
students visit: Doing Badminton Sport
students visit: Doing Bascket ball Sport
teachers visit: Doing Badminton Sport
teachers visit: Doing Bascket ball Sport
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式概述</title>
    <url>/2017/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><hr>
<ol>
<li>单一职责原则(SRO)<br> <strong>每个类应该专注于做一件事情</strong><br> 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则<span id="more"></span></li>
<li>里氏替换原则(LSP)<br> <strong>超类存在的地方，子类是可以替换的</strong><br> 子类必须实现父类中声明的所有方法，即基类对象替换为子类对象，程序将不会产生任何错误和异常，反之则不成立；使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现</li>
<li>依赖倒置原则(DIP)<br> <strong>实现尽量依赖抽象(接口)编程，而不是面对实现编程</strong><br> 具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖</li>
<li>接口隔离原则(ISP)<br> <strong>提供尽可能小的单独接口，而不要提供大的总接口</strong><br> 也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性</li>
<li>迪米特法则(LOD)<br> <strong>又叫最少知识原则，即一个软件实体应当尽可能少的与其他实体发生相互作用</strong><br> 对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部；在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用</li>
<li>开闭原则(OCP)<br> <strong>对扩展开放、对修改封闭</strong><br> 意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。<strong>封装变化</strong>是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象</li>
<li>组合聚合复用原则(CARP)<br> <strong>尽量使用合成&#x2F;聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象</strong><br> 在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。组合&#x2F;聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合&#x2F;聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用</li>
</ol>
<h2 id="设计模式概念"><a href="#设计模式概念" class="headerlink" title="设计模式概念"></a>设计模式概念</h2><hr>
<h3 id="模式要义"><a href="#模式要义" class="headerlink" title="模式要义"></a>模式要义</h3><ol>
<li><strong>每个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复的劳动</strong></li>
<li><strong>对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述</strong></li>
<li><strong>一个设计模式命名、抽象和确定了一个通用设计结构的主要方面，这些设计结构能被用来构造可复用的面向对象设计。设计模式确定了所包含的类和实例，它们的角色、协作方式以及职责分配。每一个设计模式都集中于一个特定的面向对象设计问题或设计要点，描述了什么时候使用它，在另一些设计约束条件下是否还能使用，以及使用的效果和如何取舍</strong></li>
</ol>
<h3 id="模式要素"><a href="#模式要素" class="headerlink" title="模式要素"></a>模式要素</h3><ol>
<li>模式名称(pattern name)<br> <strong>助记词，基于模式词汇表</strong><br> 在交流和讨论模式和编写文档时候用该词语</li>
<li>问题(problem)<br> <strong>描述应该再何时使用模式，解释了设计问题和问题存在的前因后果</strong><br> 可能描述了特定的设计问题，也可能描述了导致不灵活设计的类或对象结构。有时候会包括使用模式必须满足的一系列先决条件</li>
<li>解决方案(solution)<br> <strong>描述了设计的组成部分，它们之间的相互关系及各自的职责和协作方式</strong><br> 提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合(类或对象组合)来解决这个问题</li>
<li>效果(consequences)<br> <strong>描述了模式应用的效果及使用模式赢权衡的问题</strong><br> 软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响</li>
</ol>
<h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><hr>
<h3 id="模式分类准则"><a href="#模式分类准则" class="headerlink" title="模式分类准则"></a>模式分类准则</h3><ol>
<li>目的准则<br>即模式是用来完成什么工作的。模式依据其目的可分为<strong>创建型、结构型、或行为型</strong>三种<br><strong>创建型模式</strong>与对象的创建有关；<br><strong>结构型模式</strong>处理类或对象的组合；<br><strong>行为型模式</strong>对类或对象怎样交互和怎样分配职责进行描述。</li>
<li>范围准则<br> 指定模式主要是用于类还是用于对象，分为<strong>类模式、对象模式</strong><br> <strong>类模式</strong>处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了；<br> <strong>对象模式</strong>处理对象间的关系，这些关系在运行时刻是可以变化的，更具动态性；<br> 从某种意义上来说，几乎所有模式都使用继承机制，所以<strong>类模式</strong>只指那些集中于处理类间关系的模式，而大部分模式都属于<strong>对象模式</strong>的范畴</li>
</ol>
<h3 id="模式分类结果"><a href="#模式分类结果" class="headerlink" title="模式分类结果"></a>模式分类结果</h3><p><img src="http://www.taolingyang.com/2017/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/dp-categories.png" alt="dp-categories"></p>
<h3 id="模式分类分析"><a href="#模式分类分析" class="headerlink" title="模式分类分析"></a>模式分类分析</h3><ol>
<li>创建型类模式将对象的部分创建工作延迟到子类，而创建型对象模式则将它延迟到另一个对象中</li>
<li>结构型类模式使用继承机制来组合类，而结构型对象模式则描述了对象的组装方式</li>
<li>行为型类模式使用继承描述算法和控制流，而行为型对象模式则描述一组对象怎样协作<br>完成单个对象所无法完成的任务</li>
</ol>
<h3 id="模式其他分类"><a href="#模式其他分类" class="headerlink" title="模式其他分类"></a>模式其他分类</h3><p>还有其他组织模式的方式。有些模式经常会被绑在一起使用，例如,Composite常和Iterator或Visitor起使用；<br>有些模式是可替代的，例如,Prototype常用来替代Abstract Factory；<br>有些模式尽管使用意图不同，但产生的设计结果是很相似的，例如，Composite和Decorator的结构图是相似的；<br>还有一种方式是根据模式所描述的它们怎样互相引用来组织设计模式。模式关系如下图示：<br><img src="http://www.taolingyang.com/2017/09/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/dp-relations.png" alt="dp-relations"></p>
<h2 id="设计模式解决设计问题的方法"><a href="#设计模式解决设计问题的方法" class="headerlink" title="设计模式解决设计问题的方法"></a>设计模式解决设计问题的方法</h2><hr>
<p>设计模式采用多种方法来解决面向对象设计遇到的问题：</p>
<ol>
<li><p><strong>寻找合适的对象</strong></p>
<blockquote>
<p>设计模式帮助确定并不明显的抽象和描述这些抽象的对象;设计的许多对象来源于现实世界的分析模型。但是，设计结果所得到的类通常在现实世<br> 界中并不存在，</p>
</blockquote>
</li>
<li><p><strong>决定对象的粒度</strong></p>
<blockquote>
<p>设计模式能帮助怎样用对象表示完整的子系统(Facade),描述了如何支持大量的最小粒度的对象(Flyweight),其他一些模式描述了将一个对象分解成许多小对象的特定方法</p>
</blockquote>
</li>
<li><p><strong>指定对象的接口</strong></p>
<blockquote>
<p>设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口;<br> 例如Memento模式规定了Memento对象必须定义两个接口：一个允许客户保持和复制Memento的限制接口，和一个只有原对象才能使用的用来储存和提取Memento中状态的特权接口<br>设计模式也指定了接口之间的关系，经常要求一些类具有相似的接口或它们对一些类的接口做了限制<br> 例如，Decorator和Proxy模式要求Decorator和Proxy对象的接口与被修饰的对象和受委托的对象一致</p>
</blockquote>
</li>
<li><p><strong>描述对象的实现</strong></p>
<blockquote>
<p>类继承和接口继承(C++纯虚函数)；类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和表示的共享机制。然而，接口继承描述了一个对象什么时候能被用来替代另一个对象<br>针对接口编程，而不是针对实现编程；不将变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口</p>
</blockquote>
</li>
<li><p><strong>运用复用机制</strong></p>
<blockquote>
<p>优先使用<strong>组合</strong>(黑箱)而不是继承(白箱)<br><strong>委托</strong>(delegation)是一种组合方法，它使组合具有与继承同样的复用能力。在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者这类似于子类将请求交给它的父类处理<br> 主要优点在于它便于运行时刻组合对象操作以及改变这些操作的组合方式，委托是对象组合的特例。它告诉你对象组合作为一个代码复用机制可以替代继承<br><strong>参数化类型</strong>给我们提供除了类继承和对象组合外的第三种方法来组合面向对象系统中的<br> 行为(C++模板)</p>
</blockquote>
</li>
<li><p><strong>关联运行时刻和编译时刻的结构</strong></p>
<blockquote>
<p>一个面向对象程序运行时刻的结构通常与它的代码结构相差较大。代码结构在编译时刻<br> 就被确定下来了，它由继承关系固定的类组成。而程序的运行时刻结构是由快速变化的通信<br> 对象网络组成，两个结构是彼此独立的</p>
</blockquote>
</li>
<li><p><strong>设计应该支持变化</strong></p>
<blockquote>
<p>设计模式可以确保系统能以特定方式变化，从而帮助你避免重新设计系统。每一个设计模式<strong>允许系统结构的某个方面的变化独立于其他方面</strong>，这样产生的系统对于某一种特殊变化将更健壮<br>导致重新设计原因可以有：</p>
<ol>
<li>通过显式地指定一个类来创建对象: Abstract Factory, Factory Method, Prototype</li>
<li>对特殊操作的依赖： Chain of Resposibility,Command</li>
<li>对硬件和软件平台的依赖： Abstract Factory, Bridge</li>
<li>对对象表示或实现的依赖： Abstract Factory, Bridge, Memento, Proxy</li>
<li>算法依赖： Builder, Iterator, Strategy, Template Method, Visitor</li>
<li>紧耦合： Abstract Factory, Command, Facade, Mediator, Observer, Chain of  Resposibility</li>
<li>通过生成子类来扩充功能： Bridge, Chain of Resposibility, Composite, Decorator, Observer, Strategy</li>
<li>不能方便地对类进行修改： Adapter, Decorator, Visitor</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="设计模式的选择"><a href="#设计模式的选择" class="headerlink" title="设计模式的选择"></a>设计模式的选择</h2><hr>
<ol>
<li><strong>模式怎样解决设计问题的</strong></li>
<li><strong>模式的意图和目的</strong></li>
<li><strong>模式之间的关联</strong></li>
<li><strong>相似目的模式的异同点</strong></li>
<li><strong>重新设计的原因</strong></li>
<li><strong>设计的可变点</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="center">目的</th>
<th align="center">设计模式</th>
<th align="center">可变点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">创建</td>
<td align="center">Abstract Factory</td>
<td align="center">产品对象家族</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center">Builder</td>
<td align="center">如何创建一个组合对象</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center">Factory Method</td>
<td align="center">被实例化的子类</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center">Prototype</td>
<td align="center">被实例化的类</td>
</tr>
<tr>
<td align="center">创建</td>
<td align="center">Singleton</td>
<td align="center">一个类的唯一实例</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Adapter</td>
<td align="center">对象的接口</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Bridge</td>
<td align="center">对象的实现</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Composite</td>
<td align="center">一个对象的结构和组成</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Decorator</td>
<td align="center">对象的职责，不生成子类</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Facade</td>
<td align="center">一个子系统的接口</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Flyweight</td>
<td align="center">对象的存储开销</td>
</tr>
<tr>
<td align="center">结构</td>
<td align="center">Proxy</td>
<td align="center">如何访问一个对象； 该对象的位置</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Chain of Responsibility</td>
<td align="center">满足一个请求的对象</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Command</td>
<td align="center">何时、怎样满足一个请求</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Interpreter</td>
<td align="center">一个语言的文法及解释</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Iterator</td>
<td align="center">如何遍历、访问一个聚合的各个元素</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Mediator</td>
<td align="center">对象的怎样交互、和谁交互</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Memento</td>
<td align="center">一个对象哪些信息存放在对象之外即存储时机</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Observer</td>
<td align="center">多个对象依赖另外一个对象，而这些对象如何保持一致</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">State</td>
<td align="center">对象的状态</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Strategy</td>
<td align="center">算法</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Template Method</td>
<td align="center">算法中的某些步骤</td>
</tr>
<tr>
<td align="center">行为</td>
<td align="center">Visitor</td>
<td align="center">某些作用于一个或一组对象上的操作但不修改这些对象的类</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式(行为型)</title>
    <url>/2018/02/15/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在公司请年假的时候，需要首先在TMS系统提出申请，在提出申请的时候，发现申请不同的时间长短，审批的领导不一样，如不超过但是包括1天由科长(Section Chief)审批，超过1天但是不超过3天由部长(Minister)审批，超过3天以上由主任(Director)审批。在这个审批流程中，我们的年假请求沿着一条链在传递，每个请求处理者都根据请求的具体情况在自己的处理范围内进行审批，有一种专门用于处理这种请求链式传递的模式，它就是本章将要介绍的职责链模式。</p>
<span id="more"></span>

<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><hr>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>
<blockquote>
<p>常用的对象行为型设计模式之一，职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Handler<br>抽象处理者，定义了一个处理请求的接口，不同的具体处理者处理请求的实现不同<br>一般还包含一个抽象处理者的对象，作为其下家的引用。通过该引用，处理者可以连成一条链</p>
</li>
<li><p>ConcreteHandler<br>具体处理者，抽象处理者的子类，处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法<br>处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者(具体处理者中可以访问链中下一个对象，以便请求的转发)<br>具体处理者有两大作用：处理请求 &amp; 转发请求</p>
</li>
<li><p>Client<br>客户端，负责创建职责链，向链上的具体处理者(ConcreteHandler)对象提交请求</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/02/15/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/Response.jpg" alt="chainofresponsibility"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象的<code>Handler</code>,并提供<code>HandlerRequest()</code>接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Handler</span></span><br><span class="line"><span class="keyword">class</span> Handler</span><br><span class="line">&#123;</span><br><span class="line">protected: <span class="comment">// protected,子类继承能访问和使用</span></span><br><span class="line">    Handler *m_pHandler; <span class="comment">// 请求的下个抽象处理者</span></span><br><span class="line">    <span class="built_in">int</span>     m_nState; <span class="comment">// 请求的参数</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Handler(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : m<span class="constructor">_pHandler(<span class="params">pHandler</span>)</span> &#123;&#125;; </span><br><span class="line">    <span class="comment">//在构造函数中传入下一个处理者</span></span><br><span class="line">    <span class="comment">//也可以通过提供一个setHandler方法，传入Handler，动态设置传入下一个处理者</span></span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再分别定义<code>Handler</code>类的三个具体处理子类，并实现其中的<code>HandlerRequest()</code>接口，该接口主要作用是处理该请求或转发请求给下个处理者：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define  <span class="constructor">NULL_POINTER(<span class="params">ptr</span>)</span> (NULL<span class="operator"> == </span>ptr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Handler A</span></span><br><span class="line"><span class="keyword">class</span> ConcreteHandlerA : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteHandlerA(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : <span class="constructor">Handler(<span class="params">pHandler</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nState &lt; <span class="number">10</span>)    <span class="comment">// 权限范围内，处理该请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete Handler A Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;10 的情况下一个ConcreteHandler处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pHandler</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Handler Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pHandler-&gt;<span class="constructor">HandlerRequest(<span class="params">nState</span>)</span>;  <span class="comment">// 权限范围外，转发该请求让下一个处理者m_pHandler处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Handler B</span></span><br><span class="line"><span class="keyword">class</span> ConcreteHandlerB : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteHandlerB(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : <span class="constructor">Handler(<span class="params">pHandler</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nState &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete Handler B Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;20 的情况下一个ConcreteHandler处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pHandler</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Handler Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pHandler-&gt;<span class="constructor">HandlerRequest(<span class="params">nState</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Handler C</span></span><br><span class="line"><span class="keyword">class</span> ConcreteHandlerC : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteHandlerC(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : <span class="constructor">Handler(<span class="params">pHandler</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nState &lt; <span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete Handler C Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;30 的情况下一个ConcreteHandler处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pHandler</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Handler Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pHandler-&gt;<span class="constructor">HandlerRequest(<span class="params">nState</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试责任链模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define  <span class="constructor">SAFE_RELASE_POINTER(<span class="params">ptr</span>)</span> <span class="keyword">if</span>(!<span class="constructor">NULL_POINTER(<span class="params">ptr</span>)</span>) &#123;delete ptr; ptr = NULL;&#125;</span><br><span class="line"></span><br><span class="line">void <span class="constructor">ResponseTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    Handler *pCHC = <span class="keyword">new</span> <span class="constructor">ConcreteHandlerC(NULL)</span>;</span><br><span class="line">    Handler *pCHB = <span class="keyword">new</span> <span class="constructor">ConcreteHandlerB(<span class="params">pCHC</span>)</span>;</span><br><span class="line">    Handler *pCHA = <span class="keyword">new</span> <span class="constructor">ConcreteHandlerA(<span class="params">pCHB</span>)</span>; </span><br><span class="line">    <span class="comment">//在构造函数的参数内指明每一个Handler的下一个Handler </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Concrete Handler A 开始往下处理</span></span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(5)</span>;</span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(15)</span>;</span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(25)</span>;</span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(35)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCHA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCHB</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCHC</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果：</p>
<pre><code>Concrete Handler A Do The Request !!!State: 5
Concrete Handler B Do The Request !!!State: 15
Concrete Handler C Do The Request !!!State: 25
No Handler Do The Request !!!State: 35
</code></pre>
<h3 id="责任链模式的分类"><a href="#责任链模式的分类" class="headerlink" title="责任链模式的分类"></a>责任链模式的分类</h3><p>责任链模式根据请求是否能同时被多个处理对象处理或者请求是否能最终不被任何请求者处理，分为以下两类：</p>
<h4 id="纯的责任链模式"><a href="#纯的责任链模式" class="headerlink" title="纯的责任链模式"></a>纯的责任链模式</h4><ul>
<li>一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况</li>
<li>要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li>
</ul>
<h4 id="不纯的职责链模式"><a href="#不纯的职责链模式" class="headerlink" title="不纯的职责链模式"></a>不纯的职责链模式</h4><ul>
<li>一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li>
<li>而且一个请求可以最终不被任何处理者对象所接收</li>
</ul>
<blockquote>
<p>事件浮升(Event Bubbling)机制：在GUI组件的事件处理机制中,当事件发生在某一个组件时候,先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。<br>在这种场景中，每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度</li>
<li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接</li>
<li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责</li>
</ul>
</li>
<li>缺点<ul>
<li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环</li>
<li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理</li>
</ul>
</li>
</ul>
<h2 id="责任链模式具体实例"><a href="#责任链模式具体实例" class="headerlink" title="责任链模式具体实例"></a>责任链模式具体实例</h2><hr>
<h3 id="请假审批问题"><a href="#请假审批问题" class="headerlink" title="请假审批问题"></a>请假审批问题</h3><p><strong>使用责任链模式简单实现前言所述的请假审批过程</strong></p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p>1.定义抽象的<code>HoliadyHandler</code>类，并提供<code>HandleHolidayRequest</code>接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Request Class to represent request content</span></span><br><span class="line"><span class="keyword">class</span> HolidayRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _type;</span><br><span class="line">    <span class="built_in">int</span>    _days;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">HolidayRequest(<span class="params">string</span> <span class="params">type</span>, <span class="params">int</span> <span class="params">days</span>)</span> : <span class="constructor">_type(<span class="params">type</span>)</span>, <span class="constructor">_days(<span class="params">days</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> get<span class="constructor">Type(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Days(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Handler</span></span><br><span class="line"><span class="keyword">class</span> HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    HoliadyHandler *_handler;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">HoliadyHandler()</span> : <span class="constructor">_handler(NULL)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 通过set方法来设置下一个处理者，供client调用</span></span><br><span class="line">    void set<span class="constructor">Handler(HoliadyHandler <span class="operator">*</span><span class="params">handler</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        _handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别定义处理者<code>HolidayRequest</code>的子类<code>SectionChief</code>和<code>Minister</code>及<code>Director</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sectin Chief Handler</span></span><br><span class="line"><span class="keyword">class</span> SectionChief : public HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">SectionChief(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.get<span class="constructor">Days()</span> &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Section chief &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; approve your &quot;</span> &lt;&lt; request.get<span class="constructor">Days()</span> &lt;&lt; <span class="string">&quot; days for &quot;</span> &lt;&lt; request.get<span class="constructor">Type()</span> &lt;&lt; <span class="string">&quot; request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">_handler</span>)</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No holiday handler is assigned !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _handler-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Minister Handler</span></span><br><span class="line"><span class="keyword">class</span> Minister : public HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Minister(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.get<span class="constructor">Days()</span> &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Minister &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; approve your &quot;</span> &lt;&lt; request.get<span class="constructor">Days()</span> &lt;&lt; <span class="string">&quot; days for &quot;</span> &lt;&lt; request.get<span class="constructor">Type()</span> &lt;&lt; <span class="string">&quot; request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">_handler</span>)</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No holiday handler is assigned !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _handler-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Director Handler</span></span><br><span class="line"><span class="keyword">class</span> Director : public HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Director(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.get<span class="constructor">Days()</span> &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Director &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; approve your &quot;</span> &lt;&lt; request.get<span class="constructor">Days()</span> &lt;&lt; <span class="string">&quot; days for &quot;</span> &lt;&lt; request.get<span class="constructor">Type()</span> &lt;&lt;  <span class="string">&quot; request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">_handler</span>)</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No holiday handler is assigned !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _handler-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试责任链模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">ResponseTest_Holiday()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 请求处理者</span></span><br><span class="line">    HoliadyHandler *pD = <span class="keyword">new</span> <span class="constructor">Director(<span class="string">&quot;john&quot;</span>)</span>;</span><br><span class="line">    HoliadyHandler *pM = <span class="keyword">new</span> <span class="constructor">Minister(<span class="string">&quot;bob&quot;</span>)</span>;</span><br><span class="line">    HoliadyHandler *pS = <span class="keyword">new</span> <span class="constructor">SectionChief(<span class="string">&quot;bill&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置责任链</span></span><br><span class="line">    pS-&gt;set<span class="constructor">Handler(<span class="params">pM</span>)</span>;</span><br><span class="line">    pM-&gt;set<span class="constructor">Handler(<span class="params">pD</span>)</span>;</span><br><span class="line">    pD-&gt;set<span class="constructor">Handler(NULL)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求</span></span><br><span class="line">    HolidayRequest request1(<span class="string">&quot;dragon boat festival&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    HolidayRequest request2(<span class="string">&quot;mid-autumn festival&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    HolidayRequest request3(<span class="string">&quot;spring festival&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    HolidayRequest request4(<span class="string">&quot;spring festival&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理请求(第一个处理者是SectionChief,从其开始)</span></span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request1</span>)</span>;</span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request2</span>)</span>;</span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request3</span>)</span>;</span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request4</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pD</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pM</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pS</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果:</p>
<pre><code>Section chief bill approve your 1 days for dragon boat festival request !
Minister bob approve your 2 days for mid-autumn festival request !
Minister bob approve your 3 days for spring festival request !
Director john approve your 4 days for spring festival request !--
</code></pre>
<p>title: 责任链模式(行为型)<br>date: 2016-4-20<br>categories: Design Pattern<br>tags:</p>
<ul>
<li>Design Pattern</li>
<li>Behavior Pattern</li>
</ul>
<hr>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在公司请年假的时候，需要首先在TMS系统提出申请，在提出申请的时候，发现申请不同的时间长短，审批的领导不一样，如不超过但是包括1天由科长(Section Chief)审批，超过1天但是不超过3天由部长(Minister)审批，超过3天以上由主任(Director)审批。在这个审批流程中，我们的年假请求沿着一条链在传递，每个请求处理者都根据请求的具体情况在自己的处理范围内进行审批，有一种专门用于处理这种请求链式传递的模式，它就是本章将要介绍的职责链模式。</p>
<!--more-->

<h2 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h2><hr>
<h3 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止</p>
<blockquote>
<p>常用的对象行为型设计模式之一，职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦</p>
</blockquote>
<h3 id="参与者-1"><a href="#参与者-1" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Handler<br>抽象处理者，定义了一个处理请求的接口，不同的具体处理者处理请求的实现不同<br>一般还包含一个抽象处理者的对象，作为其下家的引用。通过该引用，处理者可以连成一条链</p>
</li>
<li><p>ConcreteHandler<br>具体处理者，抽象处理者的子类，处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法<br>处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者(具体处理者中可以访问链中下一个对象，以便请求的转发)<br>具体处理者有两大作用：处理请求 &amp; 转发请求</p>
</li>
<li><p>Client<br>客户端，负责创建职责链，向链上的具体处理者(ConcreteHandler)对象提交请求</p>
</li>
</ul>
<h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://7xq8f9.com1.z0.glb.clouddn.com/pic%2FReponse_Abstract.PNG" alt="chainofresponsibility_pattern"></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象的<code>Handler</code>,并提供<code>HandlerRequest()</code>接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Handler</span></span><br><span class="line"><span class="keyword">class</span> Handler</span><br><span class="line">&#123;</span><br><span class="line">protected: <span class="comment">// protected,子类继承能访问和使用</span></span><br><span class="line">    Handler *m_pHandler; <span class="comment">// 请求的下个抽象处理者</span></span><br><span class="line">    <span class="built_in">int</span>     m_nState; <span class="comment">// 请求的参数</span></span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Handler(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : m<span class="constructor">_pHandler(<span class="params">pHandler</span>)</span> &#123;&#125;; </span><br><span class="line">    <span class="comment">//在构造函数中传入下一个处理者</span></span><br><span class="line">    <span class="comment">//也可以通过提供一个setHandler方法，传入Handler，动态设置传入下一个处理者</span></span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再分别定义<code>Handler</code>类的三个具体处理子类，并实现其中的<code>HandlerRequest()</code>接口，该接口主要作用是处理该请求或转发请求给下个处理者：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define  <span class="constructor">NULL_POINTER(<span class="params">ptr</span>)</span> (NULL<span class="operator"> == </span>ptr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Handler A</span></span><br><span class="line"><span class="keyword">class</span> ConcreteHandlerA : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteHandlerA(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : <span class="constructor">Handler(<span class="params">pHandler</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nState &lt; <span class="number">10</span>)    <span class="comment">// 权限范围内，处理该请求</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete Handler A Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;10 的情况下一个ConcreteHandler处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pHandler</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Handler Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pHandler-&gt;<span class="constructor">HandlerRequest(<span class="params">nState</span>)</span>;  <span class="comment">// 权限范围外，转发该请求让下一个处理者m_pHandler处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Handler B</span></span><br><span class="line"><span class="keyword">class</span> ConcreteHandlerB : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteHandlerB(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : <span class="constructor">Handler(<span class="params">pHandler</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nState &lt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete Handler B Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;20 的情况下一个ConcreteHandler处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pHandler</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Handler Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pHandler-&gt;<span class="constructor">HandlerRequest(<span class="params">nState</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Handler C</span></span><br><span class="line"><span class="keyword">class</span> ConcreteHandlerC : public Handler</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">ConcreteHandlerC(Handler <span class="operator">*</span><span class="params">pHandler</span>)</span> : <span class="constructor">Handler(<span class="params">pHandler</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandlerRequest(<span class="params">int</span> <span class="params">nState</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nState &lt; <span class="number">30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Concrete Handler C Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &gt;30 的情况下一个ConcreteHandler处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">m_pHandler</span>)</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No Handler Do The Request !!!&quot;</span> &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; nState &lt;&lt; endl;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pHandler-&gt;<span class="constructor">HandlerRequest(<span class="params">nState</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试责任链模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define  <span class="constructor">SAFE_RELASE_POINTER(<span class="params">ptr</span>)</span> <span class="keyword">if</span>(!<span class="constructor">NULL_POINTER(<span class="params">ptr</span>)</span>) &#123;delete ptr; ptr = NULL;&#125;</span><br><span class="line"></span><br><span class="line">void <span class="constructor">ResponseTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    Handler *pCHC = <span class="keyword">new</span> <span class="constructor">ConcreteHandlerC(NULL)</span>;</span><br><span class="line">    Handler *pCHB = <span class="keyword">new</span> <span class="constructor">ConcreteHandlerB(<span class="params">pCHC</span>)</span>;</span><br><span class="line">    Handler *pCHA = <span class="keyword">new</span> <span class="constructor">ConcreteHandlerA(<span class="params">pCHB</span>)</span>; </span><br><span class="line">    <span class="comment">//在构造函数的参数内指明每一个Handler的下一个Handler </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Concrete Handler A 开始往下处理</span></span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(5)</span>;</span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(15)</span>;</span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(25)</span>;</span><br><span class="line">    pCHA-&gt;<span class="constructor">HandlerRequest(35)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCHA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCHB</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pCHC</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果：</p>
<pre><code>Concrete Handler A Do The Request !!!State: 5
Concrete Handler B Do The Request !!!State: 15
Concrete Handler C Do The Request !!!State: 25
No Handler Do The Request !!!State: 35
</code></pre>
<h3 id="责任链模式的分类-1"><a href="#责任链模式的分类-1" class="headerlink" title="责任链模式的分类"></a>责任链模式的分类</h3><p>责任链模式根据请求是否能同时被多个处理对象处理或者请求是否能最终不被任何请求者处理，分为以下两类：</p>
<h4 id="纯的责任链模式-1"><a href="#纯的责任链模式-1" class="headerlink" title="纯的责任链模式"></a>纯的责任链模式</h4><ul>
<li>一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况</li>
<li>要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况</li>
</ul>
<h4 id="不纯的职责链模式-1"><a href="#不纯的职责链模式-1" class="headerlink" title="不纯的职责链模式"></a>不纯的职责链模式</h4><ul>
<li>一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求</li>
<li>而且一个请求可以最终不被任何处理者对象所接收</li>
</ul>
<blockquote>
<p>事件浮升(Event Bubbling)机制：在GUI组件的事件处理机制中,当事件发生在某一个组件时候,先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。<br>在这种场景中，每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况</p>
</blockquote>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的</li>
<li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
<li>可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度</li>
<li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接</li>
<li>在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责</li>
</ul>
</li>
<li>缺点<ul>
<li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环</li>
<li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理</li>
</ul>
</li>
</ul>
<h2 id="责任链模式具体实例-1"><a href="#责任链模式具体实例-1" class="headerlink" title="责任链模式具体实例"></a>责任链模式具体实例</h2><hr>
<h3 id="请假审批问题-1"><a href="#请假审批问题-1" class="headerlink" title="请假审批问题"></a>请假审批问题</h3><p><strong>使用责任链模式简单实现前言所述的请假审批过程</strong></p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><p>1.定义抽象的<code>HoliadyHandler</code>类，并提供<code>HandleHolidayRequest</code>接口:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Request Class to represent request content</span></span><br><span class="line"><span class="keyword">class</span> HolidayRequest</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _type;</span><br><span class="line">    <span class="built_in">int</span>    _days;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">HolidayRequest(<span class="params">string</span> <span class="params">type</span>, <span class="params">int</span> <span class="params">days</span>)</span> : <span class="constructor">_type(<span class="params">type</span>)</span>, <span class="constructor">_days(<span class="params">days</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> get<span class="constructor">Type(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> get<span class="constructor">Days(<span class="params">void</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        return _days;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract Handler</span></span><br><span class="line"><span class="keyword">class</span> HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    HoliadyHandler *_handler;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">HoliadyHandler()</span> : <span class="constructor">_handler(NULL)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 通过set方法来设置下一个处理者，供client调用</span></span><br><span class="line">    void set<span class="constructor">Handler(HoliadyHandler <span class="operator">*</span><span class="params">handler</span>)</span> </span><br><span class="line">    &#123;</span><br><span class="line">        _handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">virtual</span> void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别定义处理者<code>HolidayRequest</code>的子类<code>SectionChief</code>和<code>Minister</code>及<code>Director</code>:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sectin Chief Handler</span></span><br><span class="line"><span class="keyword">class</span> SectionChief : public HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">SectionChief(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.get<span class="constructor">Days()</span> &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Section chief &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; approve your &quot;</span> &lt;&lt; request.get<span class="constructor">Days()</span> &lt;&lt; <span class="string">&quot; days for &quot;</span> &lt;&lt; request.get<span class="constructor">Type()</span> &lt;&lt; <span class="string">&quot; request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">_handler</span>)</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No holiday handler is assigned !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _handler-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Minister Handler</span></span><br><span class="line"><span class="keyword">class</span> Minister : public HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Minister(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.get<span class="constructor">Days()</span> &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Minister &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; approve your &quot;</span> &lt;&lt; request.get<span class="constructor">Days()</span> &lt;&lt; <span class="string">&quot; days for &quot;</span> &lt;&lt; request.get<span class="constructor">Type()</span> &lt;&lt; <span class="string">&quot; request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">_handler</span>)</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No holiday handler is assigned !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _handler-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Director Handler</span></span><br><span class="line"><span class="keyword">class</span> Director : public HoliadyHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">public:</span><br><span class="line">    <span class="constructor">Director(<span class="params">string</span> <span class="params">name</span>)</span> : <span class="constructor">_name(<span class="params">name</span>)</span> &#123;&#125;;</span><br><span class="line">public:</span><br><span class="line">    void <span class="constructor">HandleHolidayRequest(HolidayRequest &amp;<span class="params">request</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.get<span class="constructor">Days()</span> &gt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Director &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; approve your &quot;</span> &lt;&lt; request.get<span class="constructor">Days()</span> &lt;&lt; <span class="string">&quot; days for &quot;</span> &lt;&lt; request.get<span class="constructor">Type()</span> &lt;&lt;  <span class="string">&quot; request !&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="constructor">NULL_POINTER(<span class="params">_handler</span>)</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No holiday handler is assigned !&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                _handler-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.测试责任链模式:</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">ResponseTest_Holiday()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 请求处理者</span></span><br><span class="line">    HoliadyHandler *pD = <span class="keyword">new</span> <span class="constructor">Director(<span class="string">&quot;john&quot;</span>)</span>;</span><br><span class="line">    HoliadyHandler *pM = <span class="keyword">new</span> <span class="constructor">Minister(<span class="string">&quot;bob&quot;</span>)</span>;</span><br><span class="line">    HoliadyHandler *pS = <span class="keyword">new</span> <span class="constructor">SectionChief(<span class="string">&quot;bill&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置责任链</span></span><br><span class="line">    pS-&gt;set<span class="constructor">Handler(<span class="params">pM</span>)</span>;</span><br><span class="line">    pM-&gt;set<span class="constructor">Handler(<span class="params">pD</span>)</span>;</span><br><span class="line">    pD-&gt;set<span class="constructor">Handler(NULL)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求</span></span><br><span class="line">    HolidayRequest request1(<span class="string">&quot;dragon boat festival&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    HolidayRequest request2(<span class="string">&quot;mid-autumn festival&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    HolidayRequest request3(<span class="string">&quot;spring festival&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    HolidayRequest request4(<span class="string">&quot;spring festival&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理请求(第一个处理者是SectionChief,从其开始)</span></span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request1</span>)</span>;</span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request2</span>)</span>;</span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request3</span>)</span>;</span><br><span class="line">    pS-&gt;<span class="constructor">HandleHolidayRequest(<span class="params">request4</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pD</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pM</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pS</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.运行结果:</p>
<pre><code>Section chief bill approve your 1 days for dragon boat festival request !
Minister bob approve your 2 days for mid-autumn festival request !
Minister bob approve your 3 days for spring festival request !
Director john approve your 4 days for spring festival request !
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式(行为型)</title>
    <url>/2018/02/01/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在C++ STL标准库里面有各种容器对象，如vector,list,map等等，对这些容器对象的遍历操作时候,都是首先获取相应容器的迭代器，再通过迭代器的begin方法,++操作符,end方法来遍历整个容器对象内的各个元素，使得容器对象的元素存储操作和遍历操作分离了，这样的好处是对于同一个类型的容器对象可以通过不同的遍历方法来遍历，同样的，不同的类型的容器对象也可以通过相同的遍历方法来进行。像STL标准库里面的这种解耦数据存储和遍历操作的方法就是本文将要介绍的迭代器模式。</p>
<span id="more"></span>

<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><hr>
<p>一般来说，聚合对象拥有两个职责存储数据和遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个<strong>迭代器</strong>的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合<strong>单一职责原则</strong>的要求</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示，别名游标。</p>
<blockquote>
<p>迭代器模式包含聚合和迭代器两个层次结构。迭代器里面都包含了创建迭代器的工厂模式</p>
</blockquote>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Iterator<br>抽象迭代器,定义了访问和遍历元素的接口<br>一般包含获取第一个元素的<code>first()</code>方法，访问下一个元素的<code>next()</code>方法，用于判断是否还有下一个元素的<code>hasNext()</code>方法，用于获取当前元素的<code>currentItem()</code>方法等。这些方法在具体的迭代器中被实现</p>
</li>
<li><p>ConcreteIterator<br>具体迭代器,实现了抽象迭代器声明的接口，完成对聚合对象的遍历，同时在具体迭代器中通过<strong>游标</strong>来记录在聚合对象中所处的当前位置，游标通常是一个非负整数<br>具体迭代器中通常包含一个聚合对象的引用来指明迭代的对象</p>
</li>
<li><p>Aggregate<br>抽象的聚合类，用于存储和管理元素对象，声明一个<code>createIterator()</code>方法用来创建一个迭代器对象，相当于抽象迭代器工厂的角色</p>
</li>
<li><p>ConcreteAggregate<br>具体的聚合类，实现了抽象聚合类的<code>createIterator()</code>方法，该方法返回一个具体聚合类对象的具体迭代器对象实例</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/02/01/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/Iterator.jpg" alt="iterator"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>1.首先定义抽象的迭代器类<code>Iterator</code>,并提供几个常用的聚合元素遍历操作接口：<code>First()</code> ,<code>Next()</code>,<code>Current()</code>, <code>IsDone()</code>等：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Iterator</span></span><br><span class="line"><span class="comment">// 模板类Iterator定义, 使用方法：template &lt;typename(class) T&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Iterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">First</span><span class="params">()</span>  </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span>   </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T* <span class="title">Current</span><span class="params">()</span>  </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsDone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.再定义具体迭代器类<code>ConcreteItertor</code>，并实现相应的接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span>;       <span class="comment">// 模板类Aggregate声明，template &lt;typename(class) T&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 模板类ConcreteItertor定义，template &lt;typename(class) T&gt;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteItertor</span>: <span class="keyword">public</span> Iterator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Aggregate&lt;T&gt; *m_pAggr;             <span class="comment">// 与某个聚合对象联系的迭代器</span></span><br><span class="line">    <span class="type">int</span> m_cur;                         <span class="comment">// 游标</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConcreteItertor</span>(Aggregate&lt;T&gt; *pAggr) : <span class="built_in">m_pAggr</span>(pAggr) &#123;&#125;; <span class="comment">//构造方式注入需要遍历的具体聚合对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">First</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cur &lt; (m_pAggr-&gt;<span class="built_in">GetLen</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            m_cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T* <span class="title">Current</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cur &lt; (m_pAggr-&gt;<span class="built_in">GetLen</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;((*m_pAggr)[m_cur]); <span class="comment">//  重载了操作符[]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (m_cur &gt;= (m_pAggr-&gt;<span class="built_in">GetLen</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.再定义抽象的聚合类<code>Aggregate</code>，并提供了与聚合元素存储相关的操作接口,同时还声明一个创建迭代器的工厂方法<code>CreateIterator()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Aggregate</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aggregate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 工厂方法创建迭代器</span></span><br><span class="line">    <span class="keyword">virtual</span> T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddItem</span><span class="params">(T t)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">RemoveItem</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ClearItem</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.定义一个具体的聚合类<code>ConcreteAggregate</code>,实现抽象聚合类中的工厂方法返回一个具体的聚合对象迭代器，同时实现相应的元素存储相关的操作:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Aggregate : 再封装了一次vector</span></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> : <span class="title">public</span> <span class="title">Aggregate</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; m_vecData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddItem</span>(<span class="params">T t</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_vecData.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_vecData.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearItem</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_vecData.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="built_in">int</span> index)    <span class="comment">// 重载[]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_vecData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetLen</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_vecData.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt;* <span class="title">CreateIterator</span>()   </span></span><br><span class="line"><span class="function">    <span class="comment">// 实现工厂方法，创建的具体聚合对象迭代器实例      </span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteItertor&lt;T&gt;(<span class="keyword">this</span>); <span class="comment">// 与当前聚合相关联的迭代器(this)  客户端负责创建和释放Iterator</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.测试迭代器模式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void <span class="constructor">IteratorTest_General()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建聚合对象</span></span><br><span class="line">    Aggregate&lt;<span class="built_in">int</span>&gt; *pA = <span class="keyword">new</span> ConcreteAggregate&lt;<span class="built_in">int</span>&gt;;</span><br><span class="line">    pA-&gt;<span class="constructor">AddItem(1)</span>;</span><br><span class="line">    pA-&gt;<span class="constructor">AddItem(2)</span>;</span><br><span class="line">    pA-&gt;<span class="constructor">AddItem(3)</span>;</span><br><span class="line">    pA-&gt;<span class="constructor">AddItem(4)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    Iterator&lt;<span class="built_in">int</span>&gt; *pI = pA-&gt;<span class="constructor">CreateIterator()</span>; <span class="comment">// 可以再次创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (pI-&gt;<span class="constructor">First()</span>; !pI-&gt;<span class="constructor">IsDone()</span>; pI-&gt;<span class="constructor">Next()</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Item: &quot;</span> &lt;&lt; *(pI-&gt;<span class="constructor">Current()</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pA</span>)</span>;</span><br><span class="line">    <span class="constructor">SAFE_RELASE_POINTER(<span class="params">pI</span>)</span>; <span class="comment">// 手动释放创建的迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行结果：</p>
<pre><code>Item: 1
Item: 2
Item: 3
Item: 4
</code></pre>
<h3 id="迭代器模式的分类"><a href="#迭代器模式的分类" class="headerlink" title="迭代器模式的分类"></a>迭代器模式的分类</h3><p>在迭代器模式结构图中，我们可以看到具体迭代器类和具体聚合类之间存在双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便迭代器能够对这些数据进行遍历操作，除了引用方式，还可以在聚合类的内部定义迭代器，迭代器模式根据具体迭代器的实现在具体聚合类的内部还是外部，可以分为两类：</p>
<h4 id="外部迭代器模式"><a href="#外部迭代器模式" class="headerlink" title="外部迭代器模式"></a>外部迭代器模式</h4><p>即一般模式的迭代器，具体迭代器需要一个聚合对象引用，通过关联关系来关联两个层次结构，即上述的例子实现</p>
<h4 id="内部迭代器模式"><a href="#内部迭代器模式" class="headerlink" title="内部迭代器模式"></a>内部迭代器模式</h4><p>具体迭代器的实现在聚合类的内部定义和实现,将具体的迭代器作为聚合类的内部类即可:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Aggregate : 再封装了一次vector</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> : <span class="keyword">public</span> Aggregate&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;T&gt; m_vecData;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line">    <span class="comment">/* 内部迭代器实现                                                                     */</span></span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;         <span class="comment">// 外部实现迭代器，模板类ConcreteItertor定义，需要template &lt;typename(class) T&gt;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ConcreteItertor</span>: <span class="keyword">public</span> Iterator&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Aggregate&lt;T&gt; *m_pAggr;             <span class="comment">// 与某个聚合对象联系的迭代器</span></span><br><span class="line">        <span class="type">int</span> m_cur; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ConcreteItertor</span>(Aggregate&lt;T&gt; *pAggr) : <span class="built_in">m_pAggr</span>(pAggr), <span class="built_in">m_cur</span>(<span class="number">0</span>) &#123;&#125;; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">First</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            m_cur = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cur &lt; (m_pAggr-&gt;<span class="built_in">GetLen</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                m_cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> T* <span class="title">Current</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (m_cur &lt; (m_pAggr-&gt;<span class="built_in">GetLen</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;((*m_pAggr)[m_cur]); <span class="comment">//  重载了操作符[]</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsDone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (m_cur &gt;= (m_pAggr-&gt;<span class="built_in">GetLen</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line">    <span class="comment">/* 内部迭代器实现                                                                     */</span></span><br><span class="line">    <span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddItem</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_vecData.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_vecData.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ClearItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_vecData.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)    <span class="comment">// 重载[]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> m_vecData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLen</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_vecData.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Iterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteItertor</span>&lt;T&gt;(<span class="keyword">this</span>); <span class="comment">// 与当前聚合相关联的迭代器，外部实现迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>无论使用哪种实现机制，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需通过调用工厂方法<code>createIterator()</code>即可得到一个可用的迭代器对象</p>
</blockquote>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节<br>-需要为一个聚合对象提供多种遍历方式</li>
<li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式，同时扩展方便</li>
<li>简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li>
</ul>
</li>
<li>缺点<ul>
<li>将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性</li>
</ul>
</li>
</ul>
<h2 id="迭代器模式具体实例"><a href="#迭代器模式具体实例" class="headerlink" title="迭代器模式具体实例"></a>迭代器模式具体实例</h2><hr>
<h3 id="STL顺序容器遍历问题"><a href="#STL顺序容器遍历问题" class="headerlink" title="STL顺序容器遍历问题"></a>STL顺序容器遍历问题</h3><p><strong>使用迭代器模式简单实现前言所述的STL顺序容器array和list的遍历功能</strong></p>
<p><strong>代码实现</strong><br>1.定义抽象顺序容器迭代器类<code>SequenceIterator</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Sequence Iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SequenceIterator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">first</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">currentItem</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isdone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.分别定义具体的顺序容器迭代器类<code>ArrayIterator</code>和<code>ListIterator</code>,并实现相应的遍历操作接口:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Array Iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayIterator</span> : <span class="keyword">public</span> SequenceIterator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Array&lt;T&gt; *m_pArray;</span><br><span class="line">    <span class="type">int</span> m_curpos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayIterator</span>(Array&lt;T&gt; *pArray): <span class="built_in">m_pArray</span>(pArray) &#123;&#125;; <span class="comment">//与具体的聚合对象关联的迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_curpos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_curpos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">currentItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*m_pArray)[m_curpos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isdone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (m_curpos &gt;= (m_pArray-&gt;<span class="built_in">GetSize</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete List Iterator</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//  a typedef template is illegal</span></span><br><span class="line"><span class="comment">/*typedef struct tag_Node</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    T Value;</span></span><br><span class="line"><span class="comment">    tag_Node *pNext;</span></span><br><span class="line"><span class="comment">&#125;Node;  </span></span><br><span class="line"><span class="comment"> 可以用using C++11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T Value;</span><br><span class="line">    Node&lt;T&gt; *pNext;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//List的结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListIterator</span> : <span class="keyword">public</span> SequenceIterator&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    List&lt;T&gt;   *m_pList;</span><br><span class="line">    Node&lt;T&gt;   *m_pcurNode;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ListIterator</span>(List&lt;T&gt; *m_List): <span class="built_in">m_pList</span>(m_List) &#123;&#125;; <span class="comment">//与具体的聚合对象关联的迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pcurNode = m_pList-&gt;<span class="built_in">GetHeader</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_pcurNode = m_pcurNode-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">currentItem</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pcurNode-&gt;Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isdone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (m_pcurNode == m_pList-&gt;<span class="built_in">GetTailerPast</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.定义抽象的顺序容器聚合类<code>Sequence</code>,声明存储元素操作和迭代器工厂方法<code>CreateIterator()</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Abstract Sequence</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sequence</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SequenceIterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span>  <span class="title">GetSize</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PushBack</span><span class="params">(T t)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp;   <span class="title">PopBack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>= <span class="number">0</span>;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.分别定义具体的容器类<code>Array</code>及<code>List</code>,实现存储元素操作和迭代器工厂方法<code>CreateIterator()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Concrete Sequence : Array,通过数组方式实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> : <span class="keyword">public</span> Sequence&lt;T&gt;    <span class="comment">// []只有</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T m_data[ARRAY_MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> m_count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(m_data, <span class="number">0</span>, <span class="built_in">sizeof</span>(T)* ARRAY_MAX_SIZE);</span><br><span class="line">        m_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SequenceIterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//具体的工厂方法，返回array iterator</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ArrayIterator</span>&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PushBack</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_count &gt;= ARRAY_MAX_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Array Is Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_data[m_count++] = t;</span><br><span class="line">        <span class="keyword">if</span> (m_count &gt;= ARRAY_MAX_SIZE) <span class="comment">// 最后一次PUSH之后，初始化curindex = ARRAY_MAX_SIZE - 1;</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_count = ARRAY_MAX_SIZE - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_count &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Array Is Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = m_data[--m_count];</span><br><span class="line">        m_data[m_count] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (m_count &lt; <span class="number">0</span>) <span class="comment">// 最后一次POP之后，初始化curindex = 0;</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(m_data, <span class="number">0</span>, <span class="built_in">sizeof</span>(T)* ARRAY_MAX_SIZE);</span><br><span class="line">        m_count = <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">// Array 特有的方法</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index)</span><br><span class="line">    &#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= ARRAY_MAX_SIZE))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Index Is Out Of Array Range&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = m_data[index];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concrete Sequence : List,通过单链表方式实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> : <span class="keyword">public</span> Sequence&lt;T&gt; <span class="comment">//-&gt;只有</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *m_pHead;</span><br><span class="line">    Node&lt;T&gt; *m_pTail;</span><br><span class="line">    <span class="type">int</span>   m_Count;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">List</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_pHead = <span class="literal">NULL</span>;</span><br><span class="line">        m_pTail = <span class="literal">NULL</span>;</span><br><span class="line">        m_Count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">List</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SequenceIterator&lt;T&gt;* <span class="title">CreateIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     <span class="comment">//具体的工厂方法，返回list iterator</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ListIterator</span>&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">GetSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PushBack</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node&lt;T&gt; *pNewNode = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        pNewNode-&gt;Value = t;</span><br><span class="line">        pNewNode-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NULL_POINTER</span>(m_pHead)) <span class="comment">// 空的List</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_pHead = m_pTail = pNewNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_pTail-&gt;pNext = pNewNode;</span><br><span class="line">            m_pTail = pNewNode;</span><br><span class="line">        &#125;</span><br><span class="line">        ++m_Count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T&amp; <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NULL_POINTER</span>(m_pHead))</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;List Is Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;T&gt; *pTmp = m_pHead;</span><br><span class="line">        <span class="keyword">while</span> (pTmp-&gt;pNext != m_pTail &amp;&amp; (m_pHead != m_pTail)) <span class="comment">// 找出m_pTail的前面一个结点，即pTmp-&gt;pNext = m_pTail</span></span><br><span class="line">        &#123;</span><br><span class="line">            pTmp = pTmp-&gt;pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = m_pTail-&gt;Value;  <span class="comment">// 最后一个是m_pTail</span></span><br><span class="line">        <span class="keyword">if</span> (m_pHead == m_pTail)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pHead =  <span class="literal">NULL</span>; <span class="comment">// m_pHead 防止指针悬挂，野指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SAFE_RELASE_POINTER</span>(m_pTail);</span><br><span class="line">        m_pTail = pTmp;</span><br><span class="line">        m_pTail-&gt;pNext = <span class="literal">NULL</span>; <span class="comment">// 最后一个结点的pNext = NULL,便于删除的时候判断</span></span><br><span class="line">        pTmp    = <span class="literal">NULL</span>;</span><br><span class="line">        --m_Count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node&lt;T&gt; *pTmp = m_pHead;</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">NULL_POINTER</span>(pTmp))</span><br><span class="line">        &#123;</span><br><span class="line">            m_pHead = pTmp-&gt;pNext;</span><br><span class="line">            <span class="built_in">SAFE_RELASE_POINTER</span>(pTmp);</span><br><span class="line">            pTmp = m_pHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// List 特有的方法</span></span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">GetHeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node&lt;T&gt;* <span class="title">GetTailerPast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NULL_POINTER</span>(m_pTail))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pTail-&gt;pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.测试迭代器模式:</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">void IteratorTest_Sequence()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before Array Pop Back:&quot;</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    Array&lt;int&gt; *pA <span class="operator">=</span> new Array&lt;int&gt;<span class="comment">;</span></span><br><span class="line">    pA-&gt;PushBack(<span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">    pA-&gt;PushBack(<span class="number">20</span>)<span class="comment">;</span></span><br><span class="line">    pA-&gt;PushBack(<span class="number">30</span>)<span class="comment">;</span></span><br><span class="line">    pA-&gt;PushBack(<span class="number">40</span>)<span class="comment">;</span></span><br><span class="line">    SequenceIterator&lt;int&gt; *pIA <span class="operator">=</span> pA-&gt;CreateIterator()<span class="comment">;</span></span><br><span class="line">    for (pIA-&gt;first()<span class="comment">; !pIA-&gt;isdone(); pIA-&gt;next())</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array: &quot;</span> &lt;&lt; pIA-&gt;currentItem() &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After Array Pop Back:&quot;</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    int arrayPopRes <span class="operator">=</span> pA-&gt;PopBack()<span class="comment">;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array Pop Result is: &quot;</span> &lt;&lt; arrayPopRes &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    for (pIA-&gt;first()<span class="comment">; !pIA-&gt;isdone(); pIA-&gt;next())</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Array: &quot;</span> &lt;&lt; pIA-&gt;currentItem() &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before List Pop Back:&quot;</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    List&lt;int&gt; *pL <span class="operator">=</span> new List&lt;int&gt;<span class="comment">;</span></span><br><span class="line">    pL-&gt;PushBack(<span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">    pL-&gt;PushBack(<span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">    pL-&gt;PushBack(<span class="number">300</span>)<span class="comment">;</span></span><br><span class="line">    pL-&gt;PushBack(<span class="number">400</span>)<span class="comment">;</span></span><br><span class="line">    SequenceIterator&lt;int&gt; *pIL <span class="operator">=</span> pL-&gt;CreateIterator()<span class="comment">;</span></span><br><span class="line">    for (pIL-&gt;first()<span class="comment">; !pIL-&gt;isdone(); pIL-&gt;next())</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;List: &quot;</span> &lt;&lt; pIL-&gt;currentItem() &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After List Pop Back:&quot;</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    int listPopRes <span class="operator">=</span> pL-&gt;PopBack()<span class="comment">;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;List Pop Result is: &quot;</span> &lt;&lt; listPopRes &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    for (pIL-&gt;first()<span class="comment">; !pIL-&gt;isdone(); pIL-&gt;next())</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;List: &quot;</span> &lt;&lt; pIL-&gt;currentItem() &lt;&lt; endl<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SAFE_RELASE_POINTER(pA)<span class="comment">;</span></span><br><span class="line">    SAFE_RELASE_POINTER(pIA)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    SAFE_RELASE_POINTER(pL)<span class="comment">;</span></span><br><span class="line">    SAFE_RELASE_POINTER(pIL)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.运行结果:</p>
<pre><code>Before Array Pop Back:
Array: 10
Array: 20
Array: 30
Array: 40
After Array Pop Back:
Array Pop Result is: 40
Array: 10
Array: 20
Array: 30
Before List Pop Back:
List: 100
List: 200
List: 300
List: 400
After List Pop Back:
List Pop Result is: 400
List: 100
List: 200
List: 300
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Behavior Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式(结构型)</title>
    <url>/2018/08/03/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>有些小伙伴喜欢去像美国、加拿大，包括中国台湾等国家或地区旅游时候，准备不充分的时候出现这样尴尬的情况:当手机没电的时候，想用自己从国内带的充电器充电时候发现充电器罢工不能用了，这是因为上述这些国家的插座使用的不是国内50Hz的220V电压，而是60Hz的110V电压供电的，电压低了1倍，自然是不能用了。有经验的童鞋会准备一个电源插座转换器，将110V电压转为国内标准的220V电压。这里所说的转换器，其实就是起到一个适配电压的目的，也就是本篇要讨论的适配器模式。</p>
<span id="more"></span>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><hr>
<p>适配器模式，就是将原本接口不兼容的两个类之间通过一个适配器来使被适配的类能被目标类所使用，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。适配器就是在不兼容的东西之间搭建一座桥梁，让二者能很好的兼容在一起工作,分为两种形式：</p>
<ul>
<li>类适配器</li>
</ul>
<blockquote>
<p>类适配器使用<strong>多重继承</strong>对一个接口与另一个接口进行匹配</p>
</blockquote>
<ul>
<li>对象适配器</li>
</ul>
<blockquote>
<p>对象适配器使用<strong>对象组合</strong>对一个接口与另一个接口进行匹配</p>
</blockquote>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><ul>
<li><p>Target<br>定义Client使用的与特定领域相关的接口</p>
</li>
<li><p>Adaptee<br>定义一个已经存在的接口，这个接口需要适配</p>
</li>
<li><p>Adapter<br>对Adaptee的接口与Target的接口进行适配</p>
</li>
<li><p>Client<br>与符合Target接口的对象协同</p>
</li>
</ul>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p><img src="http://www.taolingyang.com/2018/08/03/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/Adapter.jpg" alt="adapter"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h4><ol>
<li><p>首先定义一个要适配的目标类<code>Target</code>,及接口<code>Request()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Target</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Target Request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个要被适配的类<code>Adaptee</code>,及其接口<code>SpecialRequest()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SpecialRequest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adaptee Special Request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义适配器类<code>Adapter</code>,通过多重继承来适配两者,通过调用<code>adaptee</code>类的<code>Request()</code> 接口Override <code>Request()</code>接口的方式来进行适配：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Adapter: <span class="symbol">public</span></span> <span class="symbol">Target, <span class="symbol">public</span></span> <span class="symbol">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Request()          <span class="comment">// Override Target&#x27;s Request()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpecialRequest();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adapter Request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类适配器模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrototypeTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Class Adapter Test</span></span><br><span class="line">   Target *pT = <span class="keyword">new</span> <span class="built_in">Adapter</span>();</span><br><span class="line">   pT-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">delete</span> pT; pT = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Adaptee Special Request
Adapter Request
</code></pre>
<h4 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h4><ol>
<li><p>首先定义一个目标类<code>Target_Obj</code>,同样实现其<code>Request()</code>接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Target_Obj</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Target_Obj() &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~Target_Obj() &#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Target_Obj Request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>然后定义一个被适配的类<code>Adaptee_Obj</code>,同样提供一个<code>SpecialRequest()</code>接口:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Adaptee_Obj</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SpecialRequest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adaptee_Obj Special Request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>最后定义一个适配器类，此类仅继承目标类，被适配器类是通过对象组合的方式来进行适配的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter_Obj</span>: <span class="keyword">public</span> Target_Obj</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Adaptee_Obj *m_pAdaptee;  <span class="comment">// 对象组合方式来适配</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Adapter_Obj</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        m_pAdaptee = <span class="keyword">new</span> <span class="built_in">Adaptee_Obj</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Adapter_Obj</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != m_pAdaptee)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_pAdaptee;</span><br><span class="line">            m_pAdaptee = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Request</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_pAdaptee)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;new Adaptee Failed!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_pAdaptee-&gt;<span class="built_in">SpecialRequest</span>();<span class="comment">//调用被适配的对象方法</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Adapter_Obj Request&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试对象适配器模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AdapterTest_General</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Object Adapter Test</span></span><br><span class="line">    Target_Obj *pTO = <span class="keyword">new</span> <span class="built_in">Adapter_Obj</span>();</span><br><span class="line">    pTO-&gt;<span class="built_in">Request</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pTO; pTO = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>Adaptee_Obj Special Request
Adapter_Obj Request
</code></pre>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>使用一个已经存在的类，如果它的接口和你实际要求的不一致时，可以考虑使用适配器模式</li>
<li>要在调用者和功能提供者双方都不太容易修改的时候再使用适配器模式，而不是一有不同时就使用它</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点<ul>
<li>降低了去实现一个功能点的难度，可以对现有的类进行包装，就可以进行使用了</li>
<li>目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用</li>
<li>提高了项目质量，现有的类一般都是经过测试的，使用了适配器模式之后，不需要对旧的类进行全面的覆盖测试</li>
<li>对象适配器还有如下优点：<ul>
<li>一个对象适配器可以把多个不同的适配者适配到同一个目标</li>
<li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配</li>
</ul>
</li>
</ul>
</li>
<li>缺点<ul>
<li>类适配器使用多重继承，对于被继承的多个父类如果有共同的基类，会出现歧义(虽然可以通过虚拟继承来解决，但是使系统的类继承体系膨胀)</li>
<li>对象适配器模式与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，其将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂</li>
</ul>
</li>
</ul>
<h2 id="适配器模式具体实例"><a href="#适配器模式具体实例" class="headerlink" title="适配器模式具体实例"></a>适配器模式具体实例</h2><hr>
<h3 id="实例1-—-STL标准库"><a href="#实例1-—-STL标准库" class="headerlink" title="实例1 — STL标准库"></a>实例1 — STL标准库</h3><p><strong>使用STL的双端队列deque类中的方法实现STL的队列queue &amp; 栈stack类，并实现其中的push和pop方法</strong></p>
<ol>
<li><p>被适配的类<code>Deque</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双端队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; cout&lt;&lt;<span class="string">&quot;Deque push_back&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123; cout&lt;&lt;<span class="string">&quot;Deque push_front&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span>()</span> &#123; cout&lt;&lt;<span class="string">&quot;Deque pop_back&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span>()</span> &#123; cout&lt;&lt;<span class="string">&quot;Deque pop_front&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Queue</code>和<code>Stack</code>均属于<code>Sequence</code>类型（适配器的目标类型）:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//顺序容器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Sequence</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">pop</span>()</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>Deque</code>分别适配为<code>Queue</code>和<code>Stack</code>类,并实现<code>push()</code>和<code>pop()</code>方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈:先进后出FILO</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>: <span class="keyword">public</span> Sequence</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        deque.<span class="built_in">push_back</span>(x); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack push&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        deque.<span class="built_in">pop_back</span>(); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Stack pop&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Deque deque; <span class="comment">//双端队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列：先进先出FIFO</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>: <span class="keyword">public</span> Sequence</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        deque.<span class="built_in">push_back</span>(x);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Queue push&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        deque.<span class="built_in">pop_front</span>(); </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Queue pop&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Deque deque; <span class="comment">//双端队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试STL适配器模式：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AdapterTest_STL()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// STL Sequence Obj Test</span></span><br><span class="line">    Sequence *s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">    Sequence *s2 = <span class="keyword">new</span> Queue();</span><br><span class="line">    s1-&gt;<span class="keyword">push</span>(<span class="number">1</span>); s1-&gt;<span class="keyword">pop</span>();</span><br><span class="line">    s2-&gt;<span class="keyword">push</span>(<span class="number">1</span>); s2-&gt;<span class="keyword">pop</span>();</span><br><span class="line">    <span class="keyword">delete</span> s1; <span class="keyword">delete</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果:</p>
<p> Deque push_back<br> Stack push<br> Deque pop_back<br> Stack pop<br> Deque push_back<br> Queue push<br> Deque pop_front<br> Queue pop</p>
</li>
</ol>
<h3 id="实例2-—-电源适配器"><a href="#实例2-—-电源适配器" class="headerlink" title="实例2 — 电源适配器"></a>实例2 — 电源适配器</h3><p><strong>实现前言所描述的电源适配器</strong></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li><p>被适配的美国类型插座类<code>USASocket</code>：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Adaptee socket</span></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">USASocket</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// USA socket;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> provideUSAVolt(<span class="built_in">void</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">110</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>目标类中国类型插座类<code>CHNSocket</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Target socket</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CHNSocket</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// China socket;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">provideChinaVolt</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>美国–&gt;中国插座转换器类<code>SocketAdapter</code>(采用对象适配器模式)：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">//  socket Adapter</span><br><span class="line">class SocketAdapter<span class="keyword"> :</span><span class="keyword"> public</span> CHNSocket</span><br><span class="line">&#123;<span class="keyword"></span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    USASocket* _usaSocket;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SocketAdapter(USASocket *socket):_usaSocket(socket) &#123;&#125;;<span class="keyword"></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in"> int </span>provideChinaVolt(void)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in"> if </span>(NULL != _usaSocket)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in"> return </span>_usaSocket-&gt;provideUSAVolt() * 2; </span><br><span class="line">            //<span class="built_in"> invoke </span>USASocket method to convert usa volt ---&gt; chn volt</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试实例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"> void <span class="constructor">AdapterTest_Socket()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Socket Adapter Test:</span></span><br><span class="line">    USASocket *s1 = <span class="keyword">new</span> <span class="constructor">USASocket()</span>;</span><br><span class="line">    SocketAdapter *s2 = <span class="keyword">new</span> <span class="constructor">SocketAdapter(<span class="params">s1</span>)</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;before convert volt is: &quot;</span> &lt;&lt; s1-&gt;provide<span class="constructor">USAVolt()</span>   &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;after convert volt is: &quot;</span>  &lt;&lt; s2-&gt;provide<span class="constructor">ChinaVolt()</span> &lt;&lt; endl;</span><br><span class="line">    delete s1; delete s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>运行结果：</p>
<pre><code>before convert volt is: 110
after convert volt is: 220
</code></pre>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Structural Pattern</tag>
      </tags>
  </entry>
</search>
